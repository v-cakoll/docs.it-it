---
title: Strategie di gestione degli errori parziali
description: Architettura di microservizi .NET per applicazioni .NET in contenitori | Strategie di gestione degli errori parziali
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: c36ea31ad19b02fb02bc8e7185bfe8687b87764f
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 06/29/2018
ms.locfileid: "37104209"
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="b11e8-103">Strategie di gestione degli errori parziali</span><span class="sxs-lookup"><span data-stu-id="b11e8-103">Strategies for handling partial failure</span></span>

<span data-ttu-id="b11e8-104">Le strategie di gestione degli errori parziali sono le seguenti.</span><span class="sxs-lookup"><span data-stu-id="b11e8-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="b11e8-105">**Usare la comunicazione asincrona, ad esempio la comunicazione basata su messaggi, tra i microservizi interni**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="b11e8-106">È consigliabile evitare di creare lunghe catene di chiamate HTTP sincrone tra i microservizi perché questa progettazione non corretta diventerà alla fine la causa principale delle interruzioni di servizio.</span><span class="sxs-lookup"><span data-stu-id="b11e8-106">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="b11e8-107">Al contrario, ad eccezione delle comunicazioni front-end tra le applicazioni client e il primo livello dei microservizi o i gateway API con granularità fine, è consigliabile usare solo la comunicazione asincrona (basata su messaggi) immediatamente al termine del ciclo di richiesta/risposta iniziale, tra i microservizi interni.</span><span class="sxs-lookup"><span data-stu-id="b11e8-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="b11e8-108">Le architetture di coerenza finale e basate su eventi consentiranno di ridurre al minimo l'effetto domino.</span><span class="sxs-lookup"><span data-stu-id="b11e8-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="b11e8-109">Questi approcci impongono un livello di autonomia dei microservizi più elevato e consentono di prevenire il problema specificato.</span><span class="sxs-lookup"><span data-stu-id="b11e8-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="b11e8-110">**Usare i tentativi con backoff incrementale**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="b11e8-111">Questa tecnica permette di evitare errori brevi e intermittenti tramite la ripetizione delle chiamate per un determinato numero di volte, nel caso in cui il servizio non sia stato disponibile per un breve periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="b11e8-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="b11e8-112">Questa situazione può essere causata da problemi di rete intermittenti o quando un microservizio/contenitore viene spostato in un altro nodo del cluster.</span><span class="sxs-lookup"><span data-stu-id="b11e8-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="b11e8-113">Tuttavia, se i tentativi non sono progettati correttamente con interruttori di circuito, l'effetto domino può aggravarsi fino a generare un errore di tipo [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="b11e8-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="b11e8-114">**Usare i timeout di rete**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-114">**Work around network timeouts**.</span></span> <span data-ttu-id="b11e8-115">In generale, i client devono essere progettati in modo da non bloccarsi a tempo indefinito e per usare sempre i timeout durante l'attesa per una risposta.</span><span class="sxs-lookup"><span data-stu-id="b11e8-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="b11e8-116">L'uso dei timeout garantisce che le risorse non rimangano bloccate per un periodo di tempo indefinito.</span><span class="sxs-lookup"><span data-stu-id="b11e8-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="b11e8-117">**Usare lo schema Circuit Breaker**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="b11e8-118">Con questo approccio, il processo client tiene traccia del numero di richieste non riuscite.</span><span class="sxs-lookup"><span data-stu-id="b11e8-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="b11e8-119">Se la frequenza di errori supera un limite configurato, si attiva un "interruttore di circuito" affinché i tentativi successivi abbiano immediatamente esito negativo.</span><span class="sxs-lookup"><span data-stu-id="b11e8-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="b11e8-120">Se un numero elevato di richieste presenta errori, il servizio potrebbe non essere disponibile e risulta inutile inviare altre richieste. Trascorso il periodo di timeout, il client deve riprovare e, se le nuove richieste hanno esito positivo, l'interruttore di circuito si chiude.</span><span class="sxs-lookup"><span data-stu-id="b11e8-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="b11e8-121">**Fornire fallback**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-121">**Provide fallbacks**.</span></span> <span data-ttu-id="b11e8-122">Con questo approccio, il processo client esegue la logica di fallback in caso di esito negativo di una richiesta, ad esempio restituendo i dati memorizzati nella cache o un valore predefinito.</span><span class="sxs-lookup"><span data-stu-id="b11e8-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="b11e8-123">Questo approccio è adatto alle query, ma risulta più complesso per gli aggiornamenti o i comandi.</span><span class="sxs-lookup"><span data-stu-id="b11e8-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="b11e8-124">**Limitare il numero di richieste in coda**.</span><span class="sxs-lookup"><span data-stu-id="b11e8-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="b11e8-125">I client devono inoltre imporre una soglia massima per il numero di richieste in sospeso che un microservizio può inviare a un determinato servizio.</span><span class="sxs-lookup"><span data-stu-id="b11e8-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="b11e8-126">Se il limite è stato raggiunto, è inutile inviare richieste aggiuntive, quindi questi tentativi devono avere immediatamente esito negativo.</span><span class="sxs-lookup"><span data-stu-id="b11e8-126">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="b11e8-127">In termini di implementazione, è possibile usare i criteri [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) (isolamento a scomparti) in Polly per soddisfare questo requisito.</span><span class="sxs-lookup"><span data-stu-id="b11e8-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="b11e8-128">Questo approccio rappresenta semplicemente una limitazione della parallelizzazione con <xref:System.Threading.SemaphoreSlim> come implementazione.</span><span class="sxs-lookup"><span data-stu-id="b11e8-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="b11e8-129">Consente anche la creazione di una "coda" all'esterno dello scomparto.</span><span class="sxs-lookup"><span data-stu-id="b11e8-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="b11e8-130">È possibile rimuovere il carico in eccesso anche prima dell'esecuzione, ad esempio se la capacità è considerata piena.</span><span class="sxs-lookup"><span data-stu-id="b11e8-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="b11e8-131">La risposta a determinati scenari di errori risulta quindi più veloce rispetto a quella di un interruttore di circuito, dal momento che l'interruttore rimane in attesa degli errori.</span><span class="sxs-lookup"><span data-stu-id="b11e8-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="b11e8-132">L'oggetto BulkheadPolicy in Polly mostra il livello di riempimento di scomparto e coda, offre eventi di overflow e può anche essere usato per aumentare automaticamente il numero di istanze.</span><span class="sxs-lookup"><span data-stu-id="b11e8-132">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b11e8-133">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="b11e8-133">Additional resources</span></span>

-   <span data-ttu-id="b11e8-134">**Modelli di resilienza**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="b11e8-134">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="b11e8-135">**Aggiunta di resilienza e ottimizzazione delle prestazioni**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="b11e8-135">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="b11e8-136">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="b11e8-136">**Bulkhead.**</span></span> <span data-ttu-id="b11e8-137">Repository GitHub.</span><span class="sxs-lookup"><span data-stu-id="b11e8-137">GitHub repo.</span></span> <span data-ttu-id="b11e8-138">Implementazione con i criteri Polly.\\</span><span class="sxs-lookup"><span data-stu-id="b11e8-138">Implementation with Polly policy.\\</span></span>
    [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="b11e8-139">**Progettazione di applicazioni resilienti per Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="b11e8-139">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="b11e8-140">**Gestione degli errori temporanei**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="b11e8-140">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="b11e8-141">[Precedente](handle-partial-failure.md)
[Successivo](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="b11e8-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
