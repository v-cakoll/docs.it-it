---
title: Automatic Memory Management
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, automatic memory management
- memory, allocating
- memory, automatic memory management
- memory, releasing
- common language runtime, automatic memory management
- automatic memory management
- managed heap
- runtime, automatic memory management
ms.assetid: d4850de5-fa63-4936-a250-5678d118acba
ms.openlocfilehash: 1038f16dca507e58005189c9558a9ec8dae4b34f
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159702"
---
# <a name="automatic-memory-management"></a><span data-ttu-id="d4b56-102">Automatic Memory Management</span><span class="sxs-lookup"><span data-stu-id="d4b56-102">Automatic Memory Management</span></span>
<span data-ttu-id="d4b56-103">Gestione automatica della memoria è uno dei servizi offerti da Common Language Runtime durante l'[esecuzione gestita](../../docs/standard/managed-execution-process.md).</span><span class="sxs-lookup"><span data-stu-id="d4b56-103">Automatic memory management is one of the services that the Common Language Runtime provides during [Managed Execution](../../docs/standard/managed-execution-process.md).</span></span> <span data-ttu-id="d4b56-104">L'allocazione e il rilascio di memoria per un'applicazione vengono gestiti da Garbage Collector di Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="d4b56-104">The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="d4b56-105">Agli sviluppatori non viene quindi richiesta la scrittura di codice per eseguire attività di gestione della memoria quando si sviluppano applicazioni gestite.</span><span class="sxs-lookup"><span data-stu-id="d4b56-105">For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</span></span> <span data-ttu-id="d4b56-106">La gestione automatica della memoria consente di evitare che si verifichino i problemi consueti legati alla gestione della memoria, quale la mancata liberazione di un oggetto e il conseguente spreco di memoria allocata ma non più referenziabile o il tentativo di accesso alla memoria per un oggetto già liberato.</span><span class="sxs-lookup"><span data-stu-id="d4b56-106">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</span></span> <span data-ttu-id="d4b56-107">In questa sezione viene descritta la modalità utilizzata dal Garbage Collector per l'allocazione e il rilascio di memoria.</span><span class="sxs-lookup"><span data-stu-id="d4b56-107">This section describes how the garbage collector allocates and releases memory.</span></span>  
  
## <a name="allocating-memory"></a><span data-ttu-id="d4b56-108">Allocazione di memoria</span><span class="sxs-lookup"><span data-stu-id="d4b56-108">Allocating Memory</span></span>  
 <span data-ttu-id="d4b56-109">Quando si inizializza un nuovo processo, per tale processo viene riservata una regione contigua di spazio degli indirizzi.</span><span class="sxs-lookup"><span data-stu-id="d4b56-109">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="d4b56-110">Lo spazio degli indirizzi riservato viene definito heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-110">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="d4b56-111">Nell'heap gestito viene conservato un puntatore all'indirizzo in cui verrà allocato il successivo oggetto dell'heap.</span><span class="sxs-lookup"><span data-stu-id="d4b56-111">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="d4b56-112">Le impostazioni iniziali del puntatore corrispondono all'indirizzo di base dell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-112">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="d4b56-113">Tutti i [tipi di riferimento](../../docs/standard/base-types/common-type-system.md) vengono allocati nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-113">All [reference types](../../docs/standard/base-types/common-type-system.md) are allocated on the managed heap.</span></span> <span data-ttu-id="d4b56-114">Quando il primo tipo di riferimento viene creato da un'applicazione, per tale tipo viene allocata memoria nell'indirizzo di base dell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-114">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="d4b56-115">Quando l'oggetto successivo viene creato dall'applicazione, la memoria destinata a tale oggetto viene allocata dal Garbage Collector nello spazio degli indirizzi immediatamente successivo al primo oggetto.</span><span class="sxs-lookup"><span data-stu-id="d4b56-115">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="d4b56-116">Lo spazio per i nuovi oggetti verrà allocato in questo modo dal Garbage Collector fino all'esaurimento dello spazio degli indirizzi.</span><span class="sxs-lookup"><span data-stu-id="d4b56-116">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>  
  
 <span data-ttu-id="d4b56-117">L'allocazione della memoria dall'heap gestito risulta più veloce dell'allocazione di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="d4b56-117">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="d4b56-118">Poiché la memoria per un oggetto viene allocata da Common Language Runtime tramite un incremento di un valore a un puntatore, tale operazione risulta veloce almeno quanto l'allocazione di memoria dallo stack.</span><span class="sxs-lookup"><span data-stu-id="d4b56-118">Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="d4b56-119">Poiché inoltre i nuovi oggetti allocati consecutivamente vengono archiviati in modo contiguo nell'heap gestito, l'accesso a tali oggetti da parte dell'applicazione risulta molto rapido.</span><span class="sxs-lookup"><span data-stu-id="d4b56-119">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</span></span>  
  
<a name="cpconautomaticmemorymanagementreleasingmemoryanchor1"></a>
## <a name="releasing-memory"></a><span data-ttu-id="d4b56-120">Rilascio di memoria</span><span class="sxs-lookup"><span data-stu-id="d4b56-120">Releasing Memory</span></span>  
 <span data-ttu-id="d4b56-121">Il modulo di ottimizzazione del Garbage Collector consente di determinare il momento migliore per l'esecuzione di una raccolta sulla base delle allocazioni in corso.</span><span class="sxs-lookup"><span data-stu-id="d4b56-121">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="d4b56-122">Durante l'esecuzione di una raccolta, la memoria per gli oggetti non più utilizzati dall'applicazione viene rilasciata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="d4b56-122">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="d4b56-123">L'individuazione degli oggetti non più in uso viene effettuata tramite l'esame delle radici dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="d4b56-123">It determines which objects are no longer being used by examining the application's roots.</span></span> <span data-ttu-id="d4b56-124">Ogni applicazione dispone di un insieme di radici.</span><span class="sxs-lookup"><span data-stu-id="d4b56-124">Every application has a set of roots.</span></span> <span data-ttu-id="d4b56-125">Ogni radice fa riferimento a un oggetto dell'heap gestito o è impostata su null.</span><span class="sxs-lookup"><span data-stu-id="d4b56-125">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="d4b56-126">Le radici di un'applicazione includono campi statici, variabili e parametri locali su uno stack di thread e registri della CPU.</span><span class="sxs-lookup"><span data-stu-id="d4b56-126">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="d4b56-127">Garbage Collector ha accesso all'elenco delle radici attive mantenute dal [compilatore JIT](../../docs/standard/managed-execution-process.md) e dal runtime.</span><span class="sxs-lookup"><span data-stu-id="d4b56-127">The garbage collector has access to the list of active roots that the [just-in-time (JIT) compiler](../../docs/standard/managed-execution-process.md) and the runtime maintain.</span></span> <span data-ttu-id="d4b56-128">Usando questo elenco, il Garbage Collector esamina le radici dell'applicazione e crea, nel corso di tale esame, un grafico contenente tutti gli oggetti raggiungibili dalle directory radice.</span><span class="sxs-lookup"><span data-stu-id="d4b56-128">Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</span></span>  
  
 <span data-ttu-id="d4b56-129">Gli oggetti non inclusi nel grafo non sono raggiungibili dalle radici dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="d4b56-129">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="d4b56-130">Gli oggetti non raggiungibili vengono considerati dal Garbage Collector come oggetti da eliminare e la memoria allocata per tali oggetti viene rilasciata.</span><span class="sxs-lookup"><span data-stu-id="d4b56-130">The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</span></span> <span data-ttu-id="d4b56-131">Nel corso di una raccolta, l'heap gestito viene esaminato dal Garbage Collector, alla ricerca dei blocchi di spazi degli indirizzi occupati da oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="d4b56-131">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="d4b56-132">Quando un oggetto non raggiungibile viene rilevato, viene utilizzata una funzione di copia della memoria che consente di ricompattare lo spazio allocato per gli oggetti ancora raggiungibili nella memoria, liberando i blocchi di spazi degli indirizzi allocati per oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="d4b56-132">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="d4b56-133">Una volta compattata la memoria per gli oggetti non raggiungibili, il Garbage Collector aggiorna i puntatori agli oggetti ai rispettivi nuovi indirizzi, in modo che le radici dell'applicazione puntino agli oggetti nelle rispettive nuove posizioni.</span><span class="sxs-lookup"><span data-stu-id="d4b56-133">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="d4b56-134">Il puntatore relativo all'heap gestito viene inoltre posizionato dopo l'ultimo oggetto non raggiungibile.</span><span class="sxs-lookup"><span data-stu-id="d4b56-134">It also positions the managed heap's pointer after the last reachable object.</span></span> <span data-ttu-id="d4b56-135">Si noti che la compressione della memoria viene effettuata solo se durante la raccolta viene rilevato un numero significativo di oggetti non raggiungibili.</span><span class="sxs-lookup"><span data-stu-id="d4b56-135">Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="d4b56-136">Se tutti gli oggetti dell'heap gestito superano la raccolta, non è necessaria alcuna compressione della memoria.</span><span class="sxs-lookup"><span data-stu-id="d4b56-136">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>  
  
 <span data-ttu-id="d4b56-137">Per migliorare le prestazioni, la memoria per oggetti di grandi dimensioni viene allocata da Common Language Runtime in un heap separato.</span><span class="sxs-lookup"><span data-stu-id="d4b56-137">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="d4b56-138">La memoria per oggetti di grandi dimensioni viene rilasciata automaticamente dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="d4b56-138">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="d4b56-139">Per evitare lo spostamento di oggetti di grandi dimensioni nella memoria, non viene effettuata la compattazione della memoria.</span><span class="sxs-lookup"><span data-stu-id="d4b56-139">However, to avoid moving large objects in memory, this memory is not compacted.</span></span>  
  
## <a name="generations-and-performance"></a><span data-ttu-id="d4b56-140">Generazioni e prestazioni</span><span class="sxs-lookup"><span data-stu-id="d4b56-140">Generations and Performance</span></span>  
 <span data-ttu-id="d4b56-141">Per ottimizzare le prestazioni del Garbage Collector, l'heap gestito è diviso in tre generazioni: 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="d4b56-141">To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</span></span> <span data-ttu-id="d4b56-142">L'algoritmo del Garbage Collection del runtime si basa su svariate generalizzazioni la cui validità è stata verificata dai produttori di software per computer tramite sperimentazioni con gli schemi di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="d4b56-142">The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</span></span> <span data-ttu-id="d4b56-143">Prima di tutto è stato rilevato che la compattazione per una parte dell'heap gestito risulta più rapida della compressione per l'intero heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-143">First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span> <span data-ttu-id="d4b56-144">In secondo luogo, la durata degli oggetti più recenti sarà inferiore alla durata degli oggetti meno recenti.</span><span class="sxs-lookup"><span data-stu-id="d4b56-144">Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</span></span> <span data-ttu-id="d4b56-145">Gli oggetti più recenti infine sono solitamente correlati e l'applicazione accede a tali oggetti quasi nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="d4b56-145">Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</span></span>  
  
 <span data-ttu-id="d4b56-146">Il Garbage Collector del runtime archivia i nuovi oggetti nella generazione 0.</span><span class="sxs-lookup"><span data-stu-id="d4b56-146">The runtime's garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="d4b56-147">Gli oggetti creati nelle prime fasi della durata dell'applicazione che non vengono raccolti vengono promossi e archiviati nelle generazioni 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="d4b56-147">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="d4b56-148">Il processo di promozione dell'oggetto viene descritto più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="d4b56-148">The process of object promotion is described later in this topic.</span></span> <span data-ttu-id="d4b56-149">Poiché la compressione di una porzione dell'heap gestito risulta più rapida della compressione dell'intero heap, questo schema consente al Garbage Collector di rilasciare la memoria in una specifica generazione, anziché rilasciare la memoria per l'intero heap gestito a ogni raccolta.</span><span class="sxs-lookup"><span data-stu-id="d4b56-149">Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>  
  
 <span data-ttu-id="d4b56-150">La raccolta viene in realtà effettuata dal Garbage Collector quando la generazione 0 è piena.</span><span class="sxs-lookup"><span data-stu-id="d4b56-150">In reality, the garbage collector performs a collection when generation 0 is full.</span></span> <span data-ttu-id="d4b56-151">Se un'applicazione tenta di creare un nuovo oggetto quando la generazione 0 è piena, il Garbage Collector rileva che nella generazione 0 non è più disponibile spazio degli indirizzi da allocare per l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="d4b56-151">If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</span></span> <span data-ttu-id="d4b56-152">Per tentare di liberare spazio degli indirizzi per l'oggetto nella generazione 0, viene effettuata una raccolta.</span><span class="sxs-lookup"><span data-stu-id="d4b56-152">The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</span></span> <span data-ttu-id="d4b56-153">Il Garbage Collector esamina prima di tutto gli oggetti presenti nella generazione 0, anziché tutti gli oggetti presenti nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-153">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="d4b56-154">Questo è infatti l'approccio più efficiente, poiché la durata degli oggetti recenti è solitamente ridotta e si presume che molti degli oggetti presenti nella generazione 0 non siano più utilizzati dall'applicazione quando si effettua una raccolta.</span><span class="sxs-lookup"><span data-stu-id="d4b56-154">This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</span></span> <span data-ttu-id="d4b56-155">L'effettuazione della raccolta sulla sola generazione 0 consente inoltre di recuperare spesso memoria sufficiente per consentire all'applicazione di continuare a creare nuovi oggetti.</span><span class="sxs-lookup"><span data-stu-id="d4b56-155">In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</span></span>  
  
 <span data-ttu-id="d4b56-156">Al termine della raccolta nella generazione 0 effettuata da Garbage Collector, la memoria per gli oggetti raggiungibili viene compressa come illustrato precedentemente in [Rilascio di memoria](#cpconautomaticmemorymanagementreleasingmemoryanchor1) in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="d4b56-156">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in [Releasing Memory](#cpconautomaticmemorymanagementreleasingmemoryanchor1) earlier in this topic.</span></span> <span data-ttu-id="d4b56-157">Il Garbage Collector promuove quindi questi oggetti e questa parte dell'heap gestito viene considerata come generazione 1.</span><span class="sxs-lookup"><span data-stu-id="d4b56-157">The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</span></span> <span data-ttu-id="d4b56-158">Poiché la durata degli oggetti non raccolti è solitamente più lunga, la promozione a una generazione superiore risulta opportuna.</span><span class="sxs-lookup"><span data-stu-id="d4b56-158">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="d4b56-159">Il riesame degli oggetti nelle generazioni 1 e 2 da parte del Garbage Collector non sarà quindi necessario a ogni raccolta della generazione 0.</span><span class="sxs-lookup"><span data-stu-id="d4b56-159">As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>  
  
 <span data-ttu-id="d4b56-160">Una volta completata la prima raccolta della generazione 0 e una volta promossi gli oggetti raggiungibili alla generazione 1, la parte restante dell'heap gestito verrà considerata dal Garbage Collector come generazione 0.</span><span class="sxs-lookup"><span data-stu-id="d4b56-160">After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</span></span> <span data-ttu-id="d4b56-161">Il Garbage Collector continuerà quindi ad allocare memoria per i nuovi oggetti nella generazione 0 fino a quando la generazione 0 non risulterà piena e non sarà necessario eseguire un'altra raccolta.</span><span class="sxs-lookup"><span data-stu-id="d4b56-161">It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</span></span> <span data-ttu-id="d4b56-162">A questo punto il modulo di ottimizzazione del Garbage Collector consentirà di determinare se sia necessario esaminare gli oggetti delle generazioni meno recenti.</span><span class="sxs-lookup"><span data-stu-id="d4b56-162">At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</span></span> <span data-ttu-id="d4b56-163">Se ad esempio una raccolta effettuata nella generazione 0 non consente di recuperare memoria sufficiente per il corretto completamento del tentativo di creazione di un nuovo oggetto da parte dell'applicazione, il Garbage Collector potrà eseguire una raccolta della generazione 1, quindi della generazione 2.</span><span class="sxs-lookup"><span data-stu-id="d4b56-163">For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="d4b56-164">Se la memoria recuperata non risulta sufficiente, il Garbage Collector potrà eseguire una raccolta nelle generazioni 2, 1 e 0.</span><span class="sxs-lookup"><span data-stu-id="d4b56-164">If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</span></span> <span data-ttu-id="d4b56-165">Al termine di ogni raccolta, gli oggetti raggiungibili nella generazione 0 vengono compressi dal Garbage Collector e promossi alla generazione 1.</span><span class="sxs-lookup"><span data-stu-id="d4b56-165">After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</span></span> <span data-ttu-id="d4b56-166">Gli oggetti presenti nella generazione 1 non raccolti vengono promossi alla generazione 2.</span><span class="sxs-lookup"><span data-stu-id="d4b56-166">Objects in generation 1 that survive collections are promoted to generation 2.</span></span> <span data-ttu-id="d4b56-167">Poiché il Garbage Collector supporta solo tre generazioni, gli oggetti presenti nella generazione 2 non raccolti rimangono nella generazione 2 fino a quando non vengono considerati non raggiungibili da raccolte successive.</span><span class="sxs-lookup"><span data-stu-id="d4b56-167">Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>  
  
## <a name="releasing-memory-for-unmanaged-resources"></a><span data-ttu-id="d4b56-168">Rilascio di memoria per le risorse non gestite</span><span class="sxs-lookup"><span data-stu-id="d4b56-168">Releasing Memory for Unmanaged Resources</span></span>  
 <span data-ttu-id="d4b56-169">Le attività di gestione della memoria necessarie vengono effettuate dal Garbage Collector per la maggior parte degli oggetti creati dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="d4b56-169">For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="d4b56-170">Per le risorse non gestite è tuttavia necessario il rilascio esplicito.</span><span class="sxs-lookup"><span data-stu-id="d4b56-170">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="d4b56-171">Il tipo più comune di risorsa non gestita è rappresentato da un oggetto che esegue il wrapping di una risorsa del sistema operativo, quale un handle di file, un handle di finestra o una connessione di rete.</span><span class="sxs-lookup"><span data-stu-id="d4b56-171">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="d4b56-172">Benché il Garbage Collector sia in grado di tenere traccia della durata di un oggetto gestito in cui è incapsulata una risorsa non gestita, non dispone di dati sufficienti per effettuare il rilascio della risorsa.</span><span class="sxs-lookup"><span data-stu-id="d4b56-172">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</span></span> <span data-ttu-id="d4b56-173">Quando si crea un oggetto che incapsula una risorsa non gestita, si consiglia di fornire il codice necessario per il rilascio della risorsa non gestita in un metodo **Dispose** pubblico.</span><span class="sxs-lookup"><span data-stu-id="d4b56-173">When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public **Dispose** method.</span></span> <span data-ttu-id="d4b56-174">Fornendo un metodo **Dispose** si consente agli utenti dell'oggetto di liberarne esplicitamente la memoria al termine delle operazioni che richiedono tale oggetto.</span><span class="sxs-lookup"><span data-stu-id="d4b56-174">By providing a **Dispose** method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="d4b56-175">Quando si usa un oggetto che incapsula una risorsa non gestita, si consiglia di tenere in considerazione il metodo **Dispose** e di chiamarlo in caso di necessità.</span><span class="sxs-lookup"><span data-stu-id="d4b56-175">When you use an object that encapsulates an unmanaged resource, you should be aware of **Dispose** and call it as necessary.</span></span> <span data-ttu-id="d4b56-176">Per altre informazioni su come pulire una risorsa non gestita e per un esempio di modello di progettazione per l'implementazione del metodo **Dispose**, vedere [Garbage Collection](../../docs/standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="d4b56-176">For more information about cleaning up unmanaged resources and an example of a design pattern for implementing **Dispose**, see [Garbage Collection](../../docs/standard/garbage-collection/index.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d4b56-177">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="d4b56-177">See also</span></span>

- <xref:System.GC>
- [<span data-ttu-id="d4b56-178">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="d4b56-178">Garbage Collection</span></span>](../../docs/standard/garbage-collection/index.md)
- [<span data-ttu-id="d4b56-179">Processo di esecuzione gestita</span><span class="sxs-lookup"><span data-stu-id="d4b56-179">Managed Execution Process</span></span>](../../docs/standard/managed-execution-process.md)
