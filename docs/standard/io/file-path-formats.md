---
title: Formati dei percorsi di file nei sistemi Windows
description: In questo articolo vengono fornite informazioni sui formati di percorso dei file nei sistemi Windows, ad esempio i percorsi DOS tradizionali, i percorsi dei dispositivi DOS e i percorsi UNC (Universal Naming Convention).
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 2d3ede97b372dd8922a10a377f69155a12f88bda
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447134"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="51fa6-103">Formati dei percorsi di file nei sistemi Windows</span><span class="sxs-lookup"><span data-stu-id="51fa6-103">File path formats on Windows systems</span></span>

<span data-ttu-id="51fa6-104">I membri di molti tipi nello spazio dei nomi <xref:System.IO> includono un parametro `path` che consente di specificare un percorso assoluto o relativo di una risorsa del file system.</span><span class="sxs-lookup"><span data-stu-id="51fa6-104">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="51fa6-105">Questo percorso viene quindi passato alle [API del file system Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="51fa6-105">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="51fa6-106">Questo argomento descrive i formati per i percorsi di file che è possibile usare nei sistemi Windows.</span><span class="sxs-lookup"><span data-stu-id="51fa6-106">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="51fa6-107">Percorsi DOS tradizionali</span><span class="sxs-lookup"><span data-stu-id="51fa6-107">Traditional DOS paths</span></span>

<span data-ttu-id="51fa6-108">Un percorso DOS standard può essere costituito da tre componenti:</span><span class="sxs-lookup"><span data-stu-id="51fa6-108">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="51fa6-109">Un volume o una lettera di unità seguita dal separatore di volume (`:`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-109">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="51fa6-110">Nome di directory.</span><span class="sxs-lookup"><span data-stu-id="51fa6-110">A directory name.</span></span> <span data-ttu-id="51fa6-111">Il [carattere separatore di directory](<xref:System.IO.Path.DirectorySeparatorChar>) separa le sottodirectory all'interno della gerarchia di directory annidata.</span><span class="sxs-lookup"><span data-stu-id="51fa6-111">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="51fa6-112">Un nome file facoltativo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-112">An optional filename.</span></span> <span data-ttu-id="51fa6-113">Il [carattere separatore di directory](<xref:System.IO.Path.DirectorySeparatorChar>) separa il percorso e il nome del file.</span><span class="sxs-lookup"><span data-stu-id="51fa6-113">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="51fa6-114">Se sono presenti tutti e tre i componenti, il percorso è assoluto.</span><span class="sxs-lookup"><span data-stu-id="51fa6-114">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="51fa6-115">Se non si specifica alcun volume o lettera di unità e il nome della directory inizia con il [carattere separatore di directory](<xref:System.IO.Path.DirectorySeparatorChar>), il percorso è relativo dalla radice dell'unità corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-115">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="51fa6-116">In caso contrario, il percorso è relativo alla directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-116">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="51fa6-117">La tabella seguente illustra alcuni percorsi possibili di directory e file.</span><span class="sxs-lookup"><span data-stu-id="51fa6-117">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="51fa6-118">Percorso</span><span class="sxs-lookup"><span data-stu-id="51fa6-118">Path</span></span>  |<span data-ttu-id="51fa6-119">Descrizione</span><span class="sxs-lookup"><span data-stu-id="51fa6-119">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="51fa6-120">Percorso file assoluto dalla radice dell'unità C:</span><span class="sxs-lookup"><span data-stu-id="51fa6-120">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="51fa6-121">Percorso assoluto dalla radice dell'unità corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-121">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="51fa6-122">Percorso relativo a un file in una sottodirectory della directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-122">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="51fa6-123">Percorso relativo a un file in una directory che è un peer della directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-123">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="51fa6-124">Percorso assoluto a un file dalla radice dell'unità C:</span><span class="sxs-lookup"><span data-stu-id="51fa6-124">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="51fa6-125">Percorso relativo dalla directory corrente dell'unità C:</span><span class="sxs-lookup"><span data-stu-id="51fa6-125">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="51fa6-126">Si noti la differenza tra gli ultimi due percorsi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-126">Note the difference between the last two paths.</span></span> <span data-ttu-id="51fa6-127">Entrambi specificano l'identificatore di volume facoltativo (C: in entrambi i casi), ma il primo inizia con la radice del volume specificato, mentre il secondo no.</span><span class="sxs-lookup"><span data-stu-id="51fa6-127">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="51fa6-128">Di conseguenza, il primo è un percorso assoluto dalla directory radice dell'unità C:, mentre il secondo è un percorso relativo dalla directory corrente dell'unità C:.</span><span class="sxs-lookup"><span data-stu-id="51fa6-128">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="51fa6-129">L'uso del secondo formato quando si intende usare il primo è una fonte comune di bug per i percorsi di file Windows.</span><span class="sxs-lookup"><span data-stu-id="51fa6-129">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="51fa6-130">È possibile determinare se un percorso di file è completo (ovvero se il percorso è indipendente dalla directory corrente e non cambia quando la directory corrente viene modificata) chiamando il metodo <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType>.</span><span class="sxs-lookup"><span data-stu-id="51fa6-130">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="51fa6-131">Si noti che tale percorso può includere segmenti di directory relativi (`.` e `..`) ed essere comunque completo se il percorso risolto punta sempre alla stessa posizione.</span><span class="sxs-lookup"><span data-stu-id="51fa6-131">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="51fa6-132">L'esempio seguente illustra la differenza fra percorsi assoluti e relativi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-132">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="51fa6-133">Si presuppone che la directory D:\FY2018\ esista e che non sia stata impostata alcuna directory corrente per D:\ dal prompt dei comandi prima di eseguire l'esempio.</span><span class="sxs-lookup"><span data-stu-id="51fa6-133">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="51fa6-134">Percorsi UNC</span><span class="sxs-lookup"><span data-stu-id="51fa6-134">UNC paths</span></span>

<span data-ttu-id="51fa6-135">I percorsi UNC (Universal Naming Convention), che vengono usati per accedere alle risorse di rete, hanno il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="51fa6-135">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="51fa6-136">Un nome host o server, preceduto da \\\\.</span><span class="sxs-lookup"><span data-stu-id="51fa6-136">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="51fa6-137">Il nome del server può essere un nome computer NetBIOS o un indirizzo IP/FQDN (sono supportati IPv4 e v6).</span><span class="sxs-lookup"><span data-stu-id="51fa6-137">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="51fa6-138">Un nome condivisione, separato dal nome host da \\.</span><span class="sxs-lookup"><span data-stu-id="51fa6-138">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="51fa6-139">Insieme, il server e il nome condivisione costituiscono il volume.</span><span class="sxs-lookup"><span data-stu-id="51fa6-139">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="51fa6-140">Nome di directory.</span><span class="sxs-lookup"><span data-stu-id="51fa6-140">A directory name.</span></span> <span data-ttu-id="51fa6-141">Il [carattere separatore di directory](<xref:System.IO.Path.DirectorySeparatorChar>) separa le sottodirectory all'interno della gerarchia di directory annidata.</span><span class="sxs-lookup"><span data-stu-id="51fa6-141">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="51fa6-142">Un nome file facoltativo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-142">An optional filename.</span></span> <span data-ttu-id="51fa6-143">Il [carattere separatore di directory](<xref:System.IO.Path.DirectorySeparatorChar>) separa il percorso e il nome del file.</span><span class="sxs-lookup"><span data-stu-id="51fa6-143">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="51fa6-144">Di seguito sono riportati alcuni esempi di percorsi UNC:</span><span class="sxs-lookup"><span data-stu-id="51fa6-144">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="51fa6-145">Percorso</span><span class="sxs-lookup"><span data-stu-id="51fa6-145">Path</span></span>  |<span data-ttu-id="51fa6-146">Descrizione</span><span class="sxs-lookup"><span data-stu-id="51fa6-146">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="51fa6-147">Directory radice dell'unità C: in `system07`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-147">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="51fa6-148">File Foo.txt nella directory Test del volume \\\\Server2\\Share.</span><span class="sxs-lookup"><span data-stu-id="51fa6-148">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="51fa6-149">I percorsi UNC devono essere sempre completi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-149">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="51fa6-150">Possono includere segmenti di directory relativi (`.` e `..`), ma devono far parte di un percorso completo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-150">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="51fa6-151">È possibile usare i percorsi relativi solo eseguendo il mapping di un percorso UNC a una lettera di unità.</span><span class="sxs-lookup"><span data-stu-id="51fa6-151">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="51fa6-152">Percorsi del dispositivo DOS</span><span class="sxs-lookup"><span data-stu-id="51fa6-152">DOS device paths</span></span>

<span data-ttu-id="51fa6-153">Il sistema operativo Windows ha un modello a oggetti unificato che punta a tutte le risorse, inclusi i file.</span><span class="sxs-lookup"><span data-stu-id="51fa6-153">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="51fa6-154">Questi percorsi degli oggetti sono accessibili dalla finestra della console e vengono esposti al livello Win32 tramite una cartella speciale di collegamenti simbolici a cui sono mappati i percorsi UNC e DOS legacy.</span><span class="sxs-lookup"><span data-stu-id="51fa6-154">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="51fa6-155">Questa cartella speciale è accessibile tramite la sintassi del percorso del dispositivo DOS, ovvero uno dei due riportati di seguito:</span><span class="sxs-lookup"><span data-stu-id="51fa6-155">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="51fa6-156">Oltre a identificare un'unità con la relativa lettera di unità, è possibile identificare un volume usando l'identificatore univoco globale (GUID) del volume.</span><span class="sxs-lookup"><span data-stu-id="51fa6-156">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="51fa6-157">Assume il formato:</span><span class="sxs-lookup"><span data-stu-id="51fa6-157">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="51fa6-158">La sintassi del percorso del dispositivo DOS è supportata nelle implementazioni .NET in esecuzione in Windows a partire da .NET Core 1.1 e .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="51fa6-158">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="51fa6-159">Il percorso del dispositivo DOS è costituito dai componenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="51fa6-159">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="51fa6-160">L'identificatore del percorso del dispositivo (`\\.\` o `\\?\`), che identifica il percorso come percorso di un dispositivo DOS.</span><span class="sxs-lookup"><span data-stu-id="51fa6-160">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="51fa6-161">`\\?\` è supportato in tutte le versioni di .NET Core e in .NET Framework a partire dalla versione 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="51fa6-161">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="51fa6-162">Un collegamento simbolico all'oggetto dispositivo "reale" (C: nel caso di un nome di unità o Volume{b75e2c83-0000-0000-0000-602f00000000} nel caso di un GUID del volume).</span><span class="sxs-lookup"><span data-stu-id="51fa6-162">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="51fa6-163">Il primo segmento del percorso del dispositivo DOS dopo l'identificatore del percorso del dispositivo identifica il volume o l'unità</span><span class="sxs-lookup"><span data-stu-id="51fa6-163">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="51fa6-164">(ad esempio, `\\?\C:\` e `\\.\BootPartition\`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-164">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="51fa6-165">È disponibile un collegamento specifico per i percorsi UNC, chiamato `UNC`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-165">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="51fa6-166">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="51fa6-166">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="51fa6-167">Per i percorsi UNC del dispositivo, la parte server/condivisione costituisce il volume.</span><span class="sxs-lookup"><span data-stu-id="51fa6-167">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="51fa6-168">Ad esempio, in `\\?\server1\e:\utilities\\filecomparer\` la parte server/condivisione è server1\utilities.</span><span class="sxs-lookup"><span data-stu-id="51fa6-168">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="51fa6-169">Ciò risulta particolarmente importante quando si chiama un metodo come <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> con segmenti di directory relativi; non è mai possibile andare oltre il volume.</span><span class="sxs-lookup"><span data-stu-id="51fa6-169">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="51fa6-170">I percorsi del dispositivo DOS sono completi per definizione.</span><span class="sxs-lookup"><span data-stu-id="51fa6-170">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="51fa6-171">I segmenti di directory relativi (`.` e `..`) non sono consentiti.</span><span class="sxs-lookup"><span data-stu-id="51fa6-171">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="51fa6-172">Le directory correnti non entrano mai in uso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-172">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="51fa6-173">Esempio: modi per fare riferimento allo stesso file</span><span class="sxs-lookup"><span data-stu-id="51fa6-173">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="51fa6-174">L'esempio seguente illustra alcuni dei modi in cui è possibile fare riferimento a un file quando si usano le API nello spazio dei nomi <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="51fa6-174">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="51fa6-175">L'esempio crea un'istanza di un oggetto <xref:System.IO.FileInfo> e usa le rispettive proprietà <xref:System.IO.FileInfo.Name> e <xref:System.IO.FileInfo.Length> per visualizzare il nome e la lunghezza del file.</span><span class="sxs-lookup"><span data-stu-id="51fa6-175">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="51fa6-176">Normalizzazione del percorso</span><span class="sxs-lookup"><span data-stu-id="51fa6-176">Path normalization</span></span>

<span data-ttu-id="51fa6-177">Quasi tutti i percorsi passati alle API di Windows sono normalizzati.</span><span class="sxs-lookup"><span data-stu-id="51fa6-177">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="51fa6-178">Durante la normalizzazione, Windows esegue la procedura seguente:</span><span class="sxs-lookup"><span data-stu-id="51fa6-178">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="51fa6-179">Identifica il percorso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-179">Identifies the path.</span></span>
- <span data-ttu-id="51fa6-180">Applica la directory corrente ai percorsi parzialmente completi (relativi).</span><span class="sxs-lookup"><span data-stu-id="51fa6-180">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="51fa6-181">Converte in forma canonica i separatori di directory e componenti.</span><span class="sxs-lookup"><span data-stu-id="51fa6-181">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="51fa6-182">Valuta i componenti di directory relativi (`.` per la directory corrente e `..` per la directory padre).</span><span class="sxs-lookup"><span data-stu-id="51fa6-182">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="51fa6-183">Elimina determinati caratteri.</span><span class="sxs-lookup"><span data-stu-id="51fa6-183">Trims certain characters.</span></span>

<span data-ttu-id="51fa6-184">Questa normalizzazione avviene in modo implicito, ma è possibile eseguirla in modo esplicito chiamando il metodo <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>, che esegue il wrapping di una chiamata alla [funzione GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="51fa6-184">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="51fa6-185">È anche possibile chiamare la [funzione GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) di Windows direttamente tramite P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="51fa6-185">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="51fa6-186">Identificazione del percorso</span><span class="sxs-lookup"><span data-stu-id="51fa6-186">Identifying the path</span></span>

<span data-ttu-id="51fa6-187">Il primo passaggio nella normalizzazione del percorso consiste nell'identificare il tipo di percorso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-187">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="51fa6-188">I percorsi rientrano in una delle categorie seguenti:</span><span class="sxs-lookup"><span data-stu-id="51fa6-188">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="51fa6-189">Sono percorsi del dispositivo, vale a dire iniziano con due separatori e un punto interrogativo o un punto (`\\?` o `\\.`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-189">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="51fa6-190">Sono percorsi UNC, vale a dire iniziano con due separatori senza un punto interrogativo o un punto.</span><span class="sxs-lookup"><span data-stu-id="51fa6-190">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="51fa6-191">Sono percorsi DOS completi, vale a dire iniziano con una lettera di unità, un separatore di volume e un separatore di componenti (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-191">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="51fa6-192">Definiscono un dispositivo legacy (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-192">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="51fa6-193">Sono relativi alla radice dell'unità corrente, vale a dire iniziano con un separatore di componenti singolo (`\`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-193">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="51fa6-194">Sono relativi alla directory corrente di un'unità specificata, vale a dire iniziano con una lettera di unità, un separatore di volume e nessun separatore di componenti (`C:`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-194">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="51fa6-195">Sono relativi alla directory corrente, vale a dire iniziano con qualsiasi altro elemento (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-195">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="51fa6-196">Il tipo di percorso determina se una directory corrente viene applicata o meno in qualche modo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-196">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="51fa6-197">Definisce inoltre qual è la "radice" del percorso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-197">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="51fa6-198">Gestione dei dispositivi legacy</span><span class="sxs-lookup"><span data-stu-id="51fa6-198">Handling legacy devices</span></span>

<span data-ttu-id="51fa6-199">Se il percorso è un dispositivo DOS legacy come `CON`, `COM1` o `LPT1`, viene convertito in un percorso del dispositivo anteponendo `\\.\` e viene restituito.</span><span class="sxs-lookup"><span data-stu-id="51fa6-199">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="51fa6-200">Un percorso che inizia con il nome di un dispositivo legacy viene sempre interpretato come dispositivo legacy dal metodo <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="51fa6-200">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="51fa6-201">Ad esempio, il percorso del dispositivo DOS per `CON.TXT` è `\\.\CON` e il percorso del dispositivo DOS per `COM1.TXT\file1.txt` è `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-201">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="51fa6-202">Applicazione della directory corrente</span><span class="sxs-lookup"><span data-stu-id="51fa6-202">Applying the current directory</span></span>

<span data-ttu-id="51fa6-203">Se un percorso non è completo, Windows applica la directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-203">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="51fa6-204">I percorsi UNC e dei dispositivi non hanno la directory corrente applicata</span><span class="sxs-lookup"><span data-stu-id="51fa6-204">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="51fa6-205">e neanche un'unità completa con il separatore C:\\.</span><span class="sxs-lookup"><span data-stu-id="51fa6-205">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="51fa6-206">Se il percorso inizia con un separatore di componenti singolo, viene applicata l'unità della directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-206">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="51fa6-207">Ad esempio, se il percorso del file è `\utilities` e la directory corrente è `C:\temp\`, la normalizzazione produce `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-207">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="51fa6-208">Se il percorso inizia con una lettera di unità, un separatore di volume e nessun separatore di componenti, viene applicata l'ultima directory corrente impostata dalla shell dei comandi per l'unità specificata.</span><span class="sxs-lookup"><span data-stu-id="51fa6-208">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="51fa6-209">Se l'ultima directory corrente non è stata impostata, viene applicata solo l'unità.</span><span class="sxs-lookup"><span data-stu-id="51fa6-209">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="51fa6-210">Ad esempio, se il percorso del file è `D:sources`, la directory corrente è `C:\Documents\` e l'ultima directory corrente nell'unità D: è stata `D:\sources\`, il risultato è `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-210">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="51fa6-211">Questi percorsi "relativi di unità" sono una fonte comune di errori logici per script e programmi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-211">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="51fa6-212">Presupporre che un percorso che inizia con una lettera e i due punti non sia relativo ovviamente non è corretto.</span><span class="sxs-lookup"><span data-stu-id="51fa6-212">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="51fa6-213">Se il percorso inizia con un elemento diverso da un separatore, vengono applicate l'unità e la directory correnti.</span><span class="sxs-lookup"><span data-stu-id="51fa6-213">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="51fa6-214">Ad esempio, se il percorso è `filecompare` e la directory corrente è `C:\utilities\`, il risultato è `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-214">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="51fa6-215">I percorsi relativi sono pericolosi nelle applicazioni multithreading (vale a dire, la maggior parte delle applicazioni) perché la directory corrente è un'impostazione specifica per il processo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-215">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="51fa6-216">Qualsiasi thread può modificare la directory corrente in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="51fa6-216">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="51fa6-217">A partire da .NET Core 2.1, è possibile chiamare il metodo <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> per ottenere un percorso assoluto da un percorso relativo e il percorso base (directory corrente) in base a cui si procede alla risoluzione.</span><span class="sxs-lookup"><span data-stu-id="51fa6-217">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="51fa6-218">Conversione in forma canonica dei separatori</span><span class="sxs-lookup"><span data-stu-id="51fa6-218">Canonicalizing separators</span></span>

<span data-ttu-id="51fa6-219">Tutte le barre (`/`) sono convertite nel separatore di Windows standard, la barra rovesciata (`\`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-219">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="51fa6-220">Se sono presenti, una serie di barre che seguono le prime due vengono compresse in una singola barra.</span><span class="sxs-lookup"><span data-stu-id="51fa6-220">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="51fa6-221">Valutazione dei componenti relativi</span><span class="sxs-lookup"><span data-stu-id="51fa6-221">Evaluating relative components</span></span>

<span data-ttu-id="51fa6-222">Mentre il percorso viene elaborato, vengono valutati tutti i componenti o i segmenti costituiti da un punto singolo o doppio (`.` o `..`):</span><span class="sxs-lookup"><span data-stu-id="51fa6-222">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="51fa6-223">Nel caso di un punto singolo, il segmento corrente viene rimosso, perché fa riferimento alla directory corrente.</span><span class="sxs-lookup"><span data-stu-id="51fa6-223">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="51fa6-224">Nel caso di un punto doppio, il segmento corrente e quello padre vengono rimossi, perché il punto doppio fa riferimento alla directory padre.</span><span class="sxs-lookup"><span data-stu-id="51fa6-224">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="51fa6-225">Le directory padre vengono rimosse solo se non sono oltre la radice del percorso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-225">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="51fa6-226">La radice del percorso dipende dal tipo di percorso.</span><span class="sxs-lookup"><span data-stu-id="51fa6-226">The root of the path depends on the type of path.</span></span> <span data-ttu-id="51fa6-227">Si tratta dell'unità (`C:\`) per i percorsi DOS, del server/condivisione per i percorsi UNC (`\\Server\Share`) e del prefisso del percorso del dispositivo per i percorsi del dispositivo (`\\?\` o `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="51fa6-227">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="51fa6-228">Eliminazione di caratteri</span><span class="sxs-lookup"><span data-stu-id="51fa6-228">Trimming characters</span></span>

<span data-ttu-id="51fa6-229">Insieme ai separatori e ai segmenti relativi rimossi in precedenza, durante la normalizzazione vengono rimossi alcuni caratteri aggiuntivi:</span><span class="sxs-lookup"><span data-stu-id="51fa6-229">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="51fa6-230">Se un segmento termina con un punto singolo, il punto viene rimosso</span><span class="sxs-lookup"><span data-stu-id="51fa6-230">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="51fa6-231">(un segmento di un punto singolo o doppio è normalizzato nel passaggio precedente;</span><span class="sxs-lookup"><span data-stu-id="51fa6-231">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="51fa6-232">un segmento di tre o più punti non è normalizzato ed è in realtà un nome di file/directory valido).</span><span class="sxs-lookup"><span data-stu-id="51fa6-232">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="51fa6-233">Se il percorso non termina con un separatore, tutti gli spazi e i punti finali (U+0020) vengono rimossi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-233">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="51fa6-234">Se l'ultimo segmento è semplicemente un punto singolo o doppio, rientra nella regola dei componenti relativi esposta in precedenza.</span><span class="sxs-lookup"><span data-stu-id="51fa6-234">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="51fa6-235">Questa regola indica che è possibile creare un nome di directory con uno spazio finale mediante l'aggiunta di un separatore finale dopo lo spazio.</span><span class="sxs-lookup"><span data-stu-id="51fa6-235">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="51fa6-236">Non creare **mai** una directory o un nome file con uno spazio finale.</span><span class="sxs-lookup"><span data-stu-id="51fa6-236">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="51fa6-237">Gli spazi finali possono rendere difficile o impossibile l'accesso a una directory e le applicazioni riscontrano in genere un errore quando si tenta di gestire directory o file i cui nomi includono spazi finali.</span><span class="sxs-lookup"><span data-stu-id="51fa6-237">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="51fa6-238">Esclusione della normalizzazione</span><span class="sxs-lookup"><span data-stu-id="51fa6-238">Skipping normalization</span></span>

<span data-ttu-id="51fa6-239">Normalmente, qualsiasi percorso passato a un'API di Windows viene effettivamente passato alla [funzione GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) e normalizzato.</span><span class="sxs-lookup"><span data-stu-id="51fa6-239">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="51fa6-240">Un'eccezione degna di nota è quando il percorso di un dispositivo inizia con un punto interrogativo anziché con un punto.</span><span class="sxs-lookup"><span data-stu-id="51fa6-240">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="51fa6-241">A meno che il percorso non inizi esattamente con `\\?\` (si noti l'uso della barra rovesciata canonica), viene normalizzato.</span><span class="sxs-lookup"><span data-stu-id="51fa6-241">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="51fa6-242">Perché escludere la normalizzazione?</span><span class="sxs-lookup"><span data-stu-id="51fa6-242">Why would you want to skip normalization?</span></span> <span data-ttu-id="51fa6-243">Per tre motivi principali:</span><span class="sxs-lookup"><span data-stu-id="51fa6-243">There are three major reasons:</span></span>

1. <span data-ttu-id="51fa6-244">Per ottenere l'accesso a percorsi che non sono in genere disponibili ma sono validi.</span><span class="sxs-lookup"><span data-stu-id="51fa6-244">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="51fa6-245">A un file o una directory denominata `hidden.`, ad esempio, è impossibile accedere in qualsiasi altro modo.</span><span class="sxs-lookup"><span data-stu-id="51fa6-245">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="51fa6-246">Per migliorare le prestazioni escludendo la normalizzazione se è già stata eseguita.</span><span class="sxs-lookup"><span data-stu-id="51fa6-246">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="51fa6-247">Solo in .NET Framework, per ignorare il controllo `MAX_PATH` per la lunghezza del percorso in modo da consentire percorsi contenenti più di 259 caratteri.</span><span class="sxs-lookup"><span data-stu-id="51fa6-247">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="51fa6-248">La maggior parte delle API consente questa operazione, con alcune eccezioni.</span><span class="sxs-lookup"><span data-stu-id="51fa6-248">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="51fa6-249">.NET Core gestisce i percorsi lunghi in modo implicito e non esegue un controllo `MAX_PATH`.</span><span class="sxs-lookup"><span data-stu-id="51fa6-249">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="51fa6-250">Il controllo `MAX_PATH` si applica solo a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="51fa6-250">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="51fa6-251">L'esclusione della normalizzazione e dei controlli MAX_PATH è l'unica differenza tra le sintassi dei due percorsi di dispositivo; altrimenti sono identici.</span><span class="sxs-lookup"><span data-stu-id="51fa6-251">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="51fa6-252">Prestare attenzione quando si esclude la normalizzazione, perché si rischia di creare percorsi difficili da gestire con le "normali" applicazioni.</span><span class="sxs-lookup"><span data-stu-id="51fa6-252">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="51fa6-253">I percorsi che iniziano con `\\?\` vengono comunque normalizzati se si passano in modo esplicito alla [funzione GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="51fa6-253">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="51fa6-254">È possibile passare i percorsi di più di `MAX_PATH` caratteri a [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) senza `\\?\` .</span><span class="sxs-lookup"><span data-stu-id="51fa6-254">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="51fa6-255">Supporta percorsi di lunghezza arbitraria fino alla dimensione massima delle stringhe che Windows è in grado di gestire.</span><span class="sxs-lookup"><span data-stu-id="51fa6-255">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="51fa6-256">Maiuscole/minuscole e file system di Windows</span><span class="sxs-lookup"><span data-stu-id="51fa6-256">Case and the Windows file system</span></span>

<span data-ttu-id="51fa6-257">Una peculiarità del file system di Windows che può confondere gli utenti e gli sviluppatori non Windows è che i nomi di percorsi e directory non fanno distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="51fa6-257">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="51fa6-258">In altre parole, i nomi di file e directory riflettono l'uso di maiuscole/minuscole delle stringhe usate quando sono stati creati.</span><span class="sxs-lookup"><span data-stu-id="51fa6-258">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="51fa6-259">Ad esempio, la chiamata al metodo</span><span class="sxs-lookup"><span data-stu-id="51fa6-259">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="51fa6-260">crea una directory denominata TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="51fa6-260">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="51fa6-261">Se si rinomina una directory o un file per modificare l'uso di maiuscole/minuscole, il nome del file o della directory riflette le maiuscole/minuscole usate quando è stato rinominato.</span><span class="sxs-lookup"><span data-stu-id="51fa6-261">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="51fa6-262">Ad esempio, il codice seguente rinomina un file denominato test.txt in Test.txt:</span><span class="sxs-lookup"><span data-stu-id="51fa6-262">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="51fa6-263">Tuttavia, nei confronti tra i nomi di file e directory non viene fatta distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="51fa6-263">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="51fa6-264">Se si cerca un file denominato "test.txt", le API del file system .NET non fanno distinzione tra maiuscole e minuscole nel confronto.</span><span class="sxs-lookup"><span data-stu-id="51fa6-264">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="51fa6-265">Test.txt, TEST.TXT, test.TXT e qualsiasi altra combinazione di lettere maiuscole e minuscole corrisponderanno a "test.txt".</span><span class="sxs-lookup"><span data-stu-id="51fa6-265">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
