---
title: Assembly di riferimento
description: Informazioni sugli assembly di riferimento, un tipo speciale di assembly in .NET che contengono solo la superficie dell'API pubblica della libreria
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 43a9dab037f4d0f1926ff67f8f38eaa6734a6d67
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/24/2020
ms.locfileid: "87164520"
---
# <a name="reference-assemblies"></a><span data-ttu-id="a29c4-103">Assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="a29c4-103">Reference assemblies</span></span>

<span data-ttu-id="a29c4-104">Gli *assembly di riferimento* sono un tipo speciale di assembly che contiene solo la quantità minima di metadati necessaria per rappresentare la superficie dell'API pubblica della libreria.</span><span class="sxs-lookup"><span data-stu-id="a29c4-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="a29c4-105">Sono incluse le dichiarazioni per tutti i membri significativi quando si fa riferimento a un assembly negli strumenti di compilazione, ma si escludono tutte le implementazioni e le dichiarazioni dei membri privati che non hanno alcun impatto osservabile sul contratto API.</span><span class="sxs-lookup"><span data-stu-id="a29c4-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="a29c4-106">Al contrario, gli assembly regolari vengono chiamati *assembly di implementazione*.</span><span class="sxs-lookup"><span data-stu-id="a29c4-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="a29c4-107">Gli assembly di riferimento non possono essere caricati per l'esecuzione, ma possono essere passati come input del compilatore nello stesso modo degli assembly di implementazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="a29c4-108">Gli assembly di riferimento vengono in genere distribuiti con il Software Development Kit (SDK) di una particolare piattaforma o libreria.</span><span class="sxs-lookup"><span data-stu-id="a29c4-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="a29c4-109">L'uso di un assembly di riferimento consente agli sviluppatori di compilare programmi destinati a una versione specifica della libreria senza avere l'assembly di implementazione completo per tale versione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="a29c4-110">Si supponga di avere solo la versione più recente di una raccolta nel computer, ma si vuole compilare un programma destinato a una versione precedente di tale libreria.</span><span class="sxs-lookup"><span data-stu-id="a29c4-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="a29c4-111">Se si esegue la compilazione direttamente nell'assembly di implementazione, si potrebbero usare inavvertitamente i membri dell'API che non sono disponibili nella versione precedente.</span><span class="sxs-lookup"><span data-stu-id="a29c4-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="a29c4-112">Questo errore si verifica solo quando si esegue il test del programma nel computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="a29c4-113">Se si esegue la compilazione in base all'assembly di riferimento per la versione precedente, si otterrà immediatamente un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="a29c4-114">Un assembly di riferimento può anche rappresentare un contratto, ovvero un set di API che non corrispondono all'assembly di implementazione concreto.</span><span class="sxs-lookup"><span data-stu-id="a29c4-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="a29c4-115">Gli assembly di riferimento, detti *assembly del contratto*, possono essere usati per più piattaforme che supportano lo stesso set di API.</span><span class="sxs-lookup"><span data-stu-id="a29c4-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="a29c4-116">Ad esempio, .NET Standard fornisce l'assembly del contratto, *netstandard.dll*, che rappresenta il set di API comuni condivise tra diverse piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="a29c4-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="a29c4-117">Le implementazioni di queste API sono contenute in assembly diversi su piattaforme diverse, ad esempio *mscorlib.dll* in .NET Framework o *System.Private.CoreLib.dll* in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a29c4-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="a29c4-118">Una libreria destinata a .NET Standard può essere eseguita in tutte le piattaforme che supportano .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="a29c4-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="a29c4-119">Uso di assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="a29c4-119">Using reference assemblies</span></span>

<span data-ttu-id="a29c4-120">Per usare determinate API dal progetto, è necessario aggiungere riferimenti ai relativi assembly.</span><span class="sxs-lookup"><span data-stu-id="a29c4-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="a29c4-121">È possibile aggiungere riferimenti a assembly di implementazione o a assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="a29c4-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="a29c4-122">È consigliabile usare gli assembly di riferimento ogni volta che sono disponibili.</span><span class="sxs-lookup"><span data-stu-id="a29c4-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="a29c4-123">In questo modo si garantisce che vengano usati solo i membri dell'API supportati nella versione di destinazione, destinati a essere usati dagli strumenti di progettazione dell'API.</span><span class="sxs-lookup"><span data-stu-id="a29c4-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="a29c4-124">L'uso dell'assembly di riferimento assicura che non si stiano prendendo una dipendenza dai dettagli di implementazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="a29c4-125">Gli assembly di riferimento per le librerie di .NET Framework vengono distribuiti con i targeting pack.</span><span class="sxs-lookup"><span data-stu-id="a29c4-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="a29c4-126">È possibile ottenerli scaricando un programma di installazione autonomo o selezionando un componente nel programma di installazione di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="a29c4-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="a29c4-127">Per ulteriori informazioni, vedere [Install the .NET Framework for Developers](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="a29c4-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="a29c4-128">Per .NET Core e .NET Standard, gli assembly di riferimento vengono scaricati automaticamente in base alle necessità (tramite NuGet) e a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="a29c4-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="a29c4-129">Per .NET Core 3,0 e versioni successive, gli assembly di riferimento per il Framework di base sono inclusi nel pacchetto [Microsoft. NETCore. app. Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (il pacchetto [Microsoft. NETCore. app](https://www.nuget.org/packages/Microsoft.NETCore.App) viene usato in alternativa per le versioni precedenti a 3,0).</span><span class="sxs-lookup"><span data-stu-id="a29c4-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="a29c4-130">Quando si aggiungono riferimenti a assembly .NET Framework in Visual Studio usando la finestra di dialogo **Aggiungi riferimento** , si seleziona un assembly dall'elenco e Visual Studio rileva automaticamente gli assembly di riferimento che corrispondono alla versione del Framework di destinazione selezionata nel progetto.</span><span class="sxs-lookup"><span data-stu-id="a29c4-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="a29c4-131">Lo stesso vale per l'aggiunta di riferimenti direttamente al progetto MSBuild utilizzando l'elemento di progetto di [riferimento](/visualstudio/msbuild/common-msbuild-project-items#reference) : è sufficiente specificare il nome dell'assembly, non il percorso completo del file.</span><span class="sxs-lookup"><span data-stu-id="a29c4-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="a29c4-132">Quando si aggiungono riferimenti a questi assembly nella riga di comando usando l' `-reference` opzione del compilatore ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) e in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) o usando il <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> metodo nell'API Roslyn, è necessario specificare manualmente i file di assembly di riferimento per la versione corretta della piattaforma di destinazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="a29c4-133">.NET Framework file di assembly di riferimento si trovano negli *assembly di riferimento% ProgramFiles (x86)% \\ \\ Microsoft \\ Framework \\ . Directory NETFramework* .</span><span class="sxs-lookup"><span data-stu-id="a29c4-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="a29c4-134">Per .NET Core, è possibile forzare l'operazione di pubblicazione per copiare gli assembly di riferimento per la piattaforma di destinazione nella sottodirectory *Publish/refs* della directory di output impostando la `PreserveCompilationContext` Proprietà Project su `true` .</span><span class="sxs-lookup"><span data-stu-id="a29c4-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="a29c4-135">Quindi, è possibile passare questi file di assembly di riferimento al compilatore.</span><span class="sxs-lookup"><span data-stu-id="a29c4-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="a29c4-136">`DependencyContext`L'uso di dal pacchetto [Microsoft. Extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) consente di individuare i percorsi.</span><span class="sxs-lookup"><span data-stu-id="a29c4-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="a29c4-137">Poiché non contengono alcuna implementazione, non è possibile caricare gli assembly di riferimento per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="a29c4-138">Il tentativo di eseguire questa operazione comporta un <xref:System.BadImageFormatException?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="a29c4-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a29c4-139">Se si vuole esaminare il contenuto di un assembly di riferimento, è possibile caricarlo nel contesto di sola reflection in .NET Framework (usando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> metodo) o in <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a29c4-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="a29c4-140">Generazione di assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="a29c4-140">Generating reference assemblies</span></span>

<span data-ttu-id="a29c4-141">La generazione di assembly di riferimento per le librerie può essere utile quando gli utenti della libreria devono compilare i programmi rispetto a diverse versioni della libreria.</span><span class="sxs-lookup"><span data-stu-id="a29c4-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="a29c4-142">La distribuzione degli assembly di implementazione per tutte queste versioni potrebbe risultare poco pratica a causa delle dimensioni elevate.</span><span class="sxs-lookup"><span data-stu-id="a29c4-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="a29c4-143">Gli assembly di riferimento hanno dimensioni minori e la loro distribuzione come parte dell'SDK della libreria riduce le dimensioni del download e consente di risparmiare spazio su disco.</span><span class="sxs-lookup"><span data-stu-id="a29c4-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="a29c4-144">Gli IDE e gli strumenti di compilazione possono inoltre sfruttare gli assembly di riferimento per ridurre i tempi di compilazione in caso di soluzioni di grandi dimensioni costituite da più librerie di classi.</span><span class="sxs-lookup"><span data-stu-id="a29c4-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="a29c4-145">In genere, negli scenari di compilazione incrementale un progetto viene ricompilato quando uno dei relativi file di input viene modificato, inclusi gli assembly da cui dipende.</span><span class="sxs-lookup"><span data-stu-id="a29c4-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="a29c4-146">L'assembly di implementazione cambia ogni volta che il programmatore modifica l'implementazione di un membro.</span><span class="sxs-lookup"><span data-stu-id="a29c4-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="a29c4-147">L'assembly di riferimento cambia solo quando è interessata l'API pubblica.</span><span class="sxs-lookup"><span data-stu-id="a29c4-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="a29c4-148">Pertanto, l'utilizzo dell'assembly di riferimento come file di input anziché dell'assembly di implementazione consente di ignorare la compilazione del progetto dipendente in alcuni casi.</span><span class="sxs-lookup"><span data-stu-id="a29c4-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="a29c4-149">È possibile generare gli assembly di riferimento:</span><span class="sxs-lookup"><span data-stu-id="a29c4-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="a29c4-150">In un progetto MSBuild, usando la [ `ProduceReferenceAssembly` Proprietà Project](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="a29c4-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="a29c4-151">Quando si compila il programma dalla riga di comando, dalle `-refonly` Opzioni del compilatore specifica ([c#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) o `-refout` ([c#](../../csharp/language-reference/compiler-options/refout-compiler-option.md)  /  [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)).</span><span class="sxs-lookup"><span data-stu-id="a29c4-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="a29c4-152">Quando si usa l'API Roslyn, impostando <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> su `true` e <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> su `false` in un oggetto passato al <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="a29c4-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="a29c4-153">Se si desidera distribuire gli assembly di riferimento con i pacchetti NuGet, è necessario includerli nella sottodirectory \*ref \\ \* nella directory del pacchetto anziché nella sottodirectory \*lib \\ \* utilizzata per gli assembly di implementazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="a29c4-154">Struttura degli assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="a29c4-154">Reference assemblies structure</span></span>

<span data-ttu-id="a29c4-155">Gli assembly di riferimento sono un'espansione del concetto correlato, *assembly di soli metadati*.</span><span class="sxs-lookup"><span data-stu-id="a29c4-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="a29c4-156">Per gli assembly di soli metadati i corpi di metodo vengono sostituiti con un singolo corpo `throw null`, ma sono inclusi tutti i membri, tranne i tipi anonimi.</span><span class="sxs-lookup"><span data-stu-id="a29c4-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="a29c4-157">Il motivo per usare i `throw null` corpi (in contrapposizione a nessun corpo) è in modo che **PEVerify** possa essere eseguito e superato (convalidando quindi la completezza dei metadati).</span><span class="sxs-lookup"><span data-stu-id="a29c4-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="a29c4-158">Gli assembly di riferimento rimuovono ulteriormente i metadati (membri privati) dagli assembly di soli metadati:</span><span class="sxs-lookup"><span data-stu-id="a29c4-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="a29c4-159">Un assembly di riferimento include solo i riferimenti per i requisiti nella superficie dell'API.</span><span class="sxs-lookup"><span data-stu-id="a29c4-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="a29c4-160">L'assembly reale può includere riferimenti aggiuntivi relativi a implementazioni specifiche.</span><span class="sxs-lookup"><span data-stu-id="a29c4-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="a29c4-161">Ad esempio, l'assembly di riferimento per `class C { private void M() { dynamic d = 1; ... } }` non fa riferimento ai tipi necessari per `dynamic` .</span><span class="sxs-lookup"><span data-stu-id="a29c4-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="a29c4-162">I membri-funzione privati (metodi, proprietà ed eventi) vengono rimossi quando la rimozione non impatta in maniera visibile sulla compilazione.</span><span class="sxs-lookup"><span data-stu-id="a29c4-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="a29c4-163">Se non sono presenti attributi [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) , vengono rimossi anche i membri della funzione interna.</span><span class="sxs-lookup"><span data-stu-id="a29c4-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="a29c4-164">I metadati negli assembly di riferimento continuano a contenere le informazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="a29c4-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="a29c4-165">Tutti i tipi, inclusi i tipi privati e annidati.</span><span class="sxs-lookup"><span data-stu-id="a29c4-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="a29c4-166">Tutti gli attributi, anche quelli interni.</span><span class="sxs-lookup"><span data-stu-id="a29c4-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="a29c4-167">Tutti i metodi virtuali.</span><span class="sxs-lookup"><span data-stu-id="a29c4-167">All virtual methods.</span></span>
- <span data-ttu-id="a29c4-168">Implementazioni esplicite dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="a29c4-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="a29c4-169">Proprietà ed eventi implementati in modo esplicito perché le relative funzioni di accesso sono virtuali.</span><span class="sxs-lookup"><span data-stu-id="a29c4-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="a29c4-170">Tutti i campi di strutture.</span><span class="sxs-lookup"><span data-stu-id="a29c4-170">All fields of structures.</span></span>

<span data-ttu-id="a29c4-171">Gli assembly di riferimento includono un attributo [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) a livello di assembly.</span><span class="sxs-lookup"><span data-stu-id="a29c4-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="a29c4-172">Questo attributo può essere specificato nell'origine. il compilatore non dovrà quindi sintetizzarlo.</span><span class="sxs-lookup"><span data-stu-id="a29c4-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="a29c4-173">A causa di questo attributo, i runtime rifiuteranno di caricare gli assembly di riferimento per l'esecuzione, ma possono essere caricati in modalità di sola reflection.</span><span class="sxs-lookup"><span data-stu-id="a29c4-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="a29c4-174">I dettagli della struttura di assembly di riferimento esatti dipendono dalla versione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="a29c4-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="a29c4-175">Le versioni più recenti possono scegliere di escludere un numero maggiore di metadati se è determinato come non influire sulla superficie dell'API pubblica.</span><span class="sxs-lookup"><span data-stu-id="a29c4-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="a29c4-176">Le informazioni contenute in questa sezione sono valide solo per gli assembly di riferimento generati dai compilatori Roslyn a partire da C# versione 7,1 o Visual Basic versione 15,3.</span><span class="sxs-lookup"><span data-stu-id="a29c4-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="a29c4-177">La struttura degli assembly di riferimento per le librerie .NET Framework e .NET Core può differire in alcuni dettagli, perché usano il proprio meccanismo di generazione di assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="a29c4-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="a29c4-178">Ad esempio, potrebbero avere corpi del metodo completamente vuoti anziché il `throw null` corpo.</span><span class="sxs-lookup"><span data-stu-id="a29c4-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="a29c4-179">Tuttavia, il principio generale si applica comunque: non hanno implementazioni del metodo utilizzabili e contengono metadati solo per i membri che hanno un effetto osservabile da una prospettiva API pubblica.</span><span class="sxs-lookup"><span data-stu-id="a29c4-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="a29c4-180">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a29c4-180">See also</span></span>

- [<span data-ttu-id="a29c4-181">Assembly in .NET</span><span class="sxs-lookup"><span data-stu-id="a29c4-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="a29c4-182">Panoramica sull'impostazione dei framework di destinazione</span><span class="sxs-lookup"><span data-stu-id="a29c4-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="a29c4-183">Procedura: aggiungere o rimuovere riferimenti tramite Gestione riferimenti</span><span class="sxs-lookup"><span data-stu-id="a29c4-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
