---
title: Threading gestito e non gestito in Windows
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
ms.openlocfilehash: de823297540d5ce3740a26614dbb9a82881decf3
ms.sourcegitcommit: 40de8df14289e1e05b40d6e5c1daabd3c286d70c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/22/2020
ms.locfileid: "86924383"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="38b22-102">Threading gestito e non gestito in Windows</span><span class="sxs-lookup"><span data-stu-id="38b22-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="38b22-103">La gestione di tutti i thread viene eseguita tramite la classe <xref:System.Threading.Thread> , inclusi i thread creati da Common Language Runtime e quelli creati all'esterno dell'ambiente di esecuzione che accedono all'ambiente gestito per eseguire il codice.</span><span class="sxs-lookup"><span data-stu-id="38b22-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="38b22-104">L'ambiente di esecuzione monitora tutti i thread nei relativi processi che abbiano eseguito codice nell'ambiente di esecuzione gestito.</span><span class="sxs-lookup"><span data-stu-id="38b22-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="38b22-105">Non tiene traccia di altri thread.</span><span class="sxs-lookup"><span data-stu-id="38b22-105">It does not track any other threads.</span></span> <span data-ttu-id="38b22-106">I thread possono accedere all'ambiente di esecuzione gestito tramite l'interoperabilità COM (perché il runtime espone gli oggetti gestiti come oggetti COM all'ambiente non gestito), la funzione [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) COM e la funzionalità platform invoke.</span><span class="sxs-lookup"><span data-stu-id="38b22-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="38b22-107">Quando un thread non gestito accede al runtime tramite, ad esempio, un oggetto COM Callable Wrapper, il sistema verifica l'archivio locale dei thread del thread in questione per trovare un oggetto <xref:System.Threading.Thread> gestito interno.</span><span class="sxs-lookup"><span data-stu-id="38b22-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="38b22-108">Se ne viene trovato uno, all'ambiente di esecuzione è già nota la presenza di questo thread.</span><span class="sxs-lookup"><span data-stu-id="38b22-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="38b22-109">Se non ne vengono trovati, tuttavia, il runtime compila un nuovo oggetto <xref:System.Threading.Thread> e lo installa nell'archivio locale dei thread del thread in questione.</span><span class="sxs-lookup"><span data-stu-id="38b22-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="38b22-110">Nel threading gestito, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> rappresenta l'identificazione del thread gestito stabile.</span><span class="sxs-lookup"><span data-stu-id="38b22-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="38b22-111">Per la durata del thread, questo non entrerà in conflitto con il valore di altri thread, indipendentemente dal dominio dell'applicazione da cui si è ottenuto il valore.</span><span class="sxs-lookup"><span data-stu-id="38b22-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="38b22-112">Mapping dal threading di Win32 al threading gestito</span><span class="sxs-lookup"><span data-stu-id="38b22-112">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="38b22-113">Nella tabella seguente viene mostrata la corrispondenza degli elementi del threading di Win32 con gli elementi equivalenti dell'ambiente di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="38b22-113">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="38b22-114">Si noti che questa corrispondenza non rappresenta funzionalità identiche.</span><span class="sxs-lookup"><span data-stu-id="38b22-114">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="38b22-115">Ad esempio, **TerminateThread** non esegue clausole **finally** o libera risorse e non può essere evitato.</span><span class="sxs-lookup"><span data-stu-id="38b22-115">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="38b22-116">Tuttavia, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> esegue tutto il codice di ripristino dello stato precedente, recupera tutte le risorse e può essere negato tramite <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="38b22-116">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="38b22-117">Assicurarsi di leggere attentamente la documentazione prima di fare ipotesi sulle funzionalità.</span><span class="sxs-lookup"><span data-stu-id="38b22-117">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="38b22-118">Win32</span><span class="sxs-lookup"><span data-stu-id="38b22-118">In Win32</span></span>|<span data-ttu-id="38b22-119">Common Language Runtime</span><span class="sxs-lookup"><span data-stu-id="38b22-119">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="38b22-120">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-120">**CreateThread**</span></span>|<span data-ttu-id="38b22-121">Combinazione di **Thread** e <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="38b22-121">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="38b22-122">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-122">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-123">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-123">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-124">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-124">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-125">**Sospendi**</span><span class="sxs-lookup"><span data-stu-id="38b22-125">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-126">**WaitForSingleObject** sull'handle del thread</span><span class="sxs-lookup"><span data-stu-id="38b22-126">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-127">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-127">**ExitThread**</span></span>|<span data-ttu-id="38b22-128">Nessun equivalente</span><span class="sxs-lookup"><span data-stu-id="38b22-128">No equivalent</span></span>|  
|<span data-ttu-id="38b22-129">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="38b22-129">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-130">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="38b22-130">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-131">Nessun equivalente</span><span class="sxs-lookup"><span data-stu-id="38b22-131">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-132">Nessun equivalente</span><span class="sxs-lookup"><span data-stu-id="38b22-132">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="38b22-133">Simile a **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="38b22-133">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="38b22-134">Thread gestiti e apartment COM</span><span class="sxs-lookup"><span data-stu-id="38b22-134">Managed threads and COM apartments</span></span>

<span data-ttu-id="38b22-135">Un thread gestito può essere contrassegnato per indicare che ospita un apartment [a thread singolo](/windows/desktop/com/single-threaded-apartments) o [a thread multipli](/windows/desktop/com/multithreaded-apartments).</span><span class="sxs-lookup"><span data-stu-id="38b22-135">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="38b22-136">Per ulteriori informazioni sull'architettura di threading COM, vedere [processi, thread e Apartment](/windows/desktop/com/processes--threads--and-apartments). I <xref:System.Threading.Thread.GetApartmentState%2A> <xref:System.Threading.Thread.SetApartmentState%2A> metodi, e <xref:System.Threading.Thread.TrySetApartmentState%2A> della <xref:System.Threading.Thread> classe restituiscono e assegnano lo stato dell'Apartment di un thread.</span><span class="sxs-lookup"><span data-stu-id="38b22-136">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="38b22-137">Se lo stato non è stato impostato, <xref:System.Threading.Thread.GetApartmentState%2A> restituisce <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38b22-137">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38b22-138">La proprietà può essere impostata solo quando il thread è nello stato <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> e solo una volta per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="38b22-138">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="38b22-139">Se lo stato dell'apartment non è impostato prima dell'avvio del thread, il thread viene inizializzato come un apartment a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="38b22-139">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="38b22-140">Il thread finalizzatore e tutti i thread controllati da <xref:System.Threading.ThreadPool> sono apartment a thread multipli.</span><span class="sxs-lookup"><span data-stu-id="38b22-140">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="38b22-141">Per il codice di avvio dell'applicazione, l'unico modo per controllare lo stato dell'apartment consiste nell'applicare <xref:System.MTAThreadAttribute> o <xref:System.STAThreadAttribute> alla routine del punto di ingresso.</span><span class="sxs-lookup"><span data-stu-id="38b22-141">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="38b22-142">In .NET Framework 1.0 e 1.1 la proprietà <xref:System.Threading.Thread.ApartmentState%2A> può essere impostata come la prima riga di codice.</span><span class="sxs-lookup"><span data-stu-id="38b22-142">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="38b22-143">In .NET Framework 2.0 questo non è consentito.</span><span class="sxs-lookup"><span data-stu-id="38b22-143">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="38b22-144">Gli oggetti gestiti esposti a COM si comportano come se avessero aggregato il gestore del marshalling a thread libero.</span><span class="sxs-lookup"><span data-stu-id="38b22-144">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="38b22-145">In altre parole, possono essere chiamati da qualsiasi apartment COM con modello a thread libero.</span><span class="sxs-lookup"><span data-stu-id="38b22-145">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="38b22-146">Gli unici oggetti gestiti che non esibiscono questo comportamento a thread libero sono gli oggetti che derivano da <xref:System.EnterpriseServices.ServicedComponent> o <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="38b22-146">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="38b22-147">Nell'ambiente gestito non è disponibile il supporto per <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> a meno che non si usino i contesti e le istanze gestite associate al contesto.</span><span class="sxs-lookup"><span data-stu-id="38b22-147">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="38b22-148">Se si usa Enterprise Services, l'oggetto deve derivare da <xref:System.EnterpriseServices.ServicedComponent>, che a sua volta è derivato da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="38b22-148">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="38b22-149">Quando il codice gestito effettua una chiamata agli oggetti COM, segue sempre le regole COM.</span><span class="sxs-lookup"><span data-stu-id="38b22-149">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="38b22-150">In altre parole, la chiamata viene eseguita tramite proxy di apartment COM e wrapper del contesto COM+ 1.0 come indicato da OLE32.</span><span class="sxs-lookup"><span data-stu-id="38b22-150">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="38b22-151">Problemi che causano il blocco</span><span class="sxs-lookup"><span data-stu-id="38b22-151">Blocking issues</span></span>  

<span data-ttu-id="38b22-152">Se un thread effettua una chiamata non gestita all'interno del sistema operativo che ha bloccato il thread nel codice non gestito, l'ambiente di esecuzione non ne assumerà il controllo per <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> o <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38b22-152">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38b22-153">Nel caso di <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, il runtime contrassegna il thread per **Abort** e ne assume il controllo al rientro nel codice gestito.</span><span class="sxs-lookup"><span data-stu-id="38b22-153">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="38b22-154">È preferibile usare il blocco gestito anziché quello non gestito.</span><span class="sxs-lookup"><span data-stu-id="38b22-154">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="38b22-155"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType> e così via sono tutti reattivi rispetto a <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> e <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38b22-155"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38b22-156">Inoltre, se il thread è incluso in un apartment a thread singolo, tutte queste operazioni di blocco gestite eseguiranno correttamente il pumping dei messaggi nell'apartment fintanto che il thread è bloccato.</span><span class="sxs-lookup"><span data-stu-id="38b22-156">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="38b22-157">Thread e fiber</span><span class="sxs-lookup"><span data-stu-id="38b22-157">Threads and fibers</span></span>

<span data-ttu-id="38b22-158">Il modello di threading di .NET non supporta i [fiber](/windows/desktop/procthread/fibers).</span><span class="sxs-lookup"><span data-stu-id="38b22-158">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="38b22-159">Non chiamare una funzione non gestita implementata usando i fiber.</span><span class="sxs-lookup"><span data-stu-id="38b22-159">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="38b22-160">Tali chiamate possono comportare un arresto anomalo del runtime .NET.</span><span class="sxs-lookup"><span data-stu-id="38b22-160">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="38b22-161">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="38b22-161">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
