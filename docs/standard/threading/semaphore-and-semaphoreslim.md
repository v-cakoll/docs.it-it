---
title: Semaphore e SemaphoreSlim
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET Framework], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET Framework], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: b9f7c122ac8acf34f740aca5f0fafc162edcea82
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/15/2020
ms.locfileid: "73127581"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="cac4e-102">Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="cac4e-102">Semaphore and SemaphoreSlim</span></span>
<span data-ttu-id="cac4e-103">La classe <xref:System.Threading.Semaphore?displayProperty=nameWithType> rappresenta un semaforo denominato (systemwide) o locale.</span><span class="sxs-lookup"><span data-stu-id="cac4e-103">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="cac4e-104">È un semplice wrapper per l'oggetto semaforo Win32.</span><span class="sxs-lookup"><span data-stu-id="cac4e-104">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="cac4e-105">I semafori Win32 sono semafori di conteggio che possono essere usati per controllare l'accesso a un pool di risorse.</span><span class="sxs-lookup"><span data-stu-id="cac4e-105">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="cac4e-106">La classe <xref:System.Threading.SemaphoreSlim> rappresenta un semaforo leggero e veloce che può essere usato per l'attesa in un singolo processo quando si prevedono tempi di attesa molto brevi.</span><span class="sxs-lookup"><span data-stu-id="cac4e-106">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="cac4e-107"><xref:System.Threading.SemaphoreSlim> si basa quanto più possibile sulle primitive di sincronizzazione fornite da Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="cac4e-107"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="cac4e-108">Tuttavia, fornisce anche gli handle di attesa basati sul kernel e inizializzati in modo differito necessari per supportare l'attesa in più semafori.</span><span class="sxs-lookup"><span data-stu-id="cac4e-108">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="cac4e-109"><xref:System.Threading.SemaphoreSlim> supporta anche l'utilizzo di token di annullamento, ma non supporta i semafori denominati né l'utilizzo di un handle di attesa per la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="cac4e-109"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="cac4e-110">Gestione di una risorsa limitata</span><span class="sxs-lookup"><span data-stu-id="cac4e-110">Managing a Limited Resource</span></span>  
 <span data-ttu-id="cac4e-111">I thread entrano nel semaforo chiamando il metodo <xref:System.Threading.WaitHandle.WaitOne%2A>, che viene ereditato dalla classe <xref:System.Threading.WaitHandle>, nel caso di un oggetto <xref:System.Threading.Semaphore?displayProperty=nameWithType>, oppure il metodo <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType>, nel caso di un oggetto <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="cac4e-111">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="cac4e-112">Al termine della chiamata, il conteggio del semaforo viene decrementato.</span><span class="sxs-lookup"><span data-stu-id="cac4e-112">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="cac4e-113">Quando un thread richiede accesso e il conteggio è zero, il thread si blocca.</span><span class="sxs-lookup"><span data-stu-id="cac4e-113">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="cac4e-114">Quando i thread rilasciano il semaforo chiamando il metodo <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>, i thread bloccati potranno entrare.</span><span class="sxs-lookup"><span data-stu-id="cac4e-114">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="cac4e-115">Per i thread bloccati al semaforo non esiste alcun ordine garantito, ad esempio first-in, first-out (FIFO) o last-in, first-out (LIFO).</span><span class="sxs-lookup"><span data-stu-id="cac4e-115">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="cac4e-116">Un thread può entrare nel semaforo più volte chiamando il metodo <xref:System.Threading.Semaphore?displayProperty=nameWithType> dell'oggetto <xref:System.Threading.WaitHandle.WaitOne%2A> oppure il metodo <xref:System.Threading.SemaphoreSlim> dell'oggetto <xref:System.Threading.SemaphoreSlim.Wait%2A> ripetutamente.</span><span class="sxs-lookup"><span data-stu-id="cac4e-116">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="cac4e-117">Per rilasciare il semaforo, il thread può chiamare l'overload del metodo <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> per lo stesso numero di volte oppure chiamare l'overload del metodo <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> o <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> e specificare il numero di accessi da rilasciare.</span><span class="sxs-lookup"><span data-stu-id="cac4e-117">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="cac4e-118">Semafori e identità thread</span><span class="sxs-lookup"><span data-stu-id="cac4e-118">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="cac4e-119">I due tipi di semaforo non applicano l'identità thread alle chiamate ai metodi <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A> e <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cac4e-119">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="cac4e-120">Ad esempio, uno scenario di utilizzo comune per i semafori implica un thread producer e un thread consumer, di cui uno incrementa sempre il conteggio del semaforo e l'altro lo decrementa sempre.</span><span class="sxs-lookup"><span data-stu-id="cac4e-120">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="cac4e-121">È compito del programmatore garantire che un thread non rilasci il semaforo troppe volte.</span><span class="sxs-lookup"><span data-stu-id="cac4e-121">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="cac4e-122">Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo.</span><span class="sxs-lookup"><span data-stu-id="cac4e-122">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="cac4e-123">Se un errore di programmazione nel thread B fa sì che venga chiamato `Release` due volte, entrambe le chiamate hanno esito positivo.</span><span class="sxs-lookup"><span data-stu-id="cac4e-123">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="cac4e-124">Il conteggio sul semaforo è completo e quando il thread A alla fine chiama `Release`, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.</span><span class="sxs-lookup"><span data-stu-id="cac4e-124">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="cac4e-125">Semafori denominati</span><span class="sxs-lookup"><span data-stu-id="cac4e-125">Named Semaphores</span></span>  
 <span data-ttu-id="cac4e-126">Il sistema operativo Windows consente di assegnare nomi ai semafori.</span><span class="sxs-lookup"><span data-stu-id="cac4e-126">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="cac4e-127">Un semaforo denominato è a livello di sistema:</span><span class="sxs-lookup"><span data-stu-id="cac4e-127">A named semaphore is system wide.</span></span> <span data-ttu-id="cac4e-128">vale a dire che, una volta creato, il semaforo denominato è visibile a tutti i thread in tutti i processi.</span><span class="sxs-lookup"><span data-stu-id="cac4e-128">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="cac4e-129">In questo modo, il semaforo denominato può essere usato per sincronizzare le attività di processi e thread.</span><span class="sxs-lookup"><span data-stu-id="cac4e-129">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="cac4e-130">È possibile creare un oggetto <xref:System.Threading.Semaphore> che rappresenta un semaforo di sistema denominato usando uno dei costruttori che specifica un nome.</span><span class="sxs-lookup"><span data-stu-id="cac4e-130">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cac4e-131">Poiché i semafori denominati sono a livello di sistema, è possibile avere più oggetti <xref:System.Threading.Semaphore> che rappresentano lo stesso semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="cac4e-131">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="cac4e-132">A ogni chiamata a un costruttore o al metodo <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> viene creato un nuovo oggetto <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="cac4e-132">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="cac4e-133">Specificando lo stesso nome ripetutamente verranno creati più oggetti che rappresentano lo stesso semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="cac4e-133">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="cac4e-134">Prestare attenzione quando si usano i semafori denominati:</span><span class="sxs-lookup"><span data-stu-id="cac4e-134">Be careful when you use named semaphores.</span></span> <span data-ttu-id="cac4e-135">siccome sono a livello di sistema, un altro processo che usa lo stesso nome può accedere al semaforo in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="cac4e-135">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="cac4e-136">Il malware in esecuzione sullo stesso computer potrebbe sfruttare questa opportunità per un attacco Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="cac4e-136">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="cac4e-137">Usare il controllo degli accessi per proteggere un oggetto <xref:System.Threading.Semaphore> che rappresenta un semaforo denominato, preferibilmente usando un costruttore che specifichi un oggetto <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cac4e-137">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="cac4e-138">È anche possibile applicare la sicurezza del controllo degli accessi usando il metodo <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>, ma in tal modo verrà creata una finestra di vulnerabilità tra l'ora di creazione del semaforo e l'ora in cui viene protetto.</span><span class="sxs-lookup"><span data-stu-id="cac4e-138">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="cac4e-139">La protezione dei semafori con la sicurezza del controllo degli accessi aiuta a impedire gli attacchi dannosi, ma non risolve il problema dei conflitti di nomi non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="cac4e-139">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cac4e-140">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="cac4e-140">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="cac4e-141">Funzionalità e oggetti di threading</span><span class="sxs-lookup"><span data-stu-id="cac4e-141">Threading Objects and Features</span></span>](../../../docs/standard/threading/threading-objects-and-features.md)
