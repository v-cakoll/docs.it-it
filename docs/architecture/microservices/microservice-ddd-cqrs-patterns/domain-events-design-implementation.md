---
title: 'Eventi del dominio: progettazione e implementazione'
description: Architettura di Microservizi .NET per applicazioni .NET in contenitori | Ottenere un quadro dettagliato degli eventi di dominio, un concetto chiave per stabilire la comunicazione tra le aggregazioni.
ms.date: 10/08/2018
ms.openlocfilehash: f427ed5216af11b90c5a8cede15806a11aedc76d
ms.sourcegitcommit: a4f9b754059f0210e29ae0578363a27b9ba84b64
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/05/2019
ms.locfileid: "74835546"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="ebc12-104">Eventi del dominio: progettazione e implementazione</span><span class="sxs-lookup"><span data-stu-id="ebc12-104">Domain events: design and implementation</span></span>

<span data-ttu-id="ebc12-105">Usare gli eventi del dominio per implementare in modo esplicito gli effetti collaterali delle modifiche all'interno del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="ebc12-106">In altre parole, e con riferimento alla terminologia DDD, usare gli eventi del dominio per implementare in modo esplicito gli effetti collaterali tra più aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="ebc12-107">Facoltativamente per migliorare la scalabilità e ridurre l'impatto sui blocchi di database, usare la coerenza finale tra le aggregazioni all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="ebc12-108">Che cos'è un evento del dominio?</span><span class="sxs-lookup"><span data-stu-id="ebc12-108">What is a domain event?</span></span>

<span data-ttu-id="ebc12-109">Un evento è qualcosa che si è verificato in passato.</span><span class="sxs-lookup"><span data-stu-id="ebc12-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="ebc12-110">Un evento di dominio è qualcosa che si verifica nel dominio e che deve essere notificato ad altri elementi dello stesso dominio (in-process).</span><span class="sxs-lookup"><span data-stu-id="ebc12-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="ebc12-111">In genere tali elementi reagiscono in qualche modo all'evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="ebc12-112">Un vantaggio importante degli eventi di dominio è che gli effetti collaterali possono essere espressi in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="ebc12-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="ebc12-113">Ad esempio, se si sta usando Entity Framework e deve esistere una reazione a un evento, probabilmente si scriverà codice per tutto ciò che è necessario per attivare l'evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="ebc12-114">In questo modo la regola viene accoppiata implicitamente al codice e sarà necessario verificare nel codice che la regola venga implementata.</span><span class="sxs-lookup"><span data-stu-id="ebc12-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="ebc12-115">D'altra parte, l'uso degli eventi di dominio rende il concetto esplicito perché sono presenti un elemento `DomainEvent` e almeno un elemento `DomainEventHandler`.</span><span class="sxs-lookup"><span data-stu-id="ebc12-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="ebc12-116">Ad esempio, quando viene creato un ordine nell'applicazione eShopOnContainer, l'utente diventa un acquirente, quindi viene generato un evento `OrderStartedDomainEvent` che viene gestito in `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, di conseguenza il concetto sottostante è evidente.</span><span class="sxs-lookup"><span data-stu-id="ebc12-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="ebc12-117">In sostanza, gli eventi di dominio consentono di esprimere esplicitamente le regole di dominio, in base al linguaggio comune offerto dagli esperti del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="ebc12-118">Gli eventi di dominio consentono anche una migliore separazione delle problematiche tra le classi all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="ebc12-119">È importante garantire che, proprio come in una transazione di database, vengano completate correttamente tutte le operazioni correlate a un evento di dominio oppure nessuna di esse.</span><span class="sxs-lookup"><span data-stu-id="ebc12-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="ebc12-120">Gli eventi di dominio sono simili agli eventi di tipo messaggistica, con una differenza importante.</span><span class="sxs-lookup"><span data-stu-id="ebc12-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="ebc12-121">Con la messaggistica reale, l'accodamento di messaggi, i broker di messaggi o un bus di servizio che usa il protocollo AMQP, un messaggio viene sempre inviato in modo asincrono e trasferito tra processi e computer.</span><span class="sxs-lookup"><span data-stu-id="ebc12-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="ebc12-122">Questo approccio è utile per l'integrazione di più contesti delimitati, microservizi o persino applicazioni differenti.</span><span class="sxs-lookup"><span data-stu-id="ebc12-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="ebc12-123">Tuttavia, con gli eventi del dominio si vuole generare un evento dall'operazione di dominio attualmente in esecuzione, facendo in modo che tutti gli effetti collaterali si verifichino all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="ebc12-124">Gli eventi del dominio e i relativi effetti collaterali, ossia le azioni attivate dopo l'elaborazione da parte dei gestori di eventi, devono verificarsi quasi immediatamente, in genere durante il processo, e all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="ebc12-125">Gli eventi del dominio possono quindi essere sincroni o asincroni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="ebc12-126">Gli eventi di integrazione, invece, devono essere sempre asincroni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="ebc12-127">Confronto tra eventi del dominio ed eventi di integrazione</span><span class="sxs-lookup"><span data-stu-id="ebc12-127">Domain events versus integration events</span></span>

<span data-ttu-id="ebc12-128">Da un punto di vista semantico gli eventi del dominio e quelli di integrazione si equivalgono, ovvero sono notifiche di un evento che si è appena verificato.</span><span class="sxs-lookup"><span data-stu-id="ebc12-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="ebc12-129">Tuttavia, la relativa implementazione deve essere diversa.</span><span class="sxs-lookup"><span data-stu-id="ebc12-129">However, their implementation must be different.</span></span> <span data-ttu-id="ebc12-130">Gli eventi del dominio non sono altro che messaggi inviati al dispatcher di eventi del dominio, eventualmente implementabile come mediatore in memoria in base a un contenitore IoC o a qualsiasi altro metodo.</span><span class="sxs-lookup"><span data-stu-id="ebc12-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="ebc12-131">Al contrario, lo scopo degli eventi di integrazione è propagare le transazioni e gli aggiornamenti di cui è stato eseguito il commit in altri sottosistemi, indipendentemente se si tratti di altri microservizi, contesti delimitati o persino di applicazioni esterne.</span><span class="sxs-lookup"><span data-stu-id="ebc12-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="ebc12-132">Tali eventi devono quindi verificarsi solo se l'entità è stata salvata in modo permanente. In caso contrario, è come se tutta l'operazione non fosse mai stata eseguita.</span><span class="sxs-lookup"><span data-stu-id="ebc12-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="ebc12-133">Come indicato in precedenza, gli eventi di integrazione devono essere basati sulla comunicazione asincrona tra più microservizi (altri contesti delimitati) o persino applicazioni/sistemi esterni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="ebc12-134">Di conseguenza, l'interfaccia del bus di eventi richiede un'infrastruttura che consenta la comunicazione tra processi distribuita tra servizi potenzialmente remoti.</span><span class="sxs-lookup"><span data-stu-id="ebc12-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="ebc12-135">Può essere basata su un bus di servizio commerciale, sulle code, su un database condiviso usato come cassetta postale o qualsiasi altro sistema di messaggistica distribuito e preferibilmente di tipo push.</span><span class="sxs-lookup"><span data-stu-id="ebc12-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="ebc12-136">Eventi del dominio come modalità consigliata per attivare effetti collaterali tra più aggregazioni all'interno dello stesso dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="ebc12-137">Se l'esecuzione di un comando correlato a un'istanza di aggregazione richiede l'esecuzione di regole di dominio aggiuntive su una o più aggregazioni aggiuntive, è necessario progettare e implementare questi effetti collaterali in modo che vengano attivati dagli eventi del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="ebc12-138">Come illustrato nella figura 7-14 e, in base a uno dei principali casi d'uso, un evento di dominio deve essere usato per propagare le modifiche dello stato tra più aggregazioni all'interno dello stesso modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Diagramma che mostra un evento di dominio che controlla i dati a un'aggregazione del buyer.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="ebc12-140">**Figura 7-14**.</span><span class="sxs-lookup"><span data-stu-id="ebc12-140">**Figure 7-14**.</span></span> <span data-ttu-id="ebc12-141">Eventi del dominio per garantire la coerenza tra più aggregazioni all'interno dello stesso dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="ebc12-142">La figura 7-14 Mostra la coerenza tra le aggregazioni e gli eventi del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="ebc12-143">Quando l'utente avvia un ordine, l'aggregazione Order Invia un evento `OrderStarted` dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="ebc12-144">L'evento del dominio OrderStarted viene gestito dall'aggregazione buyer per creare un oggetto buyer nel microservizio degli ordini, in base alle informazioni originali dell'utente del microservizio Identity (con le informazioni fornite nel comando CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="ebc12-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="ebc12-145">In alternativa, la radice di aggregazione può avere una sottoscrizione per gli eventi generati dai membri delle relative aggregazioni (entità figlio).</span><span class="sxs-lookup"><span data-stu-id="ebc12-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="ebc12-146">Ad esempio, ogni entità figlio OrderItem può generare un evento quando il prezzo dell'articolo è superiore a un importo specifico o quando la quantità di articoli di prodotto è troppo elevata.</span><span class="sxs-lookup"><span data-stu-id="ebc12-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="ebc12-147">La radice di aggregazione può quindi ricevere questi eventi ed eseguire un'aggregazione o un calcolo globale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="ebc12-148">È importante comprendere che questa comunicazione basata su eventi non viene implementata direttamente all'interno delle aggregazioni, ma è necessario implementare i gestori di eventi del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="ebc12-149">La gestione degli eventi del dominio avviene a livello di applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="ebc12-150">Il livello del modello di dominio deve essere incentrato solo sulla logica di dominio, un aspetto noto agli esperti di dominio, non sull'infrastruttura dell'applicazione, come i gestori e le azioni di persistenza degli effetti collaterali che usano i repository.</span><span class="sxs-lookup"><span data-stu-id="ebc12-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="ebc12-151">Pertanto, il livello dell'applicazione è quello in cui i gestori di eventi del dominio attivano azioni quando viene generato un evento di dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="ebc12-152">Gli eventi del dominio possono essere usati anche per attivare un numero qualsiasi di azioni di applicazioni e, ancor più importante, devono essere aperti ad aumentarle in futuro in modo disgiunto.</span><span class="sxs-lookup"><span data-stu-id="ebc12-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="ebc12-153">Ad esempio, quando l'ordine viene avviato è possibile pubblicare un evento del dominio per propagare queste informazioni ad altre aggregazioni o per generare azioni di applicazioni, come le notifiche.</span><span class="sxs-lookup"><span data-stu-id="ebc12-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="ebc12-154">Il punto chiave è il numero aperto di azioni da eseguire al verificarsi di un evento del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="ebc12-155">Con il tempo le azioni e le regole nel dominio e nell'applicazione aumenteranno.</span><span class="sxs-lookup"><span data-stu-id="ebc12-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="ebc12-156">Aumenteranno la complessità o il numero di azioni di effetti collaterali al verificarsi di un evento, ma se il codice è stato accoppiato "con la colla", ossia creando oggetti specifici con `new`, ogni volta che è necessario aggiungere una nuova azione occorrerà modificare anche il codice in uso e testato.</span><span class="sxs-lookup"><span data-stu-id="ebc12-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="ebc12-157">Questa modifica può generare nuovi bug e tale approccio non è conforme al [principio aperto/chiuso](https://en.wikipedia.org/wiki/Open/closed_principle) di [SOLID](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="ebc12-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="ebc12-158">Come se non bastasse, la classe originale che orchestra le operazioni aumenterebbe sempre di più, contrariamente al [principio di singola responsabilità (Single Responsibility Principle, SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="ebc12-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="ebc12-159">Se invece si usano gli eventi del dominio, è possibile creare un'implementazione con granularità fine disgiunta separando le responsabilità tramite questo approccio:</span><span class="sxs-lookup"><span data-stu-id="ebc12-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="ebc12-160">Inviare un comando, ad esempio CreateOrder.</span><span class="sxs-lookup"><span data-stu-id="ebc12-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="ebc12-161">Ricevere il comando in un gestore di comandi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="ebc12-162">Eseguire una transazione della singola aggregazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-162">Execute a single aggregate’s transaction.</span></span>
   - <span data-ttu-id="ebc12-163">(Facoltativo) Generare eventi del dominio per gli effetti collaterali, ad esempio OrderStartedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="ebc12-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="ebc12-164">Gestire gli eventi del dominio (all'interno del processo corrente) che eseguiranno un numero aperto di effetti collaterali in più aggregazioni o azioni di applicazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="ebc12-165">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="ebc12-165">For example:</span></span>
   - <span data-ttu-id="ebc12-166">Verificare o creare l'acquirente e la modalità di pagamento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="ebc12-167">Creare e inviare un evento di integrazione correlato al bus di eventi per propagare gli stati tra i microservizi o attivare azioni esterne, come l'invio di un messaggio di posta elettronica all'acquirente.</span><span class="sxs-lookup"><span data-stu-id="ebc12-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="ebc12-168">Gestire gli altri effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="ebc12-168">Handle other side effects.</span></span>

<span data-ttu-id="ebc12-169">Come illustrato nella figura 7-15, a partire dallo stesso evento di dominio è possibile gestire più azioni relative ad altre aggregazioni nel dominio o azioni di applicazioni aggiuntive che è necessario eseguire tra i microservizi che si connettono con gli eventi di integrazione e il bus di eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Diagramma che mostra un evento di dominio che passa i dati a diversi gestori eventi.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="ebc12-171">**Figura 7-15**.</span><span class="sxs-lookup"><span data-stu-id="ebc12-171">**Figure 7-15**.</span></span> <span data-ttu-id="ebc12-172">Gestione di più azioni per ogni dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="ebc12-173">Per lo stesso evento possono essere presenti diversi gestori nel livello dell'applicazione, un gestore può risolvere la coerenza tra aggregazioni, un altro può pubblicare un evento di integrazione in modo che possa essere usato da altri microservizi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="ebc12-174">In genere i gestori di eventi si trovano a livello dell'applicazione perché si usano oggetti di infrastruttura, come i repository o un'API di applicazione, per il comportamento del microservizio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="ebc12-175">In questo senso, i gestori di eventi sono simili ai gestori di comandi poiché entrambi fanno parte del livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="ebc12-176">La differenza importante è che un comando deve essere elaborato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="ebc12-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="ebc12-177">Un evento del dominio può essere elaborato zero o *n* volte perché può essere ricevuto da più ricevitori o gestori dell'evento con uno scopo diverso per ogni gestore.</span><span class="sxs-lookup"><span data-stu-id="ebc12-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="ebc12-178">La presenza di un numero aperto di gestori per ogni evento di dominio consente di aggiungere tutte le regole di dominio necessarie, senza influire sul codice corrente.</span><span class="sxs-lookup"><span data-stu-id="ebc12-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="ebc12-179">Ad esempio, implementare la regola di business seguente può essere facile come aggiungere alcuni gestori di eventi o anche uno solo:</span><span class="sxs-lookup"><span data-stu-id="ebc12-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="ebc12-180">Quando la quantità totale acquistata da un cliente nello store, con qualsiasi numero di ordini, supera $ 6.000, applicare uno sconto del 10% per ogni nuovo ordine e notificare al cliente questo sconto per gli ordini futuri con un messaggio di posta elettronica.</span><span class="sxs-lookup"><span data-stu-id="ebc12-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="ebc12-181">Implementare eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-181">Implement domain events</span></span>

<span data-ttu-id="ebc12-182">In C# un evento del dominio è semplicemente una classe o una struttura di dati, come un DTO (Data Transfer Object), con tutte le informazioni correlate all'evento che si è appena verificato nel dominio, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="ebc12-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="ebc12-183">Si tratta essenzialmente di una classe che contiene tutti i dati relativi all'evento OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="ebc12-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="ebc12-184">Nel linguaggio comune del dominio, poiché un evento è qualcosa che si è verificato in passato, il nome della classe dell'evento deve essere rappresentato con un verbo al passato, ad esempio OrderStartedDomainEvent oppure OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="ebc12-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="ebc12-185">Questa è la modalità di implementazione dell'evento di dominio nel microservizio per gli ordini in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="ebc12-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="ebc12-186">Come notato in precedenza, una caratteristica importante degli eventi è che, poiché un evento è qualcosa che si è verificato in passato, non deve variare.</span><span class="sxs-lookup"><span data-stu-id="ebc12-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="ebc12-187">Di conseguenza la classe deve essere non modificabile.</span><span class="sxs-lookup"><span data-stu-id="ebc12-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="ebc12-188">Nel codice precedente le proprietà sono di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="ebc12-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="ebc12-189">Non c'è alcun modo di aggiornare l'oggetto, è possibile solo impostarne i valori durante la creazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="ebc12-190">È importante evidenziare che se gli eventi del dominio venissero gestiti in modo asincrono, tramite una coda in cui è necessario serializzare e deserializzare gli oggetti dell'evento, le proprietà dovrebbero essere "private set" (private) invece che di sola lettura, in modo che il deserializzatore possa assegnare i valori al momento della rimozione dalla coda.</span><span class="sxs-lookup"><span data-stu-id="ebc12-190">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="ebc12-191">Ciò non è un problema nel microservizio degli ordini, dal momento che la pubblicazione/sottoscrizione dell'evento di dominio viene implementata in modo sincrono tramite MediatR.</span><span class="sxs-lookup"><span data-stu-id="ebc12-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="ebc12-192">Generare eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-192">Raise domain events</span></span>

<span data-ttu-id="ebc12-193">La domanda successiva è come generare un evento del dominio in modo che venga ricevuto dai gestori di eventi correlati.</span><span class="sxs-lookup"><span data-stu-id="ebc12-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="ebc12-194">Sono disponibili più approcci.</span><span class="sxs-lookup"><span data-stu-id="ebc12-194">You can use multiple approaches.</span></span>

<span data-ttu-id="ebc12-195">In origine Udi Dahan ha proposto, ad esempio in diversi post correlati come [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/) (Eventi del dominio - Parte 2), di usare una classe statica per la gestione e la generazione di eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="ebc12-196">Potrebbe trattarsi di una classe statica denominata DomainEvents che genera immediatamente eventi di dominio al momento della chiamata, usando una sintassi come `DomainEvents.Raise(Event myEvent)`.</span><span class="sxs-lookup"><span data-stu-id="ebc12-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="ebc12-197">Jimmy Bogard ha scritto un post di blog, [Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/) (Rafforzamento del dominio: eventi del dominio), in cui consiglia un approccio simile.</span><span class="sxs-lookup"><span data-stu-id="ebc12-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="ebc12-198">Tuttavia, quando la classe di eventi del dominio è statica, esegue anche immediatamente l'invio ai gestori.</span><span class="sxs-lookup"><span data-stu-id="ebc12-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="ebc12-199">I test e il debug risultano quindi più difficili perché i gestori di eventi con la logica degli effetti collaterali vengono eseguiti immediatamente dopo la generazione dell'evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="ebc12-200">Quando si eseguono i test e il debug, è possibile concentrarsi solo su ciò che accade nelle classi di aggregazione correnti e non essere reindirizzati improvvisamente ad altri gestori di eventi per gli effetti collaterali correlati ad altre aggregazioni o alla logica dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="ebc12-201">Per questo motivo sono stati sviluppati altri approcci, come illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="ebc12-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="ebc12-202">Approccio posticipato per la generazione e l'invio di eventi</span><span class="sxs-lookup"><span data-stu-id="ebc12-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="ebc12-203">Anziché eseguire immediatamente l'invio a un gestore di eventi del dominio, un approccio migliore consiste nell'aggiungere gli eventi del dominio a una raccolta e inviare questi eventi *immediatamente prima* o *immediatamente* *dopo* il commit della transazione, come con SaveChanges in Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="ebc12-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="ebc12-204">Questo approccio è stato descritto da Jimmy Bogard in questo post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) (Un pattern migliore per gli eventi del dominio)</span><span class="sxs-lookup"><span data-stu-id="ebc12-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="ebc12-205">È importante decidere se inviare gli eventi del dominio immediatamente prima o dopo il commit della transazione perché questa scelta determina se gli effetti collaterali verranno inclusi nella stessa transazione o in transazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="ebc12-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="ebc12-206">Nel secondo caso è necessario gestire la coerenza finale tra più aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="ebc12-207">Questo argomento verrà illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="ebc12-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="ebc12-208">L'approccio posticipato è quello usato nell'applicazione eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="ebc12-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="ebc12-209">Prima si aggiungono gli eventi che si verificano nelle entità in una raccolta o in un elenco di eventi per ogni entità.</span><span class="sxs-lookup"><span data-stu-id="ebc12-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="ebc12-210">Questo elenco deve far parte dell'oggetto entità o, ancor meglio, della classe base dell'entità, come illustrato nell'esempio seguente della classe base Entity:</span><span class="sxs-lookup"><span data-stu-id="ebc12-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="ebc12-211">Per generare un evento, è sufficiente aggiungerlo alla raccolta di eventi dal codice in qualsiasi metodo dell'entità aggregate-root.</span><span class="sxs-lookup"><span data-stu-id="ebc12-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="ebc12-212">Nel codice seguente, parte di [Order aggregate-root in eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) (Ordinare aggregate-root in eShopOnContainers), viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="ebc12-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="ebc12-213">Si noti che l'unica operazione che il metodo AddDomainEvent sta eseguendo è l'aggiunta di un evento all'elenco.</span><span class="sxs-lookup"><span data-stu-id="ebc12-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="ebc12-214">Non viene inviato alcun evento e non viene richiamato nessun gestore dell'evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="ebc12-215">In effetti si vuole inviare gli eventi in un secondo momento, al momento del commit della transazione nel database.</span><span class="sxs-lookup"><span data-stu-id="ebc12-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="ebc12-216">Se si usa Entity Framework Core, ciò significa nel metodo SaveChanges dell'oggetto DbContext di Entity Framework, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="ebc12-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="ebc12-217">Con questo codice si inviano gli eventi dell'entità ai rispettivi gestori di eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="ebc12-218">Il risultato complessivo è la separazione tra la generazione di un evento del dominio (una semplice aggiunta in un elenco in memoria) e l'invio a un gestore dell'evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="ebc12-219">Inoltre, a seconda del tipo di dispatcher in uso, si possono inviare gli eventi in modo sincrono o asincrono.</span><span class="sxs-lookup"><span data-stu-id="ebc12-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="ebc12-220">Tenere presente che in questo contesto i limiti transazionali hanno un ruolo importante.</span><span class="sxs-lookup"><span data-stu-id="ebc12-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="ebc12-221">Questo approccio può funzionare bene se l'unità di lavoro e la transazione possono estendersi su più aggregazioni, come quando si usa Entity Framework Core e un database relazionale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="ebc12-222">Se tuttavia la transazione non può estendersi sulle aggregazioni, ad esempio quando si usa un database NoSQL come Azure CosmosDB, è necessario implementare passaggi aggiuntivi per ottenere la coerenza.</span><span class="sxs-lookup"><span data-stu-id="ebc12-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="ebc12-223">Questo è un altro motivo per cui il mancato riconoscimento della persistenza non è universale, ma dipende dal sistema di archiviazione in uso.</span><span class="sxs-lookup"><span data-stu-id="ebc12-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="ebc12-224">Confronto tra singola transazione tra le aggregazioni e coerenza finale tra le aggregazioni</span><span class="sxs-lookup"><span data-stu-id="ebc12-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="ebc12-225">Una questione controversa è se eseguire una singola transazione tra le aggregazioni o usare la coerenza finale tra queste aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="ebc12-226">Molti autori di documenti sul modello DDD, come Eric Evans e Vaughn Vernon, sostengono la regola che una transazione corrisponde a un'aggregazione e pertanto sostengono la coerenza finale tra le aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="ebc12-227">Ad esempio, nel libro *Domain-Driven Design*, Eric Evans afferma il concetto seguente:</span><span class="sxs-lookup"><span data-stu-id="ebc12-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="ebc12-228">Non è previsto che una regola che si estende sulle aggregazioni venga aggiornata in ogni momento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="ebc12-229">Tramite l'elaborazione degli eventi, l'elaborazione batch o altri meccanismi di aggiornamento, è possibile risolvere le altre dipendenze in un determinato periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="ebc12-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="ebc12-230">(pagina 128)</span><span class="sxs-lookup"><span data-stu-id="ebc12-230">(page 128)</span></span>

<span data-ttu-id="ebc12-231">Vaughn Vernon afferma quanto segue in una [progettazione di aggregazione efficace. Parte II: creazione di aggregazioni](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)interagiscono:</span><span class="sxs-lookup"><span data-stu-id="ebc12-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="ebc12-232">Pertanto, se l'esecuzione di un comando in un'istanza di aggregazione richiede l'esecuzione di regole business aggiuntive su una o più aggregazioni, utilizzare la coerenza finale \[...\] esiste una modalità pratica per supportare la coerenza finale in un modello DDD.</span><span class="sxs-lookup"><span data-stu-id="ebc12-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="ebc12-233">Un metodo di aggregazione pubblica un evento del dominio che viene recapitato in tempo a uno o più sottoscrittori asincroni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="ebc12-234">Questa spiegazione logica si basa sull'adozione di transazioni con granularità fine anziché su transazioni che si estendono su molte aggregazioni o entità.</span><span class="sxs-lookup"><span data-stu-id="ebc12-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="ebc12-235">L'idea è che, nel secondo caso, il numero di blocchi di database sarà notevole nelle applicazioni su larga scala con esigenze di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="ebc12-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="ebc12-236">Accettare il fatto che le applicazioni con scalabilità elevata non necessitano di una coerenza transazionale immediata tra più aggregazioni consente di accettare il concetto di coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="ebc12-237">Le modifiche atomiche spesso non sono necessarie per l'azienda e, in ogni caso, è responsabilità degli esperti di dominio indicare se operazioni specifiche necessitano di transazioni atomiche.</span><span class="sxs-lookup"><span data-stu-id="ebc12-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="ebc12-238">Se un'operazione richiede sempre una transazione atomica tra più aggregazioni, ci si potrebbe chiedere se l'aggregazione deve essere di dimensione maggiore o non è stata progettata correttamente.</span><span class="sxs-lookup"><span data-stu-id="ebc12-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="ebc12-239">Tuttavia, altri sviluppatori e progettisti come Jimmy Bogard concordano sull'estensione di una singola transazione tra diverse aggregazioni, ma solo quando queste aggregazioni aggiuntive sono correlate agli effetti collaterali per lo stesso comando originale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="ebc12-240">Ad esempio, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) (Un pattern migliore per gli eventi del dominio) Bogard afferma il concetto seguente:</span><span class="sxs-lookup"><span data-stu-id="ebc12-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="ebc12-241">In genere, si desidera che gli effetti collaterali di un evento di dominio si verifichino all'interno della stessa transazione logica, ma non necessariamente nello stesso ambito di generazione dell'evento del dominio \[...\] appena prima di eseguire il commit della transazione, si inviano gli eventi ai rispettivi gestori.</span><span class="sxs-lookup"><span data-stu-id="ebc12-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="ebc12-242">Se si inviano gli eventi del dominio immediatamente *prima* del commit della transazione originale, si vuole che gli effetti collaterali di questi eventi vengano inclusi nella stessa transazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="ebc12-243">Ad esempio, se il metodo SaveChanges dell'oggetto DbContext di Entity Framework presenta un errore, la transazione eseguirà il rollback di tutte le modifiche, incluso il risultato di tutte le operazioni degli effetti collaterali implementate dai rispettivi gestori di eventi del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="ebc12-244">Ciò avviene perché l'ambito della vita dell'oggetto DbContext viene definito come "con ambito" per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="ebc12-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="ebc12-245">Pertanto, l'oggetto DbContext viene condiviso tra più oggetti del repository di cui viene creata un'istanza all'interno della stesso grafo di oggetto o ambito.</span><span class="sxs-lookup"><span data-stu-id="ebc12-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="ebc12-246">Questo coincide con l'ambito HttpRequest quando si sviluppano app MVC o API Web.</span><span class="sxs-lookup"><span data-stu-id="ebc12-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="ebc12-247">Effettivamente entrambi gli approcci, la singola transazione atomica e la coerenza finale, possono essere corretti.</span><span class="sxs-lookup"><span data-stu-id="ebc12-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="ebc12-248">Dipende molto dai requisiti aziendali e del dominio e dalle indicazioni degli esperti del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="ebc12-249">Dipende anche dalla scalabilità necessaria per il servizio perché le transazioni più granulari hanno un impatto minore sui blocchi di database.</span><span class="sxs-lookup"><span data-stu-id="ebc12-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="ebc12-250">Dipende anche dall'investimento sul codice che si è disposti a fare perché la coerenza finale richiede codice più complesso per rilevare possibili incoerenze tra le aggregazioni e la necessità di implementare azioni di compensazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="ebc12-251">Tenere in considerazione che se si esegue il commit delle modifiche nell'aggregazione originale e, successivamente, quando gli eventi vengono inviati, si verifica un problema e i gestori di eventi non possono eseguire il commit dei relativi effetti collaterali, si verificheranno incoerenze tra le aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="ebc12-252">Un modo per consentire azioni di compensazione consiste nell'archiviare gli eventi del dominio in tabelle di database aggiuntive in modo che possano far parte della transazione originale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="ebc12-253">Successivamente è possibile usare un processo batch che rilevi le incoerenze ed esegua azioni di compensazione confrontando l'elenco di eventi con lo stato corrente delle aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="ebc12-254">Le azioni di compensazione rientrano in un argomento complesso che richiederà un'analisi approfondita in prima persona e una discussione con l'utente del business e gli esperti di dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="ebc12-255">In ogni caso è possibile scegliere l'approccio necessario.</span><span class="sxs-lookup"><span data-stu-id="ebc12-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="ebc12-256">L'approccio posticipato iniziale, che genera gli eventi prima del commit per usare una singola transazione, è l'approccio più semplice quando si usa Entity Framework Core e un database relazionale.</span><span class="sxs-lookup"><span data-stu-id="ebc12-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="ebc12-257">È più facile da implementare e valido in molti casi aziendali.</span><span class="sxs-lookup"><span data-stu-id="ebc12-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="ebc12-258">È anche l'approccio adottato nel microservizio per gli ordini in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="ebc12-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="ebc12-259">Come si inviano effettivamente gli eventi ai rispettivi gestori di eventi?</span><span class="sxs-lookup"><span data-stu-id="ebc12-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="ebc12-260">Che cos'è l'oggetto `_mediator` illustrato nell'esempio precedente?</span><span class="sxs-lookup"><span data-stu-id="ebc12-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="ebc12-261">Ha a che fare con le tecniche e gli artefatti che si usano per eseguire il mapping tra gli eventi e i rispettivi gestori di eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="ebc12-262">Il dispatcher di eventi del dominio: mapping dagli eventi ai gestori di eventi</span><span class="sxs-lookup"><span data-stu-id="ebc12-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="ebc12-263">Una volta che si è in grado di inviare o pubblicare gli eventi, è necessario un tipo di elemento che pubblicherà l'evento in modo che ogni gestore correlato possa ricevere ed elaborare gli effetti collaterali in base a questo evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="ebc12-264">Un approccio è un sistema di messaggistica reale o anche un bus di eventi, possibilmente basato su un bus di servizio anziché sugli eventi in memoria.</span><span class="sxs-lookup"><span data-stu-id="ebc12-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="ebc12-265">Tuttavia, nel primo caso, la messaggistica reale sarebbe eccessiva per l'elaborazione di eventi del dominio perché è sufficiente elaborare gli eventi all'interno dello stesso processo, ovvero all'interno dello stesso dominio e livello di applicazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="ebc12-266">Un altro modo per eseguire il mapping degli eventi a più gestori di eventi consiste nell'usare la registrazione di tipi in un contenitore IoC in modo che sia possibile dedurre in modo dinamico dove inviare gli eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="ebc12-267">In altre parole, è necessario sapere quali gestori di eventi devono ricevere un evento specifico.</span><span class="sxs-lookup"><span data-stu-id="ebc12-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="ebc12-268">Nella figura 7-16 viene illustrato un approccio semplificato specifico.</span><span class="sxs-lookup"><span data-stu-id="ebc12-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Diagramma che illustra un dispatcher di eventi del dominio che invia eventi ai gestori appropriati.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="ebc12-270">**Figura 7-16**.</span><span class="sxs-lookup"><span data-stu-id="ebc12-270">**Figure 7-16**.</span></span> <span data-ttu-id="ebc12-271">Dispatcher di eventi del dominio usando IoC</span><span class="sxs-lookup"><span data-stu-id="ebc12-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="ebc12-272">È possibile compilare autonomamente tutto il codice complesso e gli elementi per implementare questo approccio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="ebc12-273">Tuttavia è possibile anche usare le librerie disponibili come [MediatR](https://github.com/jbogard/MediatR), che usa il contenitore IoC in background.</span><span class="sxs-lookup"><span data-stu-id="ebc12-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="ebc12-274">È possibile pertanto usare direttamente le interfacce predefinite e i metodi di pubblicazione/invio dell'oggetto mediator.</span><span class="sxs-lookup"><span data-stu-id="ebc12-274">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="ebc12-275">Nel codice è necessario prima registrare i tipi di gestori di eventi nel contenitore IoC, come illustrato nell'esempio seguente nel [microservizio per gli ordini eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="ebc12-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="ebc12-276">Il codice prima identifica l'assembly contenente i gestori di eventi del dominio, individuando l'assembly contenente i gestori, usando typeof(ValidateOrAddBuyerAggregateWhenXxxx), ma si potrebbe scegliere qualsiasi altro gestore di eventi per individuare l'assembly.</span><span class="sxs-lookup"><span data-stu-id="ebc12-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="ebc12-277">Poiché tutti i gestori di eventi implementano l'interfaccia IAsyncNotificationHandler, il codice cerca solo questi tipi e registra tutti i gestori di eventi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="ebc12-278">Creazione di sottoscrizioni per gli eventi del dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-278">How to subscribe to domain events</span></span>

<span data-ttu-id="ebc12-279">Quando si usa MediatR, ogni gestore di eventi deve usare un tipo di evento fornito nel parametro generico dell'interfaccia INotificationHandler, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="ebc12-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="ebc12-280">In base alla relazione tra l'evento e il gestore dell'evento, che può essere considerato la sottoscrizione, l'artefatto MediatR può individuare e attivare tutti i gestori di eventi per ogni evento.</span><span class="sxs-lookup"><span data-stu-id="ebc12-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="ebc12-281">Come gestire gli eventi del dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-281">How to handle domain events</span></span>

<span data-ttu-id="ebc12-282">Infine, il gestore di eventi implementa in genere il codice al livello dell'applicazione che usa i repository dell'infrastruttura per ottenere le aggregazioni aggiuntive necessarie e per eseguire la logica del dominio per gli effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="ebc12-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="ebc12-283">Nel seguente [codice del gestore dell'evento del dominio in eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs) viene illustrato un esempio di implementazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="ebc12-284">Il codice del gestore dell'evento del dominio precedente viene considerato codice a livello dell'applicazione perché usa i repository di infrastruttura, come spiegato nella sezione successiva sul livello di persistenza dell'infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="ebc12-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="ebc12-285">I gestori di eventi possono anche usare altri componenti dell'infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="ebc12-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="ebc12-286">Gli eventi del dominio possono generare eventi di integrazione da pubblicare al di fuori dei limiti del microservizio</span><span class="sxs-lookup"><span data-stu-id="ebc12-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="ebc12-287">Infine, è importante ricordare che a volte è possibile propagare eventi tra più microservizi.</span><span class="sxs-lookup"><span data-stu-id="ebc12-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="ebc12-288">La propagazione è un evento di integrazione e potrebbe essere pubblicata tramite un bus di eventi da un qualsiasi gestore dell'evento di dominio specifico.</span><span class="sxs-lookup"><span data-stu-id="ebc12-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="ebc12-289">Conclusioni sugli eventi del dominio</span><span class="sxs-lookup"><span data-stu-id="ebc12-289">Conclusions on domain events</span></span>

<span data-ttu-id="ebc12-290">Come illustrato, usare gli eventi del dominio per implementare in modo esplicito gli effetti collaterali delle modifiche all'interno del dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="ebc12-291">Per usare la terminologia DDD, usare gli eventi del dominio per implementare in modo esplicito gli effetti collaterali tra una o più aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="ebc12-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="ebc12-292">Inoltre, per migliorare la scalabilità e ridurre l'impatto sui blocchi di database, facoltativamente usare la coerenza finale tra le aggregazioni all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="ebc12-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="ebc12-293">L'app di riferimento USA [Mediator](https://github.com/jbogard/MediatR) per propagare gli eventi del dominio synchonously tra le aggregazioni, all'interno di una singola transazione.</span><span class="sxs-lookup"><span data-stu-id="ebc12-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchonously across aggregates, within a single transaction.</span></span> <span data-ttu-id="ebc12-294">Tuttavia, è anche possibile usare un'implementazione di AMQP, ad esempio [RabbitMQ](https://www.rabbitmq.com/) o il [bus di servizio di Azure](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) , per propagare gli eventi del dominio in modo asincrono, usando la coerenza finale, ma, come indicato in precedenza, è necessario prendere in considerazione la necessità di azioni di compensazione in caso di errori.</span><span class="sxs-lookup"><span data-stu-id="ebc12-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ebc12-295">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="ebc12-295">Additional resources</span></span>

- <span data-ttu-id="ebc12-296">**Greg Young. Che cos'è un evento di dominio?**</span><span class="sxs-lookup"><span data-stu-id="ebc12-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="ebc12-297">**Jan Stenberg. Eventi del dominio e \ coerenza finale**</span><span class="sxs-lookup"><span data-stu-id="ebc12-297">**Jan Stenberg. Domain Events and Eventual Consistency** \</span></span>
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="ebc12-298">**Jimmy Bogard. Un modello di eventi di dominio migliore** </span><span class="sxs-lookup"><span data-stu-id="ebc12-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="ebc12-299">**Vaughn Vernon. Parte II della progettazione dell'aggregazione efficace: le aggregazioni interagiscono** </span><span class="sxs-lookup"><span data-stu-id="ebc12-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="ebc12-300">**Jimmy Bogard. Rafforzamento del dominio: eventi del dominio** </span><span class="sxs-lookup"><span data-stu-id="ebc12-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="ebc12-301">**Tony, Esempio di modello di eventi del dominio** </span><span class="sxs-lookup"><span data-stu-id="ebc12-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="ebc12-302">**UDI. Come creare modelli di dominio completamente incapsulati** </span><span class="sxs-lookup"><span data-stu-id="ebc12-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="ebc12-303">**UDI. Eventi del dominio-Take 2** </span><span class="sxs-lookup"><span data-stu-id="ebc12-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <http://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="ebc12-304">**UDI. Eventi del dominio:**  \ di salvezza</span><span class="sxs-lookup"><span data-stu-id="ebc12-304">**Udi Dahan. Domain Events – Salvation** \</span></span>
  <http://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="ebc12-305">**Jan Kronquist. Non pubblicare eventi del dominio, restituirli.**</span><span class="sxs-lookup"><span data-stu-id="ebc12-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="ebc12-306">**Cesar de la Torre. Eventi del dominio rispetto agli eventi di integrazione nelle architetture DDD e microservizi** </span><span class="sxs-lookup"><span data-stu-id="ebc12-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="ebc12-307">[Precedente](client-side-validation.md)
>[Successivo](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="ebc12-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
