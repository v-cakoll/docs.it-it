---
title: Scrivere un host di runtime di .NET Core personalizzato
description: Informazioni su come ospitare il runtime di .NET Core dal codice nativo per supportare scenari avanzati che richiedono il controllo del funzionamento del runtime di .NET Core.
author: mjrousos
ms.date: 12/21/2018
ms.openlocfilehash: 46c7873a1865db04cf1c2b1bb2ded2b5dacbcc8d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "78239898"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="a239d-103">Scrivere un host di .NET Core personalizzato per controllare il runtime di .NET dal codice nativo</span><span class="sxs-lookup"><span data-stu-id="a239d-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="a239d-104">Come tutto il codice gestito, le applicazioni .NET Core sono eseguite da un host.</span><span class="sxs-lookup"><span data-stu-id="a239d-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="a239d-105">L'host è responsabile dell'avvio del runtime, inclusi i componenti come JIT e Garbage Collector, nonché della chiamata dei punti di ingresso gestiti.</span><span class="sxs-lookup"><span data-stu-id="a239d-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="a239d-106">L'hosting del runtime di .NET Core rappresenta uno scenario avanzato e, nella maggior parte dei casi, gli sviluppatori .NET Core non devono occuparsi dell'hosting poiché i processi di compilazione di .NET Core includono un host predefinito per l'esecuzione delle applicazioni .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="a239d-107">Tuttavia, in alcune circostanze particolari può essere utile ospitare in modo esplicito il runtime di .NET Core per richiamare il codice gestito in un processo nativo o per avere maggior controllo sul funzionamento del runtime.</span><span class="sxs-lookup"><span data-stu-id="a239d-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="a239d-108">Questo articolo offre una panoramica dei passaggi necessari per avviare il runtime di .NET Core dal codice nativo ed eseguire al suo interno il codice gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="a239d-109">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="a239d-109">Prerequisites</span></span>

<span data-ttu-id="a239d-110">Poiché gli host sono applicazioni native, questa esercitazione illustra la costruzione di un'applicazione in linguaggio C, per ospitare .NET Core.Because hosts are native applications, this tutorial covers constructing a C'è Application to host .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-110">Because hosts are native applications, this tutorial covers constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="a239d-111">Sarà necessario un ambiente di sviluppo C++, come quello incluso in [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs).</span><span class="sxs-lookup"><span data-stu-id="a239d-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="a239d-112">Poiché sarà necessaria anche un'applicazione .NET Core semplice con cui testare l'host, installare [.NET Core SDK](https://dotnet.microsoft.com/download) e [creare una piccola app di test .NET Core](with-visual-studio.md), ad esempio un'app 'Hello World'.</span><span class="sxs-lookup"><span data-stu-id="a239d-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://dotnet.microsoft.com/download) and [build a small .NET Core test app](with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="a239d-113">L'app 'Hello World' creata dal nuovo modello di progetto della console di .NET Core è sufficiente.</span><span class="sxs-lookup"><span data-stu-id="a239d-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="a239d-114">API di hosting</span><span class="sxs-lookup"><span data-stu-id="a239d-114">Hosting APIs</span></span>
<span data-ttu-id="a239d-115">Per l'hosting di .NET Core è possibile usare tre API diverse.</span><span class="sxs-lookup"><span data-stu-id="a239d-115">There are three different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="a239d-116">In questo articolo (e gli [esempi](https://github.com/dotnet/samples/tree/master/core/hosting)associati ) vengono illustrate tutte le opzioni.</span><span class="sxs-lookup"><span data-stu-id="a239d-116">This article (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) covers all options.</span></span>

* <span data-ttu-id="a239d-117">La soluzione preferita per l'hosting del runtime di .NET Core in .NET Core 3.0 e versioni successive è costituita dalle API delle librerie `nethost` e `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="a239d-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="a239d-118">Questi punti di ingresso gestiscono la complessità legata alla ricerca e alla configurazione del runtime per l'inizializzazione e consentono sia l'avvio di un'applicazione gestita sia la chiamata a un metodo gestito statico.</span><span class="sxs-lookup"><span data-stu-id="a239d-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="a239d-119">La soluzione preferita per l'hosting del runtime di .NET Core nelle versioni precedenti .NET Core 3.0 è costituita dall'API [CoreClrHost.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h).</span><span class="sxs-lookup"><span data-stu-id="a239d-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [CoreClrHost.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="a239d-120">Questa API espone le funzioni necessarie per avviare e arrestare facilmente il runtime e per richiamare il codice gestito tramite l'avvio di un file con estensione exe gestito o la chiamata di metodi gestiti statici.</span><span class="sxs-lookup"><span data-stu-id="a239d-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>
* <span data-ttu-id="a239d-121">È possibile ospitare .NET Core anche tramite l'interfaccia `ICLRRuntimeHost4` in [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h).</span><span class="sxs-lookup"><span data-stu-id="a239d-121">.NET Core can also be hosted with the `ICLRRuntimeHost4` interface in [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h).</span></span> <span data-ttu-id="a239d-122">Questa API è stata introdotta prima di CoreClrHost.h ed è quindi possibile che se ne sia già osservato l'uso in host precedenti.</span><span class="sxs-lookup"><span data-stu-id="a239d-122">This API has been around longer than CoreClrHost.h, so you may have seen older hosts using it.</span></span> <span data-ttu-id="a239d-123">L'API funziona ancora e consente un livello di controllo leggermente superiore sul processo di hosting rispetto a CoreClrHost.</span><span class="sxs-lookup"><span data-stu-id="a239d-123">It still works and allows a bit more control over the hosting process than CoreClrHost.</span></span> <span data-ttu-id="a239d-124">Per la maggior parte degli scenari, CoreClrHost.h è tuttavia il metodo attualmente preferito grazie alla maggiore semplicità delle relative API.</span><span class="sxs-lookup"><span data-stu-id="a239d-124">For most scenarios, though, CoreClrHost.h is preferred now because of its simpler APIs.</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="a239d-125">Host di esempio</span><span class="sxs-lookup"><span data-stu-id="a239d-125">Sample Hosts</span></span>

<span data-ttu-id="a239d-126">Nel repository GitHub dotnet/samples sono disponibili [host di esempio](https://github.com/dotnet/samples/tree/master/core/hosting) che illustrano i passaggi descritti nelle esercitazioni riportate di seguito.</span><span class="sxs-lookup"><span data-stu-id="a239d-126">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="a239d-127">I commenti presenti negli esempi associano chiaramente i passaggi numerati di queste esercitazioni al punto in cui vengono eseguiti nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="a239d-127">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="a239d-128">Per istruzioni sul download, vedere [Esempi ed esercitazioni](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span><span class="sxs-lookup"><span data-stu-id="a239d-128">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="a239d-129">Tenere presente che gli host di esempio sono destinati all'uso ai fini dell'apprendimento. In questi host, progettati per enfatizzare la leggibilità più che l'efficienza, il controllo degli errori non è prioritario.</span><span class="sxs-lookup"><span data-stu-id="a239d-129">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="a239d-130">Creare un host con NetHost.h e HostFxr.h</span><span class="sxs-lookup"><span data-stu-id="a239d-130">Create a host using NetHost.h and HostFxr.h</span></span>

<span data-ttu-id="a239d-131">La procedura seguente illustra come usare le librerie `nethost` e `hostfxr` per avviare il runtime di .NET Core in un'applicazione nativa ed eseguire una chiamata a un metodo statico gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-131">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="a239d-132">L'[esempio](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) usa la libreria e l'intestazione `nethost` installate con .NET SDK ed esegue la copia dei file [`coreclr_delegates.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) e [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) dal repository [dotnet/core-setup](https://github.com/dotnet/core-setup).</span><span class="sxs-lookup"><span data-stu-id="a239d-132">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) files from the [dotnet/core-setup](https://github.com/dotnet/core-setup) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="a239d-133">Passaggio 1: Caricare HostFxr e ottenere le funzioni di hosting esportate</span><span class="sxs-lookup"><span data-stu-id="a239d-133">Step 1 - Load HostFxr and get exported hosting functions</span></span>

<span data-ttu-id="a239d-134">La libreria `nethost` fornisce la funzione `get_hostfxr_path` per l'individuazione della libreria `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="a239d-134">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="a239d-135">La libreria `hostfxr` espone le funzioni per l'hosting del runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-135">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="a239d-136">L'elenco completo delle funzioni [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) è disponibile in e il documento di [progettazione di hosting nativo](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="a239d-136">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span></span> <span data-ttu-id="a239d-137">L'esempio e questa esercitazione usano le funzioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="a239d-137">The sample and this tutorial use the following:</span></span>

* <span data-ttu-id="a239d-138">`hostfxr_initialize_for_runtime_config`: inizializza un contesto host e si prepara per l'inizializzazione del runtime .NET Core utilizzando la configurazione di runtime specificata.</span><span class="sxs-lookup"><span data-stu-id="a239d-138">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="a239d-139">`hostfxr_get_runtime_delegate`: ottiene un delegato per la funzionalità di runtime.</span><span class="sxs-lookup"><span data-stu-id="a239d-139">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="a239d-140">`hostfxr_close`: chiude un contesto host.</span><span class="sxs-lookup"><span data-stu-id="a239d-140">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="a239d-141">Per trovare la libreria `hostfxr` si usa `get_hostfxr_path`.</span><span class="sxs-lookup"><span data-stu-id="a239d-141">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="a239d-142">La libreria viene quindi caricata e vengono recuperate le relative funzioni esportate.</span><span class="sxs-lookup"><span data-stu-id="a239d-142">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="a239d-143">Passaggio 2: Inizializzare e avviare il runtime di .NET Core</span><span class="sxs-lookup"><span data-stu-id="a239d-143">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="a239d-144">Le funzioni `hostfxr_initialize_for_runtime_config` e `hostfxr_get_runtime_delegate` inizializzano e avviano il runtime di .NET Core usando la configurazione di runtime per il componente gestito che verrà caricato.</span><span class="sxs-lookup"><span data-stu-id="a239d-144">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="a239d-145">La funzione `hostfxr_get_runtime_delegate` viene usata per ottenere un delegato di runtime che consente il caricamento di un assembly gestito e il recupero di un puntatore di funzione a un metodo statico in tale assembly.</span><span class="sxs-lookup"><span data-stu-id="a239d-145">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="a239d-146">Passaggio 3: Caricare l'assembly gestito e ottenere un puntatore di funzione a un metodo gestito</span><span class="sxs-lookup"><span data-stu-id="a239d-146">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="a239d-147">Il delegato di runtime viene chiamato per caricare l'assembly gestito e ottenere un puntatore di funzione a un metodo gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-147">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="a239d-148">Il delegato richiede il percorso dell'assembly, il nome del tipo e il nome del metodo come input e restituisce un puntatore di funzione che può essere usato per richiamare il metodo gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-148">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="a239d-149">Passando `nullptr` come nome del tipo delegato quando viene eseguita la chiamata al delegato di runtime, l'esempio usa una firma predefinita per il metodo gestito:</span><span class="sxs-lookup"><span data-stu-id="a239d-149">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="a239d-150">È possibile usare una firma diversa specificando il nome del tipo delegato quando viene eseguita la chiamata al delegato di runtime.</span><span class="sxs-lookup"><span data-stu-id="a239d-150">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="a239d-151">Passaggio 4: Eseguire il codice gestito</span><span class="sxs-lookup"><span data-stu-id="a239d-151">Step 4 - Run managed code!</span></span>

<span data-ttu-id="a239d-152">L'host nativo può ora chiamare il metodo gestito e passare i parametri desiderati.</span><span class="sxs-lookup"><span data-stu-id="a239d-152">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="a239d-153">Creare un host tramite CoreClrHost.h</span><span class="sxs-lookup"><span data-stu-id="a239d-153">Create a host using CoreClrHost.h</span></span>

<span data-ttu-id="a239d-154">La procedura seguente illustra come usare l'API CoreClrHost.h per avviare il runtime di .NET Core in un'applicazione nativa e chiamare un metodo statico gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-154">The following steps detail how to use the CoreClrHost.h API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="a239d-155">I frammenti di codice disponibili in questo documento usano alcune API specifiche di Windows, ma l'[host di esempio completo](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) include percorsi di codice Windows e Linux.</span><span class="sxs-lookup"><span data-stu-id="a239d-155">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="a239d-156">L'[host Unix CoreRun](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) mostra un esempio più complesso, tratto dal mondo reale, di hosting tramite coreclrhost.h.</span><span class="sxs-lookup"><span data-stu-id="a239d-156">The [Unix CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) shows a more complex, real-world example of hosting using coreclrhost.h.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="a239d-157">Passaggio 1: Trovare e caricare CoreCLR</span><span class="sxs-lookup"><span data-stu-id="a239d-157">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="a239d-158">Le API del runtime di .NET Core si trovano in *coreclr.dll* (in Windows), in *libcoreclr.so* (in Linux) o in *libcoreclr.dylib* (in macOS).</span><span class="sxs-lookup"><span data-stu-id="a239d-158">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="a239d-159">Il primo passaggio per l'hosting di .NET Core consiste nel caricare la libreria CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="a239d-159">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="a239d-160">Alcuni host eseguono il probe in diversi percorsi o usano parametri di input per trovare la libreria mentre altri la caricano da un determinato percorso, ad esempio una posizione accanto all'host o il percorso di un computer.</span><span class="sxs-lookup"><span data-stu-id="a239d-160">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="a239d-161">Una volta trovata, la `LoadLibraryEx` libreria viene `dlopen` caricata con (su Windows) o (su Linux/macOS).</span><span class="sxs-lookup"><span data-stu-id="a239d-161">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="a239d-162">Passaggio 2: Ottenere le funzioni di hosting di .NET Core</span><span class="sxs-lookup"><span data-stu-id="a239d-162">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="a239d-163">CoreClrHost include diversi metodi importanti utili per l'hosting di .NET Core:</span><span class="sxs-lookup"><span data-stu-id="a239d-163">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="a239d-164">`coreclr_initialize`: avvia il runtime di .NET Core e configura l'AppDomain predefinito (e solo).</span><span class="sxs-lookup"><span data-stu-id="a239d-164">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="a239d-165">`coreclr_execute_assembly`: esegue un assembly gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-165">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="a239d-166">`coreclr_create_delegate`: crea un puntatore a funzione a un metodo gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-166">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="a239d-167">`coreclr_shutdown`: arresta il runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-167">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="a239d-168">`coreclr_shutdown_2`: `coreclr_shutdown`like , ma recupera anche il codice di uscita del codice gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-168">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="a239d-169">Dopo aver caricato la libreria CoreCLR, il passaggio `GetProcAddress` successivo consiste `dlsym` nell'ottenere riferimenti a queste funzioni usando (in Windows) o (in Linux/macOS).</span><span class="sxs-lookup"><span data-stu-id="a239d-169">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="a239d-170">Passaggio 3: Preparare le proprietà di runtime</span><span class="sxs-lookup"><span data-stu-id="a239d-170">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="a239d-171">Prima di avviare il runtime è necessario preparare alcune proprietà per specificare il comportamento, in particolare del caricatore di assembly.</span><span class="sxs-lookup"><span data-stu-id="a239d-171">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="a239d-172">Le proprietà comuni includono:</span><span class="sxs-lookup"><span data-stu-id="a239d-172">Common properties include:</span></span>

* <span data-ttu-id="a239d-173">`TRUSTED_PLATFORM_ASSEMBLIES` Elenco di percorsi di assembly, delimitato da ";" in Windows e da ":" in Linux, che il runtime riuscirà a risolvere per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="a239d-173">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="a239d-174">Alcuni host includono manifesti hardcoded con l'elenco degli assembly che possono caricare.</span><span class="sxs-lookup"><span data-stu-id="a239d-174">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="a239d-175">Altri inseriranno una libreria in determinate posizioni, ad esempio accanto a *coreclr.dll*, in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="a239d-175">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="a239d-176">`APP_PATHS` Elenco di percorsi in cui eseguire il probe se un assembly non viene trovato nell'elenco degli assembly di piattaforma attendibili (TPA).</span><span class="sxs-lookup"><span data-stu-id="a239d-176">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="a239d-177">Poiché l'host ha un maggiore controllo su quali assembly vengono caricati tramite l'elenco TPA, è consigliabile che gli host determinino gli assembly che prevedono di caricare e li elenchino in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="a239d-177">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="a239d-178">Se è necessaria l'esecuzione del probe al runtime, tuttavia, questa proprietà può abilitare tale scenario.</span><span class="sxs-lookup"><span data-stu-id="a239d-178">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="a239d-179">`APP_NI_PATHS` Elenco simile ad APP_PATHS ma che deve includere i percorsi in cui verrà eseguito il probe di immagini native.</span><span class="sxs-lookup"><span data-stu-id="a239d-179">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="a239d-180">`NATIVE_DLL_SEARCH_DIRECTORIES` Questa proprietà è un elenco di percorsi in cui il caricatore esegue il probe quando cerca librerie native chiamate tramite p/invoke.</span><span class="sxs-lookup"><span data-stu-id="a239d-180">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="a239d-181">`PLATFORM_RESOURCE_ROOTS`Questo elenco include i percorsi in cui eseguire il probe per gli assembly satellite delle risorse (nelle sottodirectory specifiche delle impostazioni cultura).</span><span class="sxs-lookup"><span data-stu-id="a239d-181">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="a239d-182">In questo host di esempio l'elenco TPA viene creato includendo semplicemente tutte le librerie presenti nella directory corrente:</span><span class="sxs-lookup"><span data-stu-id="a239d-182">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="a239d-183">Poiché l'esempio è semplice, è necessaria solo la proprietà `TRUSTED_PLATFORM_ASSEMBLIES`:</span><span class="sxs-lookup"><span data-stu-id="a239d-183">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="a239d-184">Passaggio 4: Avviare il runtime</span><span class="sxs-lookup"><span data-stu-id="a239d-184">Step 4 - Start the runtime</span></span>

<span data-ttu-id="a239d-185">A differenza dell'API di hosting mscoree.h, descritta di seguito, le API CoreCLRHost.h avviano il runtime e creano l'AppDomain predefinito con una singola chiamata.</span><span class="sxs-lookup"><span data-stu-id="a239d-185">Unlike the mscoree.h hosting API (described below), CoreCLRHost.h APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="a239d-186">La funzione `coreclr_initialize` accetta un percorso di base, il nome e le proprietà descritte in precedenza e restituisce un handle all'host tramite il parametro `hostHandle`.</span><span class="sxs-lookup"><span data-stu-id="a239d-186">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="a239d-187">Passaggio 5: Eseguire il codice gestito</span><span class="sxs-lookup"><span data-stu-id="a239d-187">Step 5 - Run managed code!</span></span>

<span data-ttu-id="a239d-188">Con il runtime avviato, l'host può chiamare il codice gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-188">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="a239d-189">Questa operazione può essere eseguita in due modi diversi.</span><span class="sxs-lookup"><span data-stu-id="a239d-189">This can be done in a couple of different ways.</span></span> <span data-ttu-id="a239d-190">Il codice di esempio collegato a questa esercitazione usa la funzione `coreclr_create_delegate` per creare un delegato a un metodo gestito statico.</span><span class="sxs-lookup"><span data-stu-id="a239d-190">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="a239d-191">Questa API accetta come input il [nome dell'assembly](../../standard/assembly/names.md), un nome di tipo qualificato dallo spazio dei nomi e il nome del metodo e restituisce un delegato che può essere usato per richiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="a239d-191">This API takes the [assembly name](../../standard/assembly/names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="a239d-192">In questo esempio l'host può ora chiamare `managedDelegate` per eseguire il metodo `ManagedWorker.DoWork`.</span><span class="sxs-lookup"><span data-stu-id="a239d-192">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="a239d-193">In alternativa è possibile usare la funzione `coreclr_execute_assembly` per avviare un file eseguibile gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-193">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="a239d-194">Questa API accetta come parametri di input un percorso di assembly e una matrice di argomenti.</span><span class="sxs-lookup"><span data-stu-id="a239d-194">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="a239d-195">Carica l'assembly in questo percorso e ne richiama il metodo principale.</span><span class="sxs-lookup"><span data-stu-id="a239d-195">It loads the assembly at that path and invokes its main method.</span></span>

```C++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="a239d-196">Passaggio 6: Arrestare e pulire</span><span class="sxs-lookup"><span data-stu-id="a239d-196">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="a239d-197">Quando l'host ha infine terminato l'esecuzione del codice gestito, il runtime di .NET Core viene arrestato con `coreclr_shutdown` o `coreclr_shutdown_2`.</span><span class="sxs-lookup"><span data-stu-id="a239d-197">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="a239d-198">CoreCLR non supporta la reinizializzazione o lo scaricamento.</span><span class="sxs-lookup"><span data-stu-id="a239d-198">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="a239d-199">Non chiamare di nuovo `coreclr_initialize` né scaricare la libreria CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="a239d-199">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="create-a-host-using-mscoreeh"></a><span data-ttu-id="a239d-200">Creare un host tramite Mscoree.h</span><span class="sxs-lookup"><span data-stu-id="a239d-200">Create a host using Mscoree.h</span></span>

<span data-ttu-id="a239d-201">Come accennato in precedenza, CoreClrHost.h è attualmente il metodo preferito per l'hosting del runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-201">As mentioned previously, CoreClrHost.h is now the preferred method of hosting the .NET Core runtime.</span></span> <span data-ttu-id="a239d-202">Ma è ancora possibile usare l'interfaccia `ICLRRuntimeHost4` se le interfacce CoreClrHost.h non sono sufficienti, ad esempio se sono necessari flag di avvio non standard o se è necessario un AppDomainManager nel dominio predefinito.</span><span class="sxs-lookup"><span data-stu-id="a239d-202">The `ICLRRuntimeHost4` interface can still be used, though, if the CoreClrHost.h interfaces aren't sufficient (if non-standard startup flags are needed, for example, or if an AppDomainManager is needed on the default domain).</span></span> <span data-ttu-id="a239d-203">Queste istruzioni illustrano la procedura di hosting di .NET Core tramite mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="a239d-203">These instructions will guide you through hosting .NET Core using mscoree.h.</span></span>

<span data-ttu-id="a239d-204">L'[host CoreRun](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/corerun) mostra un esempio più complesso, tratto dal mondo reale, di hosting tramite mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="a239d-204">The [CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/corerun) shows a more complex, real-world example of hosting using mscoree.h.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="a239d-205">Nota su mscoree.h</span><span class="sxs-lookup"><span data-stu-id="a239d-205">A note about mscoree.h</span></span>
<span data-ttu-id="a239d-206">L'interfaccia di hosting di .NET Core `ICLRRuntimeHost4` è definita in [MSCOREE.IDL](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/inc/MSCOREE.IDL).</span><span class="sxs-lookup"><span data-stu-id="a239d-206">The `ICLRRuntimeHost4` .NET Core hosting interface is defined in [MSCOREE.IDL](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="a239d-207">Una versione dell'intestazione di questo file (mscoree.h) a cui l'host dovrà fare riferimento viene prodotta tramite MIDL quando viene compilato il [runtime di .NET Core](https://github.com/dotnet/runtime/).</span><span class="sxs-lookup"><span data-stu-id="a239d-207">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/runtime/) is built.</span></span> <span data-ttu-id="a239d-208">Se non si desidera compilare il runtime di .NET Core, mscoree.h è disponibile anche come [intestazione predefinita](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/) nel repository dotnet/runtime.</span><span class="sxs-lookup"><span data-stu-id="a239d-208">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/) in the dotnet/runtime repository.</span></span>

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="a239d-209">Passaggio 1: Identificare il punto di ingresso gestito</span><span class="sxs-lookup"><span data-stu-id="a239d-209">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="a239d-210">Dopo il riferimento alle intestazioni necessarie, ad esempio [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h) e stdio.h, una delle prime operazioni che devono essere eseguite da un host .NET Core consiste nell'individuare il punto di ingresso gestito da usare.</span><span class="sxs-lookup"><span data-stu-id="a239d-210">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="a239d-211">Nell'host di esempio, questa operazione viene eseguita semplicemente prendendo il primo argomento `main` della riga di comando per l'host come percorso di un file binario gestito il cui metodo verrà eseguito.</span><span class="sxs-lookup"><span data-stu-id="a239d-211">In our sample host, this is done by just taking the first command-line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#1)]

### <a name="step-2---find-and-load-coreclr"></a><span data-ttu-id="a239d-212">Passaggio 2: Trovare e caricare CoreCLR</span><span class="sxs-lookup"><span data-stu-id="a239d-212">Step 2 - Find and load CoreCLR</span></span>
<span data-ttu-id="a239d-213">Le API del runtime di .NET Core sono in *CoreCLR.dll* in Windows.</span><span class="sxs-lookup"><span data-stu-id="a239d-213">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="a239d-214">Per ottenere l'interfaccia di hosting (`ICLRRuntimeHost4`), è necessario trovare e caricare *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="a239d-214">To get our hosting interface (`ICLRRuntimeHost4`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="a239d-215">L'host definisce una convenzione per l'individuazione di *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="a239d-215">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="a239d-216">Alcuni host prevedono che il file si trovi in un percorso noto del computer, ad esempio *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*.</span><span class="sxs-lookup"><span data-stu-id="a239d-216">Some hosts expect the file to be present in a well-known machine-wide location (such as *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*).</span></span> <span data-ttu-id="a239d-217">Altri prevedono che *CoreCLR.dll* venga caricato da un percorso successivo all'host o all'app da ospitare.</span><span class="sxs-lookup"><span data-stu-id="a239d-217">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="a239d-218">Altri ancora usano una variabile di ambiente per trovare la libreria.</span><span class="sxs-lookup"><span data-stu-id="a239d-218">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="a239d-219">In Linux o macOS, la libreria di runtime principale è *rispettivamente libcoreclr.so* o *libcoreclr.dylib*.</span><span class="sxs-lookup"><span data-stu-id="a239d-219">On Linux or macOS, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="a239d-220">L'host di esempio esegue il probe in alcuni percorsi comuni di *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="a239d-220">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="a239d-221">Una volta trovato, deve `LoadLibrary` essere `dlopen` caricato tramite (o su Linux/macOS).</span><span class="sxs-lookup"><span data-stu-id="a239d-221">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/macOS).</span></span>

[!code-cpp[NetCoreHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost4-instance"></a><span data-ttu-id="a239d-222">Passaggio 3: Ottenere un'istanza ICLRRuntimeHost4</span><span class="sxs-lookup"><span data-stu-id="a239d-222">Step 3 - Get an ICLRRuntimeHost4 Instance</span></span>
<span data-ttu-id="a239d-223">L'interfaccia `ICLRRuntimeHost4` di hosting `GetProcAddress` viene `dlsym` recuperata chiamando (o su Linux/macOS) su `GetCLRRuntimeHost`, quindi richiamando tale funzione.</span><span class="sxs-lookup"><span data-stu-id="a239d-223">The `ICLRRuntimeHost4` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/macOS) on `GetCLRRuntimeHost`, and then invoking that function.</span></span>

[!code-cpp[NetCoreHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#3)]

### <a name="step-4---set-startup-flags-and-start-the-runtime"></a><span data-ttu-id="a239d-224">Passaggio 4: Impostare i flag di avvio e avviare il runtime</span><span class="sxs-lookup"><span data-stu-id="a239d-224">Step 4 - Set startup flags and start the runtime</span></span>
<span data-ttu-id="a239d-225">Con un `ICLRRuntimeHost4` disponibile, è ora possibile specificare flag di avvio del runtime e avviare il runtime.</span><span class="sxs-lookup"><span data-stu-id="a239d-225">With an `ICLRRuntimeHost4` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="a239d-226">I flag di avvio determinano il Garbage Collector (GC) da usare (simultaneo o server), l'uso di AppDomain singoli o multipli e i criteri di ottimizzazione del caricatore da usare per il caricamento di assembly indipendente dal dominio.</span><span class="sxs-lookup"><span data-stu-id="a239d-226">Startup flags determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#4)]

<span data-ttu-id="a239d-227">Il runtime viene avviato con una chiamata alla funzione `Start`.</span><span class="sxs-lookup"><span data-stu-id="a239d-227">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="a239d-228">Passaggio 5: Preparazione delle impostazioni dell'AppDomain</span><span class="sxs-lookup"><span data-stu-id="a239d-228">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="a239d-229">Dopo aver avviato il runtime, sarà necessario impostare un AppDomain.</span><span class="sxs-lookup"><span data-stu-id="a239d-229">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="a239d-230">Poiché quando si crea un AppDomain .NET sono presenti numerose opzioni da specificare, è necessario preparare tali impostazioni.</span><span class="sxs-lookup"><span data-stu-id="a239d-230">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="a239d-231">I flag AppDomain specificano i comportamenti di AppDomain correlati alla sicurezza e all'interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="a239d-231">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="a239d-232">Gli host Silverlight precedenti usavano queste impostazioni per creare il codice utente mediante sandbox, mentre gli host .NET Core più recenti eseguono il codice utente come totalmente attendibile e abilitano l'interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="a239d-232">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#5)]

<span data-ttu-id="a239d-233">Dopo aver deciso quali flag AppDomain usare, è necessario definire le proprietà dell'AppDomain.</span><span class="sxs-lookup"><span data-stu-id="a239d-233">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="a239d-234">Le proprietà sono coppie chiave/valore delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="a239d-234">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="a239d-235">Molte delle proprietà riguardano la modalità con la quale l'AppDomain caricherà gli assembly.</span><span class="sxs-lookup"><span data-stu-id="a239d-235">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="a239d-236">Le proprietà di AppDomain comuni includono:</span><span class="sxs-lookup"><span data-stu-id="a239d-236">Common AppDomain properties include:</span></span>

* <span data-ttu-id="a239d-237">`TRUSTED_PLATFORM_ASSEMBLIES`Si tratta di un elenco di `;` percorsi `:` di assembly (delimitati da Windows e su Linux/macOS) a cui AppDomain deve assegnare priorità al caricamento e concedere l'attendibilità totale (anche in domini parzialmente attendibili).</span><span class="sxs-lookup"><span data-stu-id="a239d-237">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by `;` on Windows and `:` on Linux/macOS) which the AppDomain should prioritize loading and give full trust to (even in partially trusted domains).</span></span> <span data-ttu-id="a239d-238">Questo elenco deve contenere assembly 'Framework' e altri moduli attendibili, analogamente a GAC negli scenari .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a239d-238">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="a239d-239">Alcuni host inseriranno le librerie accanto a *coreclr.dll* nell'elenco, mentre altri avranno manifesti hardcoded che elencano gli assembly attendibili per i propri scopi.</span><span class="sxs-lookup"><span data-stu-id="a239d-239">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="a239d-240">`APP_PATHS` Elenco di percorsi in cui eseguire il probe se un assembly non viene trovato nell'elenco degli assembly di piattaforma attendibili (TPA).</span><span class="sxs-lookup"><span data-stu-id="a239d-240">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="a239d-241">Poiché l'host ha un maggiore controllo su quali assembly vengono caricati tramite l'elenco TPA, è consigliabile che gli host determinino gli assembly che prevedono di caricare e li elenchino in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="a239d-241">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="a239d-242">Se è necessaria l'esecuzione del probe al runtime, tuttavia, questa proprietà può abilitare tale scenario.</span><span class="sxs-lookup"><span data-stu-id="a239d-242">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="a239d-243">`APP_NI_PATHS` Elenco molto simile ad APP_PATHS ma che deve includere i percorsi in cui verrà eseguito il probe delle immagini native.</span><span class="sxs-lookup"><span data-stu-id="a239d-243">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="a239d-244">`NATIVE_DLL_SEARCH_DIRECTORIES` Questa proprietà è un elenco di percorsi in cui il caricatore esegue il probe quando cerca DLL native chiamate tramite p/invoke.</span><span class="sxs-lookup"><span data-stu-id="a239d-244">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
* <span data-ttu-id="a239d-245">`PLATFORM_RESOURCE_ROOTS`Questo elenco include i percorsi in cui eseguire il probe per gli assembly satellite delle risorse (nelle sottodirectory specifiche delle impostazioni cultura).</span><span class="sxs-lookup"><span data-stu-id="a239d-245">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="a239d-246">In questo [host di esempio semplice](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree) queste proprietà sono impostate come segue:</span><span class="sxs-lookup"><span data-stu-id="a239d-246">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="a239d-247">Passaggio 6: Creare l'AppDomain</span><span class="sxs-lookup"><span data-stu-id="a239d-247">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="a239d-248">Dopo aver preparato tutti i flag e le proprietà AppDomain, è possibile usare `ICLRRuntimeHost4::CreateAppDomainWithManager` per impostare l'AppDomain.</span><span class="sxs-lookup"><span data-stu-id="a239d-248">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost4::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="a239d-249">Questa funzione accetta facoltativamente un nome di assembly completo e un nome di tipo da usare come gestore AppDomain del dominio.</span><span class="sxs-lookup"><span data-stu-id="a239d-249">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="a239d-250">Un gestore AppDomain può consentire a un host di controllare alcuni aspetti del comportamento dell'AppDomain e può offrire i punti di ingresso per l'avvio di codice gestito se l'host non intende richiamare il codice utente direttamente.</span><span class="sxs-lookup"><span data-stu-id="a239d-250">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>

[!code-cpp[NetCoreHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="a239d-251">Passaggio 7: Eseguire il codice gestito</span><span class="sxs-lookup"><span data-stu-id="a239d-251">Step 7 - Run managed code!</span></span>
<span data-ttu-id="a239d-252">Con un AppDomain attivo e in esecuzione, l'host può ora avviare l'esecuzione del codice gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-252">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="a239d-253">Il modo più semplice per eseguire questa operazione consiste nell'usare `ICLRRuntimeHost4::ExecuteAssembly` per richiamare un metodo del punto di ingresso dell'assembly gestito.</span><span class="sxs-lookup"><span data-stu-id="a239d-253">The easiest way to do this is to use `ICLRRuntimeHost4::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="a239d-254">Si noti che questa funzione funziona solo in scenari con dominio singolo.</span><span class="sxs-lookup"><span data-stu-id="a239d-254">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#8)]

<span data-ttu-id="a239d-255">Se `ExecuteAssembly` non soddisfa le esigenze dell'host, un'altra opzione consiste nell'usare `CreateDelegate` per creare un puntatore funzione a un metodo gestito statico.</span><span class="sxs-lookup"><span data-stu-id="a239d-255">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="a239d-256">Questa operazione richiede che l'host conosca la firma del metodo chiamato per poter creare il tipo di puntatore funzione ma offre agli host la flessibilità di richiamare codice diverso da un punto di ingresso dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="a239d-256">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span> <span data-ttu-id="a239d-257">Il nome dell'assembly specificato nel secondo parametro è il [nome completo dell'assembly gestito](../../standard/assembly/names.md) della raccolta da caricare.</span><span class="sxs-lookup"><span data-stu-id="a239d-257">The assembly name provided in the second parameter is the [full managed assembly name](../../standard/assembly/names.md) of the library to load.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
    domainId,
    L"HW, Version=1.0.0.0, Culture=neutral", // Target managed assembly
    L"ConsoleApplication.Program",           // Target managed type
    L"Main",                                 // Target entry point (static method)
    (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="a239d-258">Passaggio 8: Pulire</span><span class="sxs-lookup"><span data-stu-id="a239d-258">Step 8 - Clean up</span></span>
<span data-ttu-id="a239d-259">È necessario infine che l'host esegua una pulizia scaricando gli AppDomain, interrompendo il runtime e rilasciando il riferimento `ICLRRuntimeHost4`.</span><span class="sxs-lookup"><span data-stu-id="a239d-259">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost4` reference.</span></span>

[!code-cpp[NetCoreHost#9](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#9)]

<span data-ttu-id="a239d-260">CoreCLR non supporta lo scaricamento.</span><span class="sxs-lookup"><span data-stu-id="a239d-260">CoreCLR does not support unloading.</span></span> <span data-ttu-id="a239d-261">Non scaricare la libreria CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="a239d-261">Do not unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="a239d-262">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="a239d-262">Conclusion</span></span>
<span data-ttu-id="a239d-263">Dopo aver compilato l'host, è possibile testarlo eseguendolo dalla riga di comando e passando gli argomenti previsti dall'host, ad esempio l'app gestita da eseguire per l'host di esempio mscoree.</span><span class="sxs-lookup"><span data-stu-id="a239d-263">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects (like the managed app to run for the mscoree example host).</span></span> <span data-ttu-id="a239d-264">Quando si specifica l'app .NET Core che deve essere eseguita dall'host, assicurarsi di usare il file DLL prodotto da `dotnet build`.</span><span class="sxs-lookup"><span data-stu-id="a239d-264">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="a239d-265">Gli eseguibili (file con estensione exe) prodotti da `dotnet publish` per applicazioni autonome e complete sono in realtà l'host .NET Core predefinito, in modo che l'app possa essere avviata direttamente dalla riga di comando nei principali scenari. Il codice utente viene compilato in un file DLL con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="a239d-265">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="a239d-266">Se le cose non funzionano inizialmente, verificare che *coreclr.dll* sia disponibile nel percorso previsto dall'host, che tutte le librerie Framework necessarie siano nell'elenco TPA e che il numero di bit di CoreCLR (32 bit o 64 bit) corrisponda al modo in cui è stato compilato l'host.</span><span class="sxs-lookup"><span data-stu-id="a239d-266">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32-bit or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="a239d-267">Sebbene rappresenti uno scenario avanzato che molti sviluppatori non richiedono, l'hosting del runtime di .NET Core può essere molto utile per gli sviluppatori che devono avviare codice gestito da un processo nativo o che necessitano di maggior controllo sul comportamento del runtime di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a239d-267">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
