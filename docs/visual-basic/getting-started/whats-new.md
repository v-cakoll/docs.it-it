---
title: "Novità in Visual Basic"
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 4df9a34e078de9daeff85c894afbbf4d60501f6b
ms.sourcegitcommit: 96cc82cac4650adfb65ba351506d8a8fbcd17b5c
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/19/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="206b2-102">Novità in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="206b2-102">What's new for Visual Basic</span></span>

<span data-ttu-id="206b2-103">Questo argomento elenca i nomi delle funzionalità principali per ogni versione di Visual Basic con le descrizioni dettagliate delle funzionalità nuove e migliorate nell'ultima versione del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="206b2-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="206b2-104">Versione corrente</span><span class="sxs-lookup"><span data-stu-id="206b2-104">Current Version</span></span>

<span data-ttu-id="206b2-105">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="206b2-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="206b2-106">Per le funzionalità nuove, vedere [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="206b2-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="206b2-107">Versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="206b2-107">Previous versions</span></span>

<span data-ttu-id="206b2-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="206b2-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="206b2-109">Per le funzionalità nuove, vedere [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="206b2-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="206b2-110">Visual Basic/Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="206b2-110">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="206b2-111">Per le funzionalità nuove, vedere [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="206b2-111">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="206b2-112">Visual Basic/Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="206b2-112">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="206b2-113">Technology Preview della piattaforma del compilatore .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="206b2-113">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="206b2-114">Visual Basic/Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="206b2-114">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="206b2-115">Parole chiave `Async` e `await`, iteratori, attributi relativi alle informazioni sul chiamante</span><span class="sxs-lookup"><span data-stu-id="206b2-115">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="206b2-116">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="206b2-116">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="206b2-117">Proprietà implementate automaticamente, inizializzatori di insieme, continuazione di riga implicita, elementi dinamici, covarianza/controvarianza generica, accesso agli spazi dei nomi globali</span><span class="sxs-lookup"><span data-stu-id="206b2-117">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="206b2-118">Visual Basic/Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="206b2-118">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="206b2-119">Language Integrated Query (LINQ), valori letterali XML, inferenza del tipo di variabile locale, inizializzatori di oggetto, tipi anonimi, metodi di estensione, inferenza del tipo `var` locale, espressioni lambda, operatore `if`, metodi parziali, tipi di valore nullable</span><span class="sxs-lookup"><span data-stu-id="206b2-119">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="206b2-120">Visual Basic/Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="206b2-120">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="206b2-121">Tipo `My` e tipi di helper (accesso all'app, al computer, al file system, alla rete)</span><span class="sxs-lookup"><span data-stu-id="206b2-121">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="206b2-122">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="206b2-122">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="206b2-123">Operatori di scorrimento bit, dichiarazione di variabile del ciclo</span><span class="sxs-lookup"><span data-stu-id="206b2-123">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="206b2-124">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="206b2-124">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="206b2-125">Prima versione di Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="206b2-125">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="206b2-126">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="206b2-126">Visual Basic 15.5</span></span>

[<span data-ttu-id="206b2-127">Argomenti denominati non finali</span><span class="sxs-lookup"><span data-stu-id="206b2-127">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="206b2-128">In Visual Basic 15.3 e versioni precedenti, quando una chiamata al metodo includeva argomenti in base alla posizione e al nome, gli argomenti posizionali dovevano precedere gli argomenti denominati.</span><span class="sxs-lookup"><span data-stu-id="206b2-128">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="206b2-129">A partire da Visual Basic 15,5, gli argomenti posizionali e denominati possono trovarsi in qualsiasi ordine, purché tutti gli argomenti fino all'ultimo argomento posizionale si trovino nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="206b2-129">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="206b2-130">Ciò è particolarmente utile quando gli argomenti denominati vengono utilizzati per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="206b2-130">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="206b2-131">Ad esempio, la seguente chiamata al metodo ha due argomenti posizionali tra un argomento denominato.</span><span class="sxs-lookup"><span data-stu-id="206b2-131">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="206b2-132">L'argomento denominato chiarisce che il valore 19 rappresenta un'età.</span><span class="sxs-lookup"><span data-stu-id="206b2-132">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="206b2-133">**Separatore esadecimale/binario/ottali iniziale**</span><span class="sxs-lookup"><span data-stu-id="206b2-133">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="206b2-134">Visual Basic 2017 ha aggiunto il supporto del carattere di sottolineatura (`_`) come separatore di cifre.</span><span class="sxs-lookup"><span data-stu-id="206b2-134">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="206b2-135">A partire da Visual Basic 15.5, è possibile usare il carattere di sottolineatura come separatore iniziale tra il prefisso e la cifra esadecimale, binaria o ottale.</span><span class="sxs-lookup"><span data-stu-id="206b2-135">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="206b2-136">L'esempio seguente usa il separatore di cifra iniziali per definire 3.271.948.384 come numero esadecimale:</span><span class="sxs-lookup"><span data-stu-id="206b2-136">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="206b2-137">Per usare il carattere di sottolineatura come separatore iniziale, è necessario aggiungere l'elemento seguente al file di progetto (\*.vbproj) di Visual Basic:</span><span class="sxs-lookup"><span data-stu-id="206b2-137">To use the under score character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="206b2-138">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="206b2-138">Visual Basic 15.3</span></span>

[<span data-ttu-id="206b2-139">Inferenza di tupla denominata</span><span class="sxs-lookup"><span data-stu-id="206b2-139">Named tuple inference</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="206b2-140">Quando si assegna il valore di elementi di tupla provenienti da variabili, Visual Basic deduce il nome degli elementi di tupla dai nomi di variabili corrispondenti; non è necessario assegnare esplicitamente un nome a un elemento di tupla.</span><span class="sxs-lookup"><span data-stu-id="206b2-140">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="206b2-141">L'esempio seguente usa l'inferenza per creare una tupla con tre elementi denominati, `state`, `stateName`, e `capital`.</span><span class="sxs-lookup"><span data-stu-id="206b2-141">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

## <a name="visual-basic-2017"></a><span data-ttu-id="206b2-142">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="206b2-142">Visual Basic 2017</span></span>

[<span data-ttu-id="206b2-143">Tuple</span><span class="sxs-lookup"><span data-stu-id="206b2-143">Tuples</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="206b2-144">Le tuple sono una semplice struttura dei dati che viene solitamente usata per restituire più valori da una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="206b2-144">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="206b2-145">In genere, per restituire più valori da un metodo, è necessario eseguire una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="206b2-145">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="206b2-146">Definire un tipo personalizzato (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="206b2-146">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="206b2-147">Si tratta di una soluzione complicata.</span><span class="sxs-lookup"><span data-stu-id="206b2-147">This is a heavyweight solution.</span></span>

- <span data-ttu-id="206b2-148">Definire uno o più parametri `ByRef` e restituire un valore dal metodo.</span><span class="sxs-lookup"><span data-stu-id="206b2-148">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="206b2-149">Grazie al supporto per tuple di Visual Basic è possibile definire rapidamente una tupla, assegnare facoltativamente nomi semantici ai rispettivi valori e recuperare rapidamente i relativi valori.</span><span class="sxs-lookup"><span data-stu-id="206b2-149">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="206b2-150">L'esempio seguente esegue il wrapping di una chiamata al metodo <xref:System.Int32.TryParse%2A> e restituisce una tupla.</span><span class="sxs-lookup"><span data-stu-id="206b2-150">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="206b2-151">A questo punto è possibile chiamare il metodo e gestire la tupla restituita con codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="206b2-151">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="206b2-152">**Valori letterali binari e separatori di cifre**</span><span class="sxs-lookup"><span data-stu-id="206b2-152">**Binary literals and digit separators**</span></span>

<span data-ttu-id="206b2-153">È possibile definire un valore letterale binario usando il prefisso `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="206b2-153">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="206b2-154">È anche possibile usare il carattere di sottolineatura `_` come separatore di cifre per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="206b2-154">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="206b2-155">Nell'esempio seguente vengono usate entrambe le funzionalità per assegnare un valore `Byte` e visualizzarlo come un numero decimale, esadecimale e binario.</span><span class="sxs-lookup"><span data-stu-id="206b2-155">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="206b2-156">Per altre informazioni, vedere la sezione dedicata alle assegnazioni di valori letterali dei tipi di dati [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) e [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="206b2-156">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="206b2-157">**Supporto per valori di riferimento restituiti C#** </span><span class="sxs-lookup"><span data-stu-id="206b2-157">**Support for C# reference return values**</span></span>

<span data-ttu-id="206b2-158">A partire da C# 7, C# supporta i valori di riferimento restituiti.</span><span class="sxs-lookup"><span data-stu-id="206b2-158">Starting with C# 7, C# supports reference return values.</span></span> <span data-ttu-id="206b2-159">Pertanto, quando la chiamata al metodo riceve un valore di riferimento restituito, lo può modificare.</span><span class="sxs-lookup"><span data-stu-id="206b2-159">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="206b2-160">Visual Basic non consente di creare metodi con valori di riferimento restituiti, ma consente di usare e modificare tali valori.</span><span class="sxs-lookup"><span data-stu-id="206b2-160">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="206b2-161">Ad esempio, la classe `Sentence` seguente scritta in C# include un metodo `FindNext` che rileva la parola successiva in una frase che inizia con una sottostringa specificata.</span><span class="sxs-lookup"><span data-stu-id="206b2-161">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="206b2-162">La stringa viene restituita come valore di riferimento restituito. Una variabile `Boolean` passata dal riferimento al metodo indica se la ricerca ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="206b2-162">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="206b2-163">A questo punto il chiamante non solo può leggere il valore restituito, ma lo può anche modificare. Tale modifica si riflette sulla classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="206b2-163">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="206b2-164">In parole semplici, è possibile modificare la parola trovata nella frase usando un codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="206b2-164">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="206b2-165">Si noti che non si sta assegnando un valore al metodo, ma all'espressione che il metodo restituisce, ovvero il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="206b2-165">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="206b2-166">Esiste tuttavia un problema con questo codice. Se non viene trovata una corrispondenza, il metodo restituisce la prima parola.</span><span class="sxs-lookup"><span data-stu-id="206b2-166">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="206b2-167">L'esempio non esamina il valore dell'argomento `Boolean` per determinare se viene trovata una corrispondenza. Modifica quindi la prima parola se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="206b2-167">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="206b2-168">Nell'esempio seguente questo problema viene risolto sostituendo la prima parola con la parola stessa se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="206b2-168">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="206b2-169">Una soluzione migliore consiste nell'usare un metodo helper al quale il riferimento passa il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="206b2-169">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="206b2-170">Il metodo helper può quindi modificare l'argomento passato dal riferimento.</span><span class="sxs-lookup"><span data-stu-id="206b2-170">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="206b2-171">Nell'esempio seguente viene eseguita questa operazione.</span><span class="sxs-lookup"><span data-stu-id="206b2-171">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="206b2-172">Per altre informazioni, vedere [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md) (Valori di riferimento restituiti).</span><span class="sxs-lookup"><span data-stu-id="206b2-172">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="206b2-173">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="206b2-173">Visual Basic 14</span></span>

[<span data-ttu-id="206b2-174">Nameof</span><span class="sxs-lookup"><span data-stu-id="206b2-174">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="206b2-175">È possibile ottenere il nome di stringa non qualificato di un tipo o di un membro, da usare in un messaggio di errore senza definire una stringa a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="206b2-175">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="206b2-176">In questo modo il codice sarà corretto anche durante il refactoring.</span><span class="sxs-lookup"><span data-stu-id="206b2-176">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="206b2-177">Questa funzionalità è utile anche per l'associazione di collegamenti MVC (Modello-Vista-Controller) e la generazione di eventi di modifica di proprietà.</span><span class="sxs-lookup"><span data-stu-id="206b2-177">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="206b2-178">Interpolazione di stringhe</span><span class="sxs-lookup"><span data-stu-id="206b2-178">String Interpolation</span></span>](../../csharp/language-reference/keywords/interpolated-strings.md)  
 <span data-ttu-id="206b2-179">È possibile usare espressioni di interpolazione di stringhe per costruire stringhe.</span><span class="sxs-lookup"><span data-stu-id="206b2-179">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="206b2-180">Un'espressione di stringa interpolata è simile a una stringa di modello che contiene espressioni.</span><span class="sxs-lookup"><span data-stu-id="206b2-180">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="206b2-181">In relazione agli argomenti, è più facile comprendere una stringa interpolata che la [formattazione composita](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="206b2-181">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="206b2-182">Indicizzazione e accesso ai membri condizionali null</span><span class="sxs-lookup"><span data-stu-id="206b2-182">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="206b2-183">È possibile verificare la presenza di valori null con una sintassi molto leggera prima di eseguire un'operazione di accesso ai membri (`?.`) o di indice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="206b2-183">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="206b2-184">Questi operatori consentono di scrivere meno codice per gestire i controlli null, soprattutto per l'ordinamento decrescente delle strutture di dati.</span><span class="sxs-lookup"><span data-stu-id="206b2-184">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="206b2-185">Se l'operando di sinistra o il riferimento a un oggetto è null, le operazioni restituiscono null.</span><span class="sxs-lookup"><span data-stu-id="206b2-185">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="206b2-186">Valori letterali stringa multilinea</span><span class="sxs-lookup"><span data-stu-id="206b2-186">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="206b2-187">I valori letterali stringa possono contenere sequenze di nuove righe.</span><span class="sxs-lookup"><span data-stu-id="206b2-187">String literals can contain newline sequences.</span></span>  <span data-ttu-id="206b2-188">Non è più necessario usare `<xml><![CDATA[...text with newlines...]]></xml>.Value` come soluzione alternativa.</span><span class="sxs-lookup"><span data-stu-id="206b2-188">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="206b2-189">Commenti</span><span class="sxs-lookup"><span data-stu-id="206b2-189">Comments</span></span>  
<span data-ttu-id="206b2-190">È possibile inserire commenti dopo le continuazioni di riga implicita, all'interno delle espressioni dell'inizializzatore e tra i termini delle espressioni LINQ.</span><span class="sxs-lookup"><span data-stu-id="206b2-190">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="206b2-191">Risoluzione dei nomi completi più intelligente</span><span class="sxs-lookup"><span data-stu-id="206b2-191">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="206b2-192">In precedenza, con un codice come `Threading.Thread.Sleep(1000)`, Visual Basic cercava lo spazio dei nomi "Threading", individuava un'ambiguità tra System.Threading e System.Windows.Threading e quindi segnalava un errore.</span><span class="sxs-lookup"><span data-stu-id="206b2-192">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="206b2-193">Visual Basic ora prende in considerazione entrambi gli spazi dei nomi possibili.</span><span class="sxs-lookup"><span data-stu-id="206b2-193">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="206b2-194">Se si visualizza l'elenco di completamento, l'editor di Visual Studio elenca i membri di entrambi i tipi in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="206b2-194">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="206b2-195">Valori letterali data con anno all'inizio</span><span class="sxs-lookup"><span data-stu-id="206b2-195">Year-first Date Literals</span></span>  
 <span data-ttu-id="206b2-196">I valori letterali data possono avere il formato aaaa-mm-gg, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="206b2-196">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="206b2-197">Proprietà dell'interfaccia readonly</span><span class="sxs-lookup"><span data-stu-id="206b2-197">Readonly Interface Properties</span></span>  
 <span data-ttu-id="206b2-198">È possibile implementare proprietà dell'interfaccia readonly usando una proprietà readonly.</span><span class="sxs-lookup"><span data-stu-id="206b2-198">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="206b2-199">L'interfaccia garantisce la funzionalità minima e le classi di implementazione non smettono di consentire l'impostazione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="206b2-199">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="206b2-200">TypeOf \<espressione> IsNot \<tipo></span><span class="sxs-lookup"><span data-stu-id="206b2-200">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="206b2-201">Per una maggiore leggibilità del codice, ora è possibile usare `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="206b2-201">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="206b2-202">#Disable Warning \<ID> e #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="206b2-202">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="206b2-203">È possibile disabilitare e abilitare avvisi specifici per le aree all'interno di un file di origine.</span><span class="sxs-lookup"><span data-stu-id="206b2-203">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="206b2-204">Miglioramenti dei commenti ai documenti XML</span><span class="sxs-lookup"><span data-stu-id="206b2-204">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="206b2-205">Quando si scrivono commenti ai documenti, si accede a Smart Editor e al supporto per la compilazione per la convalida di nomi di parametro, la corretta gestione di `crefs` (generics, operatori e così via), la colorazione e il refactoring.</span><span class="sxs-lookup"><span data-stu-id="206b2-205">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="206b2-206">Definizioni di interfacce e moduli parziali</span><span class="sxs-lookup"><span data-stu-id="206b2-206">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="206b2-207">Oltre a classi e struct, è possibile dichiarare interfacce e moduli parziali.</span><span class="sxs-lookup"><span data-stu-id="206b2-207">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="206b2-208">Direttive #Region in corpi di metodo</span><span class="sxs-lookup"><span data-stu-id="206b2-208">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="206b2-209">È possibile inserire delimitatori #Region...#End Region in qualsiasi punto di un file, nelle funzioni o nei corpi delle funzioni.</span><span class="sxs-lookup"><span data-stu-id="206b2-209">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="206b2-210">Le definizioni Overrides sono overload impliciti</span><span class="sxs-lookup"><span data-stu-id="206b2-210">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="206b2-211">Se si aggiunge il modificatore `Overrides` a una definizione, il compilatore aggiunge in modo implicito `Overloads`. In questo modo è possibile digitare meno codice nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="206b2-211">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="206b2-212">CObj consentito negli argomenti degli attributi</span><span class="sxs-lookup"><span data-stu-id="206b2-212">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="206b2-213">Il compilatore generava un errore indicante che CObj(...), se usato nelle costruzioni degli attributi, non era una costante.</span><span class="sxs-lookup"><span data-stu-id="206b2-213">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="206b2-214">Dichiarazione e utilizzo di metodi ambigui da interfacce diverse</span><span class="sxs-lookup"><span data-stu-id="206b2-214">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="206b2-215">In precedenza il codice seguente restituiva errori che impedivano di dichiarare `IMock` o di chiamare `GetDetails` (se questi erano stati dichiarati in c#):</span><span class="sxs-lookup"><span data-stu-id="206b2-215">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="206b2-216">Ora il compilatore userà le normali regole di risoluzione dell'overload per scegliere l'oggetto `GetDetails` più appropriato da chiamare ed è possibile dichiarare le relazioni tre le interfacce in Visual Basic, come quelle mostrate nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="206b2-216">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="206b2-217">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="206b2-217">See also</span></span>  
 [<span data-ttu-id="206b2-218">Novità di Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="206b2-218">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
