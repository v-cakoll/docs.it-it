---
title: Nozioni fondamentali sulla sicurezza per l’accesso al codice
description: "Informazioni sulle nozioni di base sulla sicurezza dall'accesso di codice per le app destinate a CLR: codice indipendente dai tipi, sintassi imperativa e dichiarativa, librerie di classi sicure e codice trasparente."
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 9d1f2e35c79ca32595711316885991717c4c1696
ms.sourcegitcommit: 97ce5363efa88179dd76e09de0103a500ca9b659
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/13/2020
ms.locfileid: "86281748"
---
# <a name="code-access-security-basics"></a><span data-ttu-id="c4869-103">Nozioni fondamentali sulla sicurezza per l’accesso al codice</span><span class="sxs-lookup"><span data-stu-id="c4869-103">Code Access Security Basics</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="c4869-104">È necessario che tutte le applicazioni basate su Common Language Runtime, ovvero tutte le applicazioni gestite, interagiscano con il relativo sistema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="c4869-104">Every application that targets the common language runtime (that is, every managed application) must interact with the runtime's security system.</span></span> <span data-ttu-id="c4869-105">Quando un'applicazione gestita viene caricata, il relativo host concede automaticamente un set di autorizzazioni a tale applicazione.</span><span class="sxs-lookup"><span data-stu-id="c4869-105">When a managed application is loaded, its host automatically grants it a set of permissions.</span></span> <span data-ttu-id="c4869-106">Queste autorizzazioni sono determinate dalle impostazioni di sicurezza locali dell'host o dalla sandbox che contiene l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="c4869-106">These permissions are determined by the host's local security settings or by the sandbox the application is in.</span></span> <span data-ttu-id="c4869-107">A seconda delle autorizzazioni, l'applicazione viene eseguita correttamente o genera un'eccezione di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="c4869-107">Depending on these permissions, the application either runs properly or generates a security exception.</span></span>

<span data-ttu-id="c4869-108">L'host predefinito per le applicazioni desktop consente l'esecuzione del codice in modalità di attendibilità totale.</span><span class="sxs-lookup"><span data-stu-id="c4869-108">The default host for desktop applications allows code to run in full trust.</span></span> <span data-ttu-id="c4869-109">Se pertanto l'applicazione è destinata al desktop, dispone di un set di autorizzazione senza restrizioni.</span><span class="sxs-lookup"><span data-stu-id="c4869-109">Therefore, if your application targets the desktop, it has an unrestricted permission set.</span></span> <span data-ttu-id="c4869-110">Altri host o sandbox forniscono un set di autorizzazioni limitato per le applicazioni.</span><span class="sxs-lookup"><span data-stu-id="c4869-110">Other hosts or sandboxes provide a limited permission set for applications.</span></span> <span data-ttu-id="c4869-111">Poiché il set di autorizzazioni può essere diverso da host a host, è necessario progettare l'applicazione in modo che usi solo le autorizzazioni consentite dall'host di destinazione.</span><span class="sxs-lookup"><span data-stu-id="c4869-111">Because the permission set can change from host to host, you must design your application to use only the permissions that your target host allows.</span></span>

<span data-ttu-id="c4869-112">È necessario avere familiarità con i concetti attinenti alla sicurezza dall'accesso di codice, illustrati di seguito, per poter scrivere applicazioni efficienti basate su Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="c4869-112">You must be familiar with the following code access security concepts in order to write effective applications that target the common language runtime:</span></span>

- <span data-ttu-id="c4869-113">**Codice indipendente**dai tipi: il codice indipendente dai tipi è codice che accede ai tipi solo in modalità ben definite e consentite.</span><span class="sxs-lookup"><span data-stu-id="c4869-113">**Type-safe code**: Type-safe code is code that accesses types only in well-defined, allowable ways.</span></span> <span data-ttu-id="c4869-114">Dato un riferimento a un oggetto valido, ad esempio, il codice indipendente dai tipi può accedere solo a offset fissi corrispondenti ai membri di campo effettivi.</span><span class="sxs-lookup"><span data-stu-id="c4869-114">For example, given a valid object reference, type-safe code can access memory at fixed offsets that correspond to actual field members.</span></span> <span data-ttu-id="c4869-115">Se tuttavia il codice accede alla memoria a offset arbitrari esterni all'intervallo di memoria appartenente ai campi dell'oggetto esposti in modo pubblico, non sarà indipendente dai tipi.</span><span class="sxs-lookup"><span data-stu-id="c4869-115">If the code accesses memory at arbitrary offsets outside the range of memory that belongs to that object's publicly exposed fields, it is not type-safe.</span></span> <span data-ttu-id="c4869-116">Per consentire al codice di usufruire dei vantaggi della sicurezza per l'accesso al codice, è necessario usare un compilatore che generi codice indipendente dai tipi verificabile.</span><span class="sxs-lookup"><span data-stu-id="c4869-116">To enable code to benefit from code access security, you must use a compiler that generates verifiably type-safe code.</span></span> <span data-ttu-id="c4869-117">Per ulteriori informazioni, vedere la sezione relativa alla [scrittura di codice indipendente dai tipi verificabile](#typesafe_code) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="c4869-117">For more information, see the [Writing Verifiably Type-Safe Code](#typesafe_code) section later in this topic.</span></span>

- <span data-ttu-id="c4869-118">**Sintassi dichiarativa e imperativa**: il codice destinato a Common Language Runtime può interagire con il sistema di sicurezza richiedendo le autorizzazioni, richiedendo che i chiamanti dispongano di autorizzazioni specifiche e sovrascrivendo alcune impostazioni di sicurezza (con privilegi sufficienti).</span><span class="sxs-lookup"><span data-stu-id="c4869-118">**Imperative and declarative syntax**: Code that targets the common language runtime can interact with the security system by requesting permissions, demanding that callers have specified permissions, and overriding certain security settings (given enough privileges).</span></span> <span data-ttu-id="c4869-119">Per interagire a livello di codice con il sistema di sicurezza di .NET Framework, è necessario usare due forme differenti di sintassi: la sintassi dichiarativa e la sintassi imperativa.</span><span class="sxs-lookup"><span data-stu-id="c4869-119">You use two forms of syntax to programmatically interact with the .NET Framework security system: declarative syntax and imperative syntax.</span></span> <span data-ttu-id="c4869-120">Le chiamate dichiarative sono eseguite mediante l'impiego di attributi, le chiamate imperative mediante l'uso di nuove istanze di classi all'interno del codice.</span><span class="sxs-lookup"><span data-stu-id="c4869-120">Declarative calls are performed using attributes; imperative calls are performed using new instances of classes within your code.</span></span> <span data-ttu-id="c4869-121">Alcune chiamate possono essere eseguite solo in modo imperativo, altre solo in modo dichiarativo e altre ancora in nessun modo.</span><span class="sxs-lookup"><span data-stu-id="c4869-121">Some calls can be performed only imperatively, others can be performed only declaratively, and some calls can be performed in either manner.</span></span>

- <span data-ttu-id="c4869-122">**Librerie di classi sicure**: una libreria di classi protetta usa le richieste di sicurezza per garantire che i chiamanti della libreria dispongano delle autorizzazioni per accedere alle risorse esposte dalla libreria.</span><span class="sxs-lookup"><span data-stu-id="c4869-122">**Secure class libraries**: A secure class library uses security demands to ensure that the library's callers have permission to access the resources that the library exposes.</span></span> <span data-ttu-id="c4869-123">Una libreria di classi protetta potrebbe ad esempio usare un metodo per la creazione di file mediante il quale si impone che i chiamanti dispongano di specifiche autorizzazioni per creare file.</span><span class="sxs-lookup"><span data-stu-id="c4869-123">For example, a secure class library might have a method for creating files that would demand that its callers have permissions to create files.</span></span> <span data-ttu-id="c4869-124">In .NET Framework sono disponibili librerie di classi protette.</span><span class="sxs-lookup"><span data-stu-id="c4869-124">The .NET Framework consists of secure class libraries.</span></span> <span data-ttu-id="c4869-125">È necessario conoscere esattamente le autorizzazioni necessarie per l'accesso a ognuna delle librerie usate dal codice.</span><span class="sxs-lookup"><span data-stu-id="c4869-125">You should be aware of the permissions required to access any library that your code uses.</span></span> <span data-ttu-id="c4869-126">Per ulteriori informazioni, vedere la sezione [utilizzo delle librerie di classi protette](#secure_library) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="c4869-126">For more information, see the [Using Secure Class Libraries](#secure_library) section later in this topic.</span></span>

- <span data-ttu-id="c4869-127">**Codice Transparent**: a partire dalla .NET Framework 4, oltre a identificare autorizzazioni specifiche, è necessario determinare se il codice deve essere eseguito come SecurityTransparent.</span><span class="sxs-lookup"><span data-stu-id="c4869-127">**Transparent code**: Starting with the .NET Framework 4, in addition to identifying specific permissions, you must also determine whether your code should run as security-transparent.</span></span> <span data-ttu-id="c4869-128">Il codice SecurityTransparent non può chiamare tipi o membri identificati come SecurityCritical.</span><span class="sxs-lookup"><span data-stu-id="c4869-128">Security-transparent code cannot call types or members that are identified as security-critical.</span></span> <span data-ttu-id="c4869-129">Questa regola si applica sia alle applicazioni completamente attendibili che a quelle parzialmente attendibili.</span><span class="sxs-lookup"><span data-stu-id="c4869-129">This rule applies to full-trust applications as well as partially trusted applications.</span></span> <span data-ttu-id="c4869-130">Per altre informazioni, vedere [codice SecurityTransparent](security-transparent-code.md).</span><span class="sxs-lookup"><span data-stu-id="c4869-130">For more information, see [Security-Transparent Code](security-transparent-code.md).</span></span>

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a><span data-ttu-id="c4869-131">Scrittura di codice indipendente dai tipi verificabile</span><span class="sxs-lookup"><span data-stu-id="c4869-131">Writing Verifiably Type-Safe Code</span></span>

<span data-ttu-id="c4869-132">Durante la compilazione JIT viene eseguito un processo di verifica, in base al quale il codice viene esaminato, per provare a determinare se è indipendente dai tipi.</span><span class="sxs-lookup"><span data-stu-id="c4869-132">Just-in-time (JIT) compilation performs a verification process that examines code and tries to determine whether the code is type-safe.</span></span> <span data-ttu-id="c4869-133">Il codice verificato durante la verifica come indipendente dai tipi viene definito *codice indipendente dai tipi verificabile*.</span><span class="sxs-lookup"><span data-stu-id="c4869-133">Code that is proven during verification to be type-safe is called *verifiably type-safe code*.</span></span> <span data-ttu-id="c4869-134">Esiste, infatti, codice che pur essendo indipendente dai tipi non è indipendente dai tipi verificabile, a causa delle limitazioni del processo di verifica o del compilatore.</span><span class="sxs-lookup"><span data-stu-id="c4869-134">Code can be type-safe, yet might not be verifiably type-safe because of the limitations of the verification process or of the compiler.</span></span> <span data-ttu-id="c4869-135">Non tutti i linguaggi sono indipendenti dai tipi e alcuni compilatori di linguaggio, quali Microsoft Visual C++, non sono in grado di generare codice gestito indipendente dai tipi verificabile.</span><span class="sxs-lookup"><span data-stu-id="c4869-135">Not all languages are type-safe, and some language compilers, such as Microsoft Visual C++, cannot generate verifiably type-safe managed code.</span></span> <span data-ttu-id="c4869-136">Per stabilire se il compilatore di linguaggio usato è in grado di generare codice indipendente dai tipi verificabile, consultare la documentazione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="c4869-136">To determine whether the language compiler you use generates verifiably type-safe code, consult the compiler's documentation.</span></span> <span data-ttu-id="c4869-137">Se si usa un compilatore di linguaggio che genera codice indipendente dai tipi verificabile solo quando si evitano determinati costrutti di linguaggio, potrebbe essere necessario usare lo [strumento PEVerify](../tools/peverify-exe-peverify-tool.md) per determinare se il codice è indipendente dai tipi verificabile.</span><span class="sxs-lookup"><span data-stu-id="c4869-137">If you use a language compiler that generates verifiably type-safe code only when you avoid certain language constructs, you might want to use the [PEVerify tool](../tools/peverify-exe-peverify-tool.md) to determine whether your code is verifiably type-safe.</span></span>

<span data-ttu-id="c4869-138">È tuttavia possibile tentare l'esecuzione di codice non indipendente dai tipi verificabile, se i criteri di sicurezza consentono al codice di evitare la verifica.</span><span class="sxs-lookup"><span data-stu-id="c4869-138">Code that is not verifiably type-safe can attempt to execute if security policy allows the code to bypass verification.</span></span> <span data-ttu-id="c4869-139">Poiché l'indipendenza dai tipi è tuttavia una componente essenziale del meccanismo di isolamento degli assembly nell'ambiente di esecuzione, non è possibile applicare la sicurezza in maniera affidabile se il codice viola le regole dell'indipendenza dai tipi.</span><span class="sxs-lookup"><span data-stu-id="c4869-139">However, because type safety is an essential part of the runtime's mechanism for isolating assemblies, security cannot be reliably enforced if code violates the rules of type safety.</span></span> <span data-ttu-id="c4869-140">In base all'impostazione predefinita, l'esecuzione del codice non indipendente dai tipi è consentita solo se il codice ha origine nel computer locale.</span><span class="sxs-lookup"><span data-stu-id="c4869-140">By default, code that is not type-safe is allowed to run only if it originates from the local computer.</span></span> <span data-ttu-id="c4869-141">È quindi necessario che il codice mobile sia indipendente dai tipi.</span><span class="sxs-lookup"><span data-stu-id="c4869-141">Therefore, mobile code should be type-safe.</span></span>

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a><span data-ttu-id="c4869-142">Uso di librerie di classi protette</span><span class="sxs-lookup"><span data-stu-id="c4869-142">Using Secure Class Libraries</span></span>

<span data-ttu-id="c4869-143">Se il codice richiede e ottiene le autorizzazioni richieste dalla libreria di classi, sarà autorizzato ad accedere alla libreria e le risorse esposte dalla libreria saranno protette dall'accesso non autorizzato.</span><span class="sxs-lookup"><span data-stu-id="c4869-143">If your code requests and is granted the permissions required by the class library, it will be allowed to access the library and the resources that the library exposes will be protected from unauthorized access.</span></span> <span data-ttu-id="c4869-144">Se il codice non dispone delle autorizzazioni appropriate, non sarà consentito l'accesso alla libreria di classi e il codice dannoso non potrà usare il codice dell'utente per accedere indirettamente alle risorse protette.</span><span class="sxs-lookup"><span data-stu-id="c4869-144">If your code does not have the appropriate permissions, it will not be allowed to access the class library, and malicious code will not be able to use your code to indirectly access protected resources.</span></span> <span data-ttu-id="c4869-145">Altro codice che chiama il codice deve essere autorizzato ad accedere alla raccolta.</span><span class="sxs-lookup"><span data-stu-id="c4869-145">Other code that calls your code must also have permission to access the library.</span></span> <span data-ttu-id="c4869-146">In caso contrario, sarà limitata anche l'esecuzione del codice.</span><span class="sxs-lookup"><span data-stu-id="c4869-146">If it does not, your code will be restricted from running as well.</span></span>

<span data-ttu-id="c4869-147">La sicurezza per l'accesso al codice non elimina la possibilità di errori umani nella scrittura del codice.</span><span class="sxs-lookup"><span data-stu-id="c4869-147">Code access security does not eliminate the possibility of human error in writing code.</span></span> <span data-ttu-id="c4869-148">Tuttavia, se l'applicazione usa le librerie di classi protette per accedere alle risorse protette, il rischio di problemi relativi alla sicurezza del codice applicazione risulta ridotto dall'accurato controllo cui sono sottoposte le librerie di classi.</span><span class="sxs-lookup"><span data-stu-id="c4869-148">However, if your application uses secure class libraries to access protected resources, the security risk for application code is decreased, because class libraries are closely scrutinized for potential security problems.</span></span>

## <a name="declarative-security"></a><span data-ttu-id="c4869-149">Sicurezza dichiarativa</span><span class="sxs-lookup"><span data-stu-id="c4869-149">Declarative Security</span></span>

<span data-ttu-id="c4869-150">La sintassi di sicurezza dichiarativa utilizza [gli attributi](../../standard/attributes/index.md) per inserire le informazioni di sicurezza nei [metadati](../../standard/metadata-and-self-describing-components.md) del codice.</span><span class="sxs-lookup"><span data-stu-id="c4869-150">Declarative security syntax uses [attributes](../../standard/attributes/index.md) to place security information into the [metadata](../../standard/metadata-and-self-describing-components.md) of your code.</span></span> <span data-ttu-id="c4869-151">Gli attributi possono essere inseriti a livello di assembly, classe o membro, per indicare il tipo di richiesta, la domanda o l'override che si vuole usare.</span><span class="sxs-lookup"><span data-stu-id="c4869-151">Attributes can be placed at the assembly, class, or member level, to indicate the type of request, demand, or override you want to use.</span></span> <span data-ttu-id="c4869-152">Le richieste vengono usate in applicazioni destinate a Common Language Runtime per informare il sistema di sicurezza runtime sulle autorizzazioni necessarie o non necessarie per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="c4869-152">Requests are used in applications that target the common language runtime to inform the runtime security system about the permissions that your application needs or does not want.</span></span> <span data-ttu-id="c4869-153">Le richieste e gli override vengono usati nelle librerie per proteggere le risorse dai chiamanti o per eseguire l'override del comportamento di sicurezza predefinito.</span><span class="sxs-lookup"><span data-stu-id="c4869-153">Demands and overrides are used in libraries to help protect resources from callers or to override default security behavior.</span></span>

> [!NOTE]
> <span data-ttu-id="c4869-154">Nel .NET Framework 4 sono state apportate importanti modifiche al modello di sicurezza e alla terminologia di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c4869-154">In the .NET Framework 4, there have been important changes to the .NET Framework security model and terminology.</span></span> <span data-ttu-id="c4869-155">Per ulteriori informazioni su queste modifiche, vedere [modifiche di sicurezza](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).</span><span class="sxs-lookup"><span data-stu-id="c4869-155">For more information about these changes, see [Security Changes](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).</span></span>

<span data-ttu-id="c4869-156">Per usare le chiamate di sicurezza dichiarativa, è necessario inizializzare i dati dello stato dell'oggetto di autorizzazione in modo che rappresenti la forma specifica di autorizzazione necessaria.</span><span class="sxs-lookup"><span data-stu-id="c4869-156">In order to use declarative security calls, you must initialize the state data of the permission object so that it represents the particular form of permission you need.</span></span> <span data-ttu-id="c4869-157">Ciascuna autorizzazione incorporata dispone di un attributo a cui viene passata un'enumerazione <xref:System.Security.Permissions.SecurityAction> per descrivere il tipo di operazione di protezione che si vuole eseguire.</span><span class="sxs-lookup"><span data-stu-id="c4869-157">Every built-in permission has an attribute that is passed a <xref:System.Security.Permissions.SecurityAction> enumeration to describe the type of security operation you want to perform.</span></span> <span data-ttu-id="c4869-158">Tuttavia, le autorizzazioni accettano anche i propri parametri esclusivi.</span><span class="sxs-lookup"><span data-stu-id="c4869-158">However, permissions also accept their own parameters that are exclusive to them.</span></span>

<span data-ttu-id="c4869-159">Nel frammento di codice riportato di seguito viene illustrata la sintassi dichiarativa per richiedere che i chiamanti del codice dispongano di un'autorizzazione personalizzata denominata `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="c4869-159">The following code fragment shows declarative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="c4869-160">Questa autorizzazione è un'autorizzazione personalizzata ipotetica e non esiste in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c4869-160">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="c4869-161">In questo esempio viene effettuata la chiamata dichiarativa direttamente prima della definizione di classe, specificando che è necessario applicare l'autorizzazione a livello di classe.</span><span class="sxs-lookup"><span data-stu-id="c4869-161">In this example, the declarative call is placed directly before the class definition, specifying that this permission be applied to the class level.</span></span> <span data-ttu-id="c4869-162">All'attributo viene passata una struttura **SecurityAction. Demand** per specificare che i chiamanti devono disporre di questa autorizzazione per poter essere eseguiti.</span><span class="sxs-lookup"><span data-stu-id="c4869-162">The attribute is passed a **SecurityAction.Demand** structure to specify that callers must have this permission in order to run.</span></span>

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a><span data-ttu-id="c4869-163">Sicurezza imperativa</span><span class="sxs-lookup"><span data-stu-id="c4869-163">Imperative Security</span></span>

<span data-ttu-id="c4869-164">La sintassi di sicurezza imperativa invia una chiamata di sicurezza mediante la creazione di una nuova istanza dell'oggetto autorizzazione che si vuole richiamare.</span><span class="sxs-lookup"><span data-stu-id="c4869-164">Imperative security syntax issues a security call by creating a new instance of the permission object you want to invoke.</span></span> <span data-ttu-id="c4869-165">È possibile usare la sintassi imperativa per eseguire domande e override, ma non richieste.</span><span class="sxs-lookup"><span data-stu-id="c4869-165">You can use imperative syntax to perform demands and overrides, but not requests.</span></span>

<span data-ttu-id="c4869-166">Prima di eseguire la chiamata di sicurezza, è necessario inizializzare i dati dello stato dell'oggetto di autorizzazione in modo che rappresenti la forma specifica di autorizzazione necessaria.</span><span class="sxs-lookup"><span data-stu-id="c4869-166">Before you make the security call, you must initialize the state data of the permission object so that it represents the particular form of the permission you need.</span></span> <span data-ttu-id="c4869-167">Ad esempio, quando si crea un <xref:System.Security.Permissions.FileIOPermission> oggetto, è possibile usare il costruttore per inizializzare l'oggetto **FileIOPermission** in modo che rappresenti l'accesso illimitato a tutti i file o nessun accesso ai file.</span><span class="sxs-lookup"><span data-stu-id="c4869-167">For example, when creating a <xref:System.Security.Permissions.FileIOPermission> object, you can use the constructor to initialize the **FileIOPermission** object so that it represents either unrestricted access to all files or no access to files.</span></span> <span data-ttu-id="c4869-168">In alternativa, è possibile utilizzare un oggetto **FileIOPermission** diverso, passando i parametri che indicano il tipo di accesso che si desidera venga rappresentato dall'oggetto (ovvero lettura, Accodamento o scrittura) e i file che si desidera proteggere dall'oggetto.</span><span class="sxs-lookup"><span data-stu-id="c4869-168">Or, you can use a different **FileIOPermission** object, passing parameters that indicate the type of access you want the object to represent (that is, read, append, or write) and what files you want the object to protect.</span></span>

<span data-ttu-id="c4869-169">Oltre a usare la sintassi di sicurezza imperativa per richiamare un singolo oggetto di sicurezza, è possibile usarla per inizializzare un gruppo di autorizzazioni in un set di autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="c4869-169">In addition to using imperative security syntax to invoke a single security object, you can use it to initialize a group of permissions in a permission set.</span></span> <span data-ttu-id="c4869-170">Questa tecnica è ad esempio l'unico modo per eseguire in modo affidabile chiamate [Assert](using-the-assert-method.md) su più autorizzazioni in un unico metodo.</span><span class="sxs-lookup"><span data-stu-id="c4869-170">For example, this technique is the only way to reliably perform [assert](using-the-assert-method.md) calls on multiple permissions in one method.</span></span> <span data-ttu-id="c4869-171">Usare le classi <xref:System.Security.PermissionSet> e <xref:System.Security.NamedPermissionSet> per creare un gruppo di autorizzazioni e quindi chiamare il metodo appropriato per richiamare la chiamata di sicurezza desiderato.</span><span class="sxs-lookup"><span data-stu-id="c4869-171">Use the <xref:System.Security.PermissionSet> and <xref:System.Security.NamedPermissionSet> classes to create a group of permissions and then call the appropriate method to invoke the desired security call.</span></span>

<span data-ttu-id="c4869-172">È possibile usare la sintassi imperativa per eseguire domande e override, ma non richieste.</span><span class="sxs-lookup"><span data-stu-id="c4869-172">You can use imperative syntax to perform demands and overrides, but not requests.</span></span> <span data-ttu-id="c4869-173">Potrebbe usare la sintassi imperativa per richieste e override anziché la sintassi dichiarativa quando le informazioni necessarie per inizializzare lo stato di autorizzazione diventano note solo in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="c4869-173">You might use imperative syntax for demands and overrides instead of declarative syntax when information that you need in order to initialize the permission state becomes known only at run time.</span></span> <span data-ttu-id="c4869-174">Ad esempio, se si vuole garantire che i chiamanti abbiano l'autorizzazione di lettura di un determinato file, ma non si conosce il nome del file fino al runtime, usare una richiesta imperativa.</span><span class="sxs-lookup"><span data-stu-id="c4869-174">For example, if you want to ensure that callers have permission to read a certain file, but you do not know the name of that file until run time, use an imperative demand.</span></span> <span data-ttu-id="c4869-175">È anche possibile usare controlli imperativi invece di controlli dichiarativi quando è necessario determinare in fase di esecuzione se contiene una condizione e, in base al risultato del test, eseguire o no una richiesta di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="c4869-175">You might also choose to use imperative checks instead of declarative checks when you need to determine at run time whether a condition holds and, based on the result of the test, make a security demand (or not).</span></span>

<span data-ttu-id="c4869-176">Nel frammento di codice riportato di seguito viene illustrata la sintassi imperativa per richiedere che i chiamanti del codice abbiano un'autorizzazione personalizzata denominata `MyPermission`.</span><span class="sxs-lookup"><span data-stu-id="c4869-176">The following code fragment shows imperative syntax for requesting that your code's callers have a custom permission called `MyPermission`.</span></span> <span data-ttu-id="c4869-177">Questa autorizzazione è un'autorizzazione personalizzata ipotetica e non esiste in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c4869-177">This permission is a hypothetical custom permission and does not exist in the .NET Framework.</span></span> <span data-ttu-id="c4869-178">Una nuova istanza di `MyPermission` viene creata in `MyMethod` e protegge solo questo metodo con la chiamata di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="c4869-178">A new instance of `MyPermission` is created in `MyMethod`, guarding only this method with the security call.</span></span>

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a><span data-ttu-id="c4869-179">Utilizzo di classi wrapper gestite</span><span class="sxs-lookup"><span data-stu-id="c4869-179">Using Managed Wrapper Classes</span></span>

<span data-ttu-id="c4869-180">È necessario che la maggior parte delle applicazione e dei componenti, fatta eccezione per le librerie protette, non chiami direttamente codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="c4869-180">Most applications and components (except secure libraries) should not directly call unmanaged code.</span></span> <span data-ttu-id="c4869-181">Le ragioni sono molteplici.</span><span class="sxs-lookup"><span data-stu-id="c4869-181">There are several reasons for this.</span></span> <span data-ttu-id="c4869-182">Se il codice chiama direttamente codice non gestito, in molti casi non ne sarà autorizzata l'esecuzione, poiché per chiamare codice nativo è necessario che il codice disponga di un livello di attendibilità elevato.</span><span class="sxs-lookup"><span data-stu-id="c4869-182">If code calls unmanaged code directly, it will not be allowed to run in many circumstances because code must be granted a high level of trust to call native code.</span></span> <span data-ttu-id="c4869-183">Se i criteri vengono modificati in modo da consentire l'esecuzione di tale applicazione, potrebbe risultarne seriamente indebolita la protezione del sistema e l'applicazione sarebbe libera di eseguire quasi ogni tipo di operazione.</span><span class="sxs-lookup"><span data-stu-id="c4869-183">If policy is modified to allow such an application to run, it can significantly weaken the security of the system, leaving the application free to perform almost any operation.</span></span>

<span data-ttu-id="c4869-184">È inoltre probabile che il codice che dispone dell'autorizzazione per l'accesso a codice sia in grado di effettuare qualsiasi operazione chiamando un'API non gestita.</span><span class="sxs-lookup"><span data-stu-id="c4869-184">Additionally, code that has permission to access unmanaged code can probably perform almost any operation by calling into an unmanaged API.</span></span> <span data-ttu-id="c4869-185">Ad esempio, il codice che dispone dell'autorizzazione per chiamare codice non gestito non deve <xref:System.Security.Permissions.FileIOPermission> accedere a un file, ma può semplicemente chiamare direttamente un'API file non gestita (Win32), ignorando l'API del file gestito che richiede **FileIOPermission**.</span><span class="sxs-lookup"><span data-stu-id="c4869-185">For example, code that has permission to call unmanaged code does not need <xref:System.Security.Permissions.FileIOPermission> to access a file; it can just call an unmanaged (Win32) file API directly, bypassing the managed file API that requires **FileIOPermission**.</span></span> <span data-ttu-id="c4869-186">Se il codice gestito è autorizzato a chiamare codice non gestito e lo chiama direttamente, il sistema di protezione non sarà in grado di imporre in maniera affidabile restrizioni di protezione, dal momento che non è possibile imporre tali restrizioni su codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="c4869-186">If managed code has permission to call into unmanaged code and does call directly into unmanaged code, the security system will be unable to reliably enforce security restrictions, since the runtime cannot enforce such restrictions on unmanaged code.</span></span>

<span data-ttu-id="c4869-187">Se si vuole che l'applicazione esegua un'operazione che richiede l'accesso a codice non gestito, sarà necessario usare, se disponibile, una classe gestita attendibile che esegua il wrapping della funzionalità richiesta.</span><span class="sxs-lookup"><span data-stu-id="c4869-187">If you want your application to perform an operation that requires accessing unmanaged code, it should do so through a trusted managed class that wraps the required functionality (if such a class exists).</span></span> <span data-ttu-id="c4869-188">Non creare autonomamente una classe wrapper se ne esiste già una in una libreria di classi protetta.</span><span class="sxs-lookup"><span data-stu-id="c4869-188">Do not create a wrapper class yourself if one already exists in a secure class library.</span></span> <span data-ttu-id="c4869-189">La classe wrapper, a cui è necessario concedere un elevato livello di attendibilità perché le sia consentito chiamare codice non gestito, impone ai chiamanti il possesso delle opportune autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="c4869-189">The wrapper class, which must be granted a high degree of trust to be allowed to make the call into unmanaged code, is responsible for demanding that its callers have the appropriate permissions.</span></span> <span data-ttu-id="c4869-190">Se si usa una classe wrapper, è necessario che il codice richieda e ottenga esclusivamente le autorizzazioni da essa pretese.</span><span class="sxs-lookup"><span data-stu-id="c4869-190">If you use the wrapper class, your code only needs to request and be granted the permissions that the wrapper class demands.</span></span>

## <a name="see-also"></a><span data-ttu-id="c4869-191">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="c4869-191">See also</span></span>

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [<span data-ttu-id="c4869-192">Assert</span><span class="sxs-lookup"><span data-stu-id="c4869-192">Assert</span></span>](using-the-assert-method.md)
- [<span data-ttu-id="c4869-193">Sicurezza dall'accesso di codice</span><span class="sxs-lookup"><span data-stu-id="c4869-193">Code Access Security</span></span>](code-access-security.md)
- [<span data-ttu-id="c4869-194">Nozioni fondamentali sulla sicurezza per l’accesso al codice</span><span class="sxs-lookup"><span data-stu-id="c4869-194">Code Access Security Basics</span></span>](code-access-security-basics.md)
- [<span data-ttu-id="c4869-195">Attributes (Attributi)</span><span class="sxs-lookup"><span data-stu-id="c4869-195">Attributes</span></span>](../../standard/attributes/index.md)
- [<span data-ttu-id="c4869-196">Metadati e componenti auto-descrittivi</span><span class="sxs-lookup"><span data-stu-id="c4869-196">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
