---
title: Scelta di un modello di scambio dei messaggi
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: ac5ff841eb4e314c1c9d04c895d7a22766da003e
ms.sourcegitcommit: 15109844229ade1c6449f48f3834db1b26907824
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/07/2018
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="a10a7-102">Scelta di un modello di scambio dei messaggi</span><span class="sxs-lookup"><span data-stu-id="a10a7-102">Choosing a Message Exchange Pattern</span></span>
<span data-ttu-id="a10a7-103">Il primo passaggio nella scrittura di un trasporto personalizzato è necessario stabilire quali *modelli di scambio dei messaggi* (o MEP) sono necessari per il canale a cui si sta sviluppando.</span><span class="sxs-lookup"><span data-stu-id="a10a7-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="a10a7-104">In questo argomento vengono descritte le opzioni disponibili e vengono illustrati i vari requisiti.</span><span class="sxs-lookup"><span data-stu-id="a10a7-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="a10a7-105">Questa è la prima attività nell'elenco di attività di sviluppo channel descritto in [sviluppo canali](../../../../docs/framework/wcf/extending/developing-channels.md).</span><span class="sxs-lookup"><span data-stu-id="a10a7-105">This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="a10a7-106">Sei modelli di scambio dei messaggi</span><span class="sxs-lookup"><span data-stu-id="a10a7-106">Six Message Exchange Patterns</span></span>  
 <span data-ttu-id="a10a7-107">Sono disponibili tre modelli di scambio dei messaggi:</span><span class="sxs-lookup"><span data-stu-id="a10a7-107">There are three MEPs to choose from:</span></span>  
  
-   <span data-ttu-id="a10a7-108">Datagramma (<xref:System.ServiceModel.Channels.IInputChannel> e <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="a10a7-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="a10a7-109">Quando si utilizza un modello di scambio di datagramma, un client invia un messaggio utilizzando un *generato automaticamente* exchange.</span><span class="sxs-lookup"><span data-stu-id="a10a7-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="a10a7-110">Tale scambio richiede una conferma fuori banda di recapito con esito positivo.</span><span class="sxs-lookup"><span data-stu-id="a10a7-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="a10a7-111">Il messaggio potrebbe infatti andare perso durante il transito e non raggiungere mai il servizio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="a10a7-112">Se l'operazione di invio viene completata correttamente sul lato client, non c'è garanzia che l'endpoint remoto abbia ricevuto il messaggio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="a10a7-113">Il datagramma è un componente fondamentale per i messaggi, poiché sulla sua base è possibile compilare protocolli propri, tra cui protocolli affidabili e protocolli sicuri.</span><span class="sxs-lookup"><span data-stu-id="a10a7-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="a10a7-114">I canali del datagramma del client implementano l'interfaccia <xref:System.ServiceModel.Channels.IOutputChannel>, mentre i canali del datagramma del servizio implementano l'interfaccia <xref:System.ServiceModel.Channels.IInputChannel>.</span><span class="sxs-lookup"><span data-stu-id="a10a7-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
-   <span data-ttu-id="a10a7-115">Richiesta-risposta (<xref:System.ServiceModel.Channels.IRequestChannel> e <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="a10a7-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="a10a7-116">In questo modello di scambio, viene inviato un messaggio e viene ricevuta una risposta.</span><span class="sxs-lookup"><span data-stu-id="a10a7-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="a10a7-117">Il modello è costituito da coppie richiesta-risposta.</span><span class="sxs-lookup"><span data-stu-id="a10a7-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="a10a7-118">Esempi di chiamate richiesta-risposta sono le chiamate RPC (Remote Procedure Call) e le richieste GET del browser.</span><span class="sxs-lookup"><span data-stu-id="a10a7-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="a10a7-119">Questo modello è anche noto come half-duplex.</span><span class="sxs-lookup"><span data-stu-id="a10a7-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="a10a7-120">In tale modello, i canali client implementano l'interfaccia <xref:System.ServiceModel.Channels.IRequestChannel>, mentre i canali del servizio implementano l'interfaccia <xref:System.ServiceModel.Channels.IReplyChannel>.</span><span class="sxs-lookup"><span data-stu-id="a10a7-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
-   <span data-ttu-id="a10a7-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="a10a7-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="a10a7-122">Il modello di scambio duplex consente l'invio di un numero arbitrario di messaggi da parte di un client e la ricezione in qualsiasi ordine.</span><span class="sxs-lookup"><span data-stu-id="a10a7-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="a10a7-123">Tale modello è simile a una conversazione telefonica, in cui ogni parola pronunciata è un messaggio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="a10a7-124">Poiché in questo modello i due lati possono entrambi inviare e ricevere messaggi, l'interfaccia implementata dai canali client e del servizio è <xref:System.ServiceModel.Channels.IDuplexChannel>.</span><span class="sxs-lookup"><span data-stu-id="a10a7-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="a10a7-125">![Scelta di un modello di scambio di messaggi](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="a10a7-125">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="a10a7-126">I tre modelli di scambio dei messaggi di base.</span><span class="sxs-lookup"><span data-stu-id="a10a7-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="a10a7-127">Dall'alto verso il basso: datagramma, richiesta-risposta e duplex.</span><span class="sxs-lookup"><span data-stu-id="a10a7-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="a10a7-128">Ognuno di questi modelli può inoltre supportare *sessioni*.</span><span class="sxs-lookup"><span data-stu-id="a10a7-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="a10a7-129">Una sessione (e un'implementazione di <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> di tipo <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) mette in correlazione tutti i messaggi inviati e ricevuti su un canale.</span><span class="sxs-lookup"><span data-stu-id="a10a7-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="a10a7-130">Il modello richiesta-risposta è una sessione autonoma a due messaggi, poiché la richiesta e la risposta sono correlate.</span><span class="sxs-lookup"><span data-stu-id="a10a7-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="a10a7-131">Il modello richiesta-risposta che supporta sessioni implica invece che tutte le coppie richiesta/risposta sul canale siano correlate le une con le altre.</span><span class="sxs-lookup"><span data-stu-id="a10a7-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="a10a7-132">È quindi possibile scegliere fra un totale di sei modelli di scambio dei messaggi:</span><span class="sxs-lookup"><span data-stu-id="a10a7-132">This gives you a total of six MEPs to choose from:</span></span>  
  
-   <span data-ttu-id="a10a7-133">Datagram</span><span class="sxs-lookup"><span data-stu-id="a10a7-133">Datagram</span></span>  
  
-   <span data-ttu-id="a10a7-134">Richiesta-risposta</span><span class="sxs-lookup"><span data-stu-id="a10a7-134">Request-response</span></span>  
  
-   <span data-ttu-id="a10a7-135">Duplex</span><span class="sxs-lookup"><span data-stu-id="a10a7-135">Duplex</span></span>  
  
-   <span data-ttu-id="a10a7-136">Datagramma con sessioni</span><span class="sxs-lookup"><span data-stu-id="a10a7-136">Datagram with sessions</span></span>  
  
-   <span data-ttu-id="a10a7-137">Richiesta-risposta con sessioni</span><span class="sxs-lookup"><span data-stu-id="a10a7-137">Request-response with sessions</span></span>  
  
-   <span data-ttu-id="a10a7-138">Duplex con sessioni</span><span class="sxs-lookup"><span data-stu-id="a10a7-138">Duplex with sessions</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a10a7-139">Per il trasporto UDP, l'unico modello di scambio dei messaggi supportato è il datagramma, poiché il protocollo UPD è di tipo fire and forget.</span><span class="sxs-lookup"><span data-stu-id="a10a7-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="a10a7-140">Sessioni e canali con sessione</span><span class="sxs-lookup"><span data-stu-id="a10a7-140">Sessions and Sessionful Channels</span></span>  
 <span data-ttu-id="a10a7-141">Nel campo delle reti, esistono protocolli orientati alla connessione, ad esempio il protocollo TCP, e protocolli senza connessione, ad esempio il protocollo UPD.</span><span class="sxs-lookup"><span data-stu-id="a10a7-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="a10a7-142">WCF utilizza il termine sessione per indicare un'astrazione logica simile a quello di connessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="a10a7-143">I protocolli WCF con sessione sono simili ai protocolli di rete orientati alla connessione, mentre i protocolli WCF senza sessione sono simili ai protocolli di rete senza connessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="a10a7-144">Nel modello a oggetti dei canali, ogni sessione logica si manifesta come un'istanza di un canale con sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="a10a7-145">Ogni nuova sessione creata dal client e accettata nel servizio corrisponde pertanto a un nuovo canale con sessione su ciascun lato.</span><span class="sxs-lookup"><span data-stu-id="a10a7-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="a10a7-146">Nel diagramma seguente viene illustrata, nella parte superiore, la struttura dei canali senza sessione e, nella parte inferiore, la struttura dei canali con sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="a10a7-147">![Scelta di un modello di scambio di messaggi](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="a10a7-147">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="a10a7-148">Un client crea un nuovo canale con sessione e invia un messaggio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="a10a7-149">Sul lato del servizio, il listener del canale riceve il messaggio e ne rileva l'appartenenza a una nuova sessione, crea quindi un nuovo canale con sessione e lo passa all'applicazione (in risposta alla chiamata dell'applicazione AcceptChannel sul listener del canale).</span><span class="sxs-lookup"><span data-stu-id="a10a7-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="a10a7-150">L'applicazione riceve quindi il messaggio e tutti i messaggi successivi inviati nella stessa sessione attraverso lo stesso canale con sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="a10a7-151">Un altro (o lo stesso) client crea un nuovo canale con sessione e invia un messaggio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="a10a7-152">Il listener del canale rileva che il messaggio è in una nuova sessione e crea un nuovo canale con sessione e il processo si ripete.</span><span class="sxs-lookup"><span data-stu-id="a10a7-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="a10a7-153">Senza sessioni, non esiste alcuna correlazione tra i canali e le sessioni.</span><span class="sxs-lookup"><span data-stu-id="a10a7-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="a10a7-154">Un listener del canale crea pertanto un solo canale tramite il quale tutti i messaggi ricevuti vengono recapitati all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="a10a7-155">Non esiste inoltre alcun ordinamento dei messaggi, poiché non esiste alcuna sessione al cui interno mantenere l'ordine dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="a10a7-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="a10a7-156">Nella parte superiore dell'immagine precedente viene illustrato uno scambio di messaggi senza sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="a10a7-157">Avvio e terminazione di sessioni</span><span class="sxs-lookup"><span data-stu-id="a10a7-157">Starting and Terminating Sessions</span></span>  
 <span data-ttu-id="a10a7-158">Le sessioni vengono avviate sul client mediante la creazione di un nuovo canale con sessione</span><span class="sxs-lookup"><span data-stu-id="a10a7-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="a10a7-159">e vengono avviate sul servizio quando il servizio riceve un messaggio inviato in una nuova sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="a10a7-160">Analogamente, le sessioni vengono terminate mediante la chiusura o l'interruzione di un canale con sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="a10a7-161">L'eccezione è rappresentata dall'interfaccia <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, che viene utilizzata per l'invio e la ricezione di messaggi in un modello di comunicazione duplex con sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="a10a7-162">È possibile che un lato desideri arrestare l'invio di messaggi ma continuarne la ricezione; a questo scopo, quando si utilizza l'interfaccia <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, è presente un meccanismo che consente di chiudere la sessione di output, indicando quindi che non verranno più inviati messaggi, ma di mantenere aperta la sessione di input in modo da continuare a ricevere messaggi.</span><span class="sxs-lookup"><span data-stu-id="a10a7-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="a10a7-163">In generale, le sessioni vengono chiuse sul lato di uscita e non sul lato di ingresso.</span><span class="sxs-lookup"><span data-stu-id="a10a7-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="a10a7-164">In altri termini, è possibile chiudere i canali di output con sessione, in questo modo terminando correttamente la sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="a10a7-165">Con la chiusura di un canale di output con sessione, il canale di input con sessione corrispondente restituirà un valore null all'applicazione che chiama <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> su <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span><span class="sxs-lookup"><span data-stu-id="a10a7-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="a10a7-166">Non è tuttavia consigliabile chiudere i canali di input con sessione a meno che <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> su <xref:System.ServiceModel.Channels.IDuplexSessionChannel> non restituisca un valore null per indicare che la sessione è già chiusa.</span><span class="sxs-lookup"><span data-stu-id="a10a7-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="a10a7-167">Se <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> su <xref:System.ServiceModel.Channels.IDuplexSessionChannel> non ha restituito un valore null, con la chiusura di un canale di input con sessione è possibile che venga generata un'eccezione a causa della ricezione di messaggi imprevisti durante la chiusura.</span><span class="sxs-lookup"><span data-stu-id="a10a7-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="a10a7-168">Se un destinatario desidera terminare una sessione prima che lo faccia il mittente, è necessario chiamare <xref:System.ServiceModel.ICommunicationObject.Abort%2A> sul canale di input, terminando così immediatamente la sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="a10a7-169">Scrittura di canali con sessione</span><span class="sxs-lookup"><span data-stu-id="a10a7-169">Writing Sessionful Channels</span></span>  
 <span data-ttu-id="a10a7-170">Quando si crea un canale con sessione, è necessario che il canale esegua alcune operazioni per fornire le sessioni.</span><span class="sxs-lookup"><span data-stu-id="a10a7-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="a10a7-171">Sul lato di invio, il canale deve:</span><span class="sxs-lookup"><span data-stu-id="a10a7-171">On the send side, your channel needs to:</span></span>  
  
-   <span data-ttu-id="a10a7-172">Per ogni nuovo canale, creare una nuova sessione e associarlo all'ID della nuova sessione rappresentato da una stringa univoca</span><span class="sxs-lookup"><span data-stu-id="a10a7-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="a10a7-173">oppure ottenere una nuova sessione dal canale con sessione sottostante nello stack.</span><span class="sxs-lookup"><span data-stu-id="a10a7-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
-   <span data-ttu-id="a10a7-174">Per ogni messaggio inviato utilizzando il canale, se il canale ha creato la sessione (anziché ottenerla dal livello sottostante), è necessario associare il messaggio alla sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="a10a7-175">Per i canali di protocollo, questa operazione viene in genere eseguita aggiungendo un'intestazione SOAP.</span><span class="sxs-lookup"><span data-stu-id="a10a7-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="a10a7-176">Per i canali di trasporto, viene in genere eseguita creando una nuova connessione di trasporto o aggiungendo informazioni sulla sessione al protocollo di frame.</span><span class="sxs-lookup"><span data-stu-id="a10a7-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
-   <span data-ttu-id="a10a7-177">Per ogni messaggio inviato utilizzando il canale, è necessario fornire le garanzie di recapito sopra indicate.</span><span class="sxs-lookup"><span data-stu-id="a10a7-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="a10a7-178">Se ci si basa sul canale sottostante per fornire la sessione, tale canale fornirà anche le garanzie di recapito.</span><span class="sxs-lookup"><span data-stu-id="a10a7-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="a10a7-179">Se si sta creando la sessione, è necessario implementare tali garanzie all'interno del protocollo.</span><span class="sxs-lookup"><span data-stu-id="a10a7-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="a10a7-180">In generale, se si scrive un canale di protocollo che presuppone WCF su entrambi i lati, potrebbe essere necessario il canale di trasporto TCP o di messaggistica affidabile e basarsi su uno di essi per fornire una sessione.</span><span class="sxs-lookup"><span data-stu-id="a10a7-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
-   <span data-ttu-id="a10a7-181">Quando sul canale viene chiamato il metodo<xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType>, eseguire le operazioni necessarie per chiudere la sessione utilizzando il timeout specificato o quello predefinito.</span><span class="sxs-lookup"><span data-stu-id="a10a7-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="a10a7-182">A tale scopo è sufficiente chiamare il metodo <xref:System.ServiceModel.ICommunicationObject.Close%2A> sul canale sottostante (se la sessione è stata ottenuta da tale canale), inviare un messaggio SOAP speciale o chiudere una connessione di trasporto.</span><span class="sxs-lookup"><span data-stu-id="a10a7-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
-   <span data-ttu-id="a10a7-183">Quando sul canale viene chiamato il metodo <xref:System.ServiceModel.ICommunicationObject.Abort%2A>, terminare immediatamente la sessione senza eseguire l'I/O.</span><span class="sxs-lookup"><span data-stu-id="a10a7-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="a10a7-184">Questa operazione può non comportare nulla o implicare l'interruzione di una connessione di rete o di un'altra risorsa.</span><span class="sxs-lookup"><span data-stu-id="a10a7-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="a10a7-185">Sul lato di ricezione, il canale deve:</span><span class="sxs-lookup"><span data-stu-id="a10a7-185">On the receive side, your channel needs to:</span></span>  
  
-   <span data-ttu-id="a10a7-186">Per ogni messaggio in ingresso, il listener del canale deve rilevare a quale sessione appartiene.</span><span class="sxs-lookup"><span data-stu-id="a10a7-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="a10a7-187">Se si tratta del primo messaggio della sessione, il listener del canale deve creare un nuovo canale e restituirlo dalla chiamata al metodo <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a10a7-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a10a7-188">In caso contrario, il listener del canale deve cercare il canale esistente che corrisponde alla sessione e recapitare il messaggio tramite tale canale.</span><span class="sxs-lookup"><span data-stu-id="a10a7-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
-   <span data-ttu-id="a10a7-189">Se il canale sta creando la sessione (unitamente alle garanzie di recapito necessarie), potrebbe essere necessario che il lato ricevente esegua alcune azioni, ad esempio il riordinamento dei messaggi o l'invio di conferme.</span><span class="sxs-lookup"><span data-stu-id="a10a7-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
-   <span data-ttu-id="a10a7-190">Quando sul canale viene chiamato il metodo <xref:System.ServiceModel.ICommunicationObject.Close%2A>, eseguire le operazioni necessarie per chiudere la sessione utilizzando il timeout specificato o quello predefinito.</span><span class="sxs-lookup"><span data-stu-id="a10a7-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="a10a7-191">Se il canale riceve un messaggio mentre è in attesa della scadenza del timeout di chiusura, è possibile che vengano generate delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="a10a7-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="a10a7-192">Questo perché il canale sarà nello stato di chiusura in corso al momento della ricezione di un messaggio.</span><span class="sxs-lookup"><span data-stu-id="a10a7-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
-   <span data-ttu-id="a10a7-193">Quando sul canale viene chiamato il metodo <xref:System.ServiceModel.ICommunicationObject.Abort%2A>, terminare immediatamente la sessione senza eseguire l'I/O.</span><span class="sxs-lookup"><span data-stu-id="a10a7-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="a10a7-194">Anche in questo caso, tale operazione può non comportare nulla o implicare l'interruzione di una connessione di rete o di un'altra risorsa.</span><span class="sxs-lookup"><span data-stu-id="a10a7-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a10a7-195">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a10a7-195">See Also</span></span>  
 [<span data-ttu-id="a10a7-196">Panoramica sul modello dei canali</span><span class="sxs-lookup"><span data-stu-id="a10a7-196">Channel Model Overview</span></span>](../../../../docs/framework/wcf/extending/channel-model-overview.md)
