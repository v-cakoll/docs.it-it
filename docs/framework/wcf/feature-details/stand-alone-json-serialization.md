---
title: Serializzazione JSON autonoma mediante DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 39d3c0acd75ffd9a54c5e62a15487a2cd8c465cb
ms.sourcegitcommit: dfad244ba549702b649bfef3bb057e33f24a8fb2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/12/2020
ms.locfileid: "75904609"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="073a8-102">Serializzazione JSON autonoma mediante DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="073a8-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="073a8-103">Questo articolo riguarda <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="073a8-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="073a8-104">Per la maggior parte degli scenari che coinvolgono la serializzazione e la deserializzazione di JSON, è consigliabile usare le API nello [spazio dei nomi System. Text. JSON](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span> 

<span data-ttu-id="073a8-105">JSON (JavaScript Object Notation) è un formato dati progettato specificatamente per essere utilizzato dal codice JavaScript in esecuzione su pagine Web all'interno del browser.</span><span class="sxs-lookup"><span data-stu-id="073a8-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="073a8-106">Si tratta del formato dati predefinito utilizzato dai servizi ASP.NET AJAX creati in Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="073a8-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="073a8-107">Questo formato può essere utilizzato durante la creazione di servizi AJAX senza effettuare l'integrazione con ASP.NET: in questo caso, il formato predefinito è XML, ma è anche possibile scegliere JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="073a8-108">Infine, se è necessario disporre del supporto JSON ma non si sta creando un servizio AJAX, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> consente di serializzare direttamente oggetti di tipo .NET in dati JSON e di deserializzare tali dati in istanze di tipi .NET.</span><span class="sxs-lookup"><span data-stu-id="073a8-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="073a8-109">Per una descrizione di come eseguire questa operazione, vedere [procedura: serializzare e deserializzare i dati JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="073a8-110">Tranne rare eccezioni, quando si lavora con JSON sono supportati gli stessi tipi .NET supportati da <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="073a8-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="073a8-111">Per un elenco dei tipi supportati, vedere [tipi supportati dal serializzatore di contratti dati](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="073a8-112">L'elenco include la maggior parte dei tipi primitivi e dei tipi di matrice e di raccolta, nonché i tipi complessi che utilizzano <xref:System.Runtime.Serialization.DataContractAttribute> e <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="073a8-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="073a8-113">Mapping di tipi .NET a tipi JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="073a8-114">Nella tabella seguente viene illustrata la corrispondenza tra i tipi .NET e i tipi JSON/JavaScript quando ne viene eseguito il mapping mediante le procedure di serializzazione e deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="073a8-115">Tipi .NET</span><span class="sxs-lookup"><span data-stu-id="073a8-115">.NET Types</span></span>|<span data-ttu-id="073a8-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="073a8-116">JSON/JavaScript</span></span>|<span data-ttu-id="073a8-117">Note</span><span class="sxs-lookup"><span data-stu-id="073a8-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="073a8-118">Tutti i tipi numerici, ad esempio <xref:System.Int32>, <xref:System.Decimal> o <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="073a8-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="073a8-119">Number</span><span class="sxs-lookup"><span data-stu-id="073a8-119">Number</span></span>|<span data-ttu-id="073a8-120">I valori speciali quali `Double.NaN`, `Double.PositiveInfinity` e `Double.NegativeInfinity` non sono supportati e determinano un tipo JSON non valido.</span><span class="sxs-lookup"><span data-stu-id="073a8-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="073a8-121">Number</span><span class="sxs-lookup"><span data-stu-id="073a8-121">Number</span></span>|<span data-ttu-id="073a8-122">Vedere "Enumerazioni e JSON" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="073a8-123">Boolean</span><span class="sxs-lookup"><span data-stu-id="073a8-123">Boolean</span></span>|--|
|<span data-ttu-id="073a8-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="073a8-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="073a8-125">Stringa</span><span class="sxs-lookup"><span data-stu-id="073a8-125">String</span></span>|--|
|<span data-ttu-id="073a8-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="073a8-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="073a8-127">Stringa</span><span class="sxs-lookup"><span data-stu-id="073a8-127">String</span></span>|<span data-ttu-id="073a8-128">Il formato di questi tipi in JSON è identico a quello di XML (essenzialmente, TimeSpan nel formato di durata ISO 8601, GUID nel formato "12345678-ABCD-ABCD-ABCD-1234567890AB" e URI nella relativa forma di stringa naturale come "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="073a8-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="073a8-129">Per informazioni precise, vedere [riferimento allo schema del contratto dati](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="073a8-130">Stringa</span><span class="sxs-lookup"><span data-stu-id="073a8-130">String</span></span>|<span data-ttu-id="073a8-131">Il formato è "nome:spazio dei nomi" (tutto ciò che si trova prima del primo segno di due punti è il nome).</span><span class="sxs-lookup"><span data-stu-id="073a8-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="073a8-132">Il nome o lo spazio dei nomi potrebbero non essere presenti.</span><span class="sxs-lookup"><span data-stu-id="073a8-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="073a8-133">Se non esiste alcuno spazio dei nomi, è possibile omettere anche i due punti.</span><span class="sxs-lookup"><span data-stu-id="073a8-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="073a8-134"><xref:System.Array> di tipo <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="073a8-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="073a8-135">Matrice di numeri</span><span class="sxs-lookup"><span data-stu-id="073a8-135">Array of numbers</span></span>|<span data-ttu-id="073a8-136">Ogni numero rappresenta il valore di un byte.</span><span class="sxs-lookup"><span data-stu-id="073a8-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="073a8-137">DateTime o String</span><span class="sxs-lookup"><span data-stu-id="073a8-137">DateTime or String</span></span>|<span data-ttu-id="073a8-138">Vedere Date/Ore e JSON più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="073a8-139">Tipo complesso</span><span class="sxs-lookup"><span data-stu-id="073a8-139">Complex type</span></span>|<span data-ttu-id="073a8-140">Vedere Date/Ore e JSON più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="073a8-141">Tipi XML e ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="073a8-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="073a8-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="073a8-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="073a8-143">Matrici di <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="073a8-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="073a8-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="073a8-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="073a8-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="073a8-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="073a8-146">Stringa</span><span class="sxs-lookup"><span data-stu-id="073a8-146">String</span></span>|<span data-ttu-id="073a8-147">Vedere la sezione relativa ai tipi XML e a JSON in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="073a8-148">Tipo complesso vuoto</span><span class="sxs-lookup"><span data-stu-id="073a8-148">Empty complex type</span></span>|--|
|<span data-ttu-id="073a8-149">Raccolte, dizionari e matrici</span><span class="sxs-lookup"><span data-stu-id="073a8-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="073a8-150">Matrice</span><span class="sxs-lookup"><span data-stu-id="073a8-150">Array</span></span>|<span data-ttu-id="073a8-151">Vedere la sezione relativa alle raccolte, ai dizionari e alle matrici in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="073a8-152">Tipi complessi (con applicazione dell'attributo <xref:System.Runtime.Serialization.DataContractAttribute> o <xref:System.SerializableAttribute>)</span><span class="sxs-lookup"><span data-stu-id="073a8-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="073a8-153">Tipo complesso</span><span class="sxs-lookup"><span data-stu-id="073a8-153">Complex type</span></span>|<span data-ttu-id="073a8-154">I membri dati diventano membri del tipo complesso JavaScript.</span><span class="sxs-lookup"><span data-stu-id="073a8-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="073a8-155">Tipi complessi che implementano l'interfaccia <xref:System.Runtime.Serialization.ISerializable></span><span class="sxs-lookup"><span data-stu-id="073a8-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="073a8-156">Tipo complesso</span><span class="sxs-lookup"><span data-stu-id="073a8-156">Complex type</span></span>|<span data-ttu-id="073a8-157">Come altri tipi complessi ma alcuni tipi <xref:System.Runtime.Serialization.ISerializable> non sono supportati. Vedere la parte relativa al supporto per ISerializable nella sezione Informazioni avanzate di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="073a8-158">Valore `Null` per qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-158">`Null` value for any type</span></span>|<span data-ttu-id="073a8-159">Null</span><span class="sxs-lookup"><span data-stu-id="073a8-159">Null</span></span>|<span data-ttu-id="073a8-160">Anche i tipi nullable sono supportati e mappati a JSON, così come i tipi non-nullable.</span><span class="sxs-lookup"><span data-stu-id="073a8-160">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="073a8-161">Enumerazioni e JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-161">Enumerations and JSON</span></span>

<span data-ttu-id="073a8-162">In JSON, i valori dei membri dell'enumerazione vengono trattati come numeri, a differenza di quanto accade nei contratti dati, nei quali questi vengono inclusi come nomi dei membri.</span><span class="sxs-lookup"><span data-stu-id="073a8-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="073a8-163">Per ulteriori informazioni sul trattamento del contratto dati, vedere [tipi di enumerazione nei contratti dati](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="073a8-164">Con `public enum Color {red, green, blue, yellow, pink}`, ad esempio, la serializzazione di `yellow` produce il numero 3 e non la stringa "yellow".</span><span class="sxs-lookup"><span data-stu-id="073a8-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="073a8-165">Tutti i membri `enum` sono serializzabili.</span><span class="sxs-lookup"><span data-stu-id="073a8-165">All `enum` members are serializable.</span></span> <span data-ttu-id="073a8-166">Gli attributi <xref:System.Runtime.Serialization.EnumMemberAttribute> e <xref:System.NonSerializedAttribute>, se utilizzati, vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="073a8-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="073a8-167">È possibile deserializzare un valore `enum` non esistente: ad esempio, il valore 87 può essere deserializzato nell'enumerazione Color precedente anche se non è stato definito un nome di colore corrispondente.</span><span class="sxs-lookup"><span data-stu-id="073a8-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="073a8-168">Un `enum` di flag non è speciale e viene trattato come qualsiasi altro `enum`.</span><span class="sxs-lookup"><span data-stu-id="073a8-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="073a8-169">Date/Ore e JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-169">Dates/Times and JSON</span></span>

<span data-ttu-id="073a8-170">Il formato JSON non supporta direttamente le date e le ore.</span><span class="sxs-lookup"><span data-stu-id="073a8-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="073a8-171">Tuttavia, queste vengono comunemente utilizzate e in ASP.NET AJAX è disponibile un supporto speciale per tali tipi.</span><span class="sxs-lookup"><span data-stu-id="073a8-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="073a8-172">Quando si utilizzano i proxy ASP.NET AJAX, il tipo <xref:System.DateTime> in .NET corrisponde perfettamente al tipo `DateTime` in JavaScript.</span><span class="sxs-lookup"><span data-stu-id="073a8-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="073a8-173">Quando non si utilizza ASP.NET, un tipo <xref:System.DateTime> viene rappresentato in JSON come una stringa con formato speciale descritta nella sezione Informazioni avanzate di questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="073a8-174"><xref:System.DateTimeOffset> è rappresentato in JSON come tipo complesso: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="073a8-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="073a8-175">Il membro `offsetMinutes` rappresenta la differenza tra l'ora locale e l'ora di Greenwich (GMT), nota anche come ora UTC (Coordinated Universal Time), associata all'ubicazione dell'evento di interesse.</span><span class="sxs-lookup"><span data-stu-id="073a8-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="073a8-176">Il membro `dateTime` rappresenta il momento in cui si è verificato l'evento di interesse (anche in questo caso diventa `DateTime` in JavaScript se è in uso ASP.NET AJAX oppure una stringa in caso contrario).</span><span class="sxs-lookup"><span data-stu-id="073a8-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="073a8-177">Al momento della serializzazione, il membro `dateTime` viene sempre serializzato in GMT.</span><span class="sxs-lookup"><span data-stu-id="073a8-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="073a8-178">Pertanto, nella descrizione dell'ora 03.00 di New York, il membro `dateTime` conterrà il componente temporale 08.00, mentre i `offsetMinutes` saranno 300 (meno 300 minuti o 5 ore rispetto a GMT).</span><span class="sxs-lookup"><span data-stu-id="073a8-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="073a8-179">Quando gli oggetti <xref:System.DateTime> e <xref:System.DateTimeOffset> vengono serializzati in JSON, conservano solo le informazioni con una precisione espressa in millisecondi.</span><span class="sxs-lookup"><span data-stu-id="073a8-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="073a8-180">I sottomultipli di millisecondi (micro/nanosecondi) vanno persi durante la serializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="073a8-181">Tipi XML e JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-181">XML Types and JSON</span></span>

<span data-ttu-id="073a8-182">I tipi XML diventano stringhe JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="073a8-183">Se, ad esempio, un membro dati "q" di tipo XElement contiene \<ABC/>, il codice JSON sarà {"q": "\<ABC/>"}.</span><span class="sxs-lookup"><span data-stu-id="073a8-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="073a8-184">Alcune regole speciali determinano la modalità di incapsulamento dell'XML. Per ulteriori informazioni vedere la sezione Informazioni avanzate più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="073a8-185">Se si sta utilizzando ASP.NET AJAX e non si desidera impiegare le stringhe in JavaScript, ma il codice DOM XML, impostare la proprietà <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> su XML in <xref:System.ServiceModel.Web.WebGetAttribute> o la proprietà <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> su XML in <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="073a8-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="073a8-186">Collection, dizionari e matrici</span><span class="sxs-lookup"><span data-stu-id="073a8-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="073a8-187">In JSON, tutti e le raccolte, tutti i dizionari e le matrici vengono rappresentati come matrici.</span><span class="sxs-lookup"><span data-stu-id="073a8-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="073a8-188">Qualsiasi personalizzazione che utilizza <xref:System.Runtime.Serialization.CollectionDataContractAttribute> viene ignorata nella rappresentazione JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="073a8-189">I dizionari non sono un modo per lavorare direttamente con JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="073a8-190">Dictionary\<String, Object > potrebbe non essere supportato nello stesso modo in WCF come previsto dall'uso di altre tecnologie JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="073a8-191">Se, ad esempio, "abc" viene mappato a "xyz" e "def" viene mappato a 42 in un dizionario, la rappresentazione JSON non può essere {"abc":"xyz","def":42}, ma sarà [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].</span><span class="sxs-lookup"><span data-stu-id="073a8-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="073a8-192">Se si desidera lavorare direttamente con JSON (accedendo alle chiavi e ai valori in modo dinamico, senza definire preliminarmente un contratto rigido), sono disponibili diverse opzioni:</span><span class="sxs-lookup"><span data-stu-id="073a8-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="073a8-193">Si consiglia di usare l'esempio [AJAX (debolmente tipizzato JSON Serialization)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="073a8-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="073a8-194">Utilizzo dell'interfaccia <xref:System.Runtime.Serialization.ISerializable> e dei costruttori di deserializzazione. Questi due meccanismi consentono di accedere alle coppie chiave/valore di JSON rispettivamente durante la serializzazione e la deserializzazione, ma non funzionano in scenari di trust parziale.</span><span class="sxs-lookup"><span data-stu-id="073a8-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="073a8-195">Si consiglia di utilizzare il [mapping tra JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) anziché un serializzatore.</span><span class="sxs-lookup"><span data-stu-id="073a8-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="073a8-196">Il *polimorfismo* nel contesto di serializzazione si riferisce alla possibilità di serializzare un tipo derivato in cui è previsto il tipo di base.</span><span class="sxs-lookup"><span data-stu-id="073a8-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="073a8-197">Quando vengono utilizzate raccolte in modo polimorfico (ad esempio quando si assegna una raccolta a un elemento <xref:System.Object>), esistono regole speciali specifiche per JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="073a8-198">Questo argomento viene trattato in modo approfondito nella sezione Informazioni avanzate più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="073a8-199">Altre informazioni</span><span class="sxs-lookup"><span data-stu-id="073a8-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="073a8-200">Ordine dei membri dati</span><span class="sxs-lookup"><span data-stu-id="073a8-200">Order of Data Members</span></span>

<span data-ttu-id="073a8-201">L'ordine dei membri dati non è importante quando si utilizza JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="073a8-202">In particolare, anche se è impostato <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, è comunque possibile deserializzare i dati JSON in qualsiasi ordine.</span><span class="sxs-lookup"><span data-stu-id="073a8-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="073a8-203">Tipi JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-203">JSON Types</span></span>

<span data-ttu-id="073a8-204">Il tipo JSON non deve necessariamente corrispondere alla tabella precedente durante la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="073a8-205">Ad esempio, un `Int` normalmente viene mappato a un numero JSON, ma può anche essere deserializzato da una stringa JSON, se questa contiene un numero valido.</span><span class="sxs-lookup"><span data-stu-id="073a8-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="073a8-206">Ovvero, sia {"q": 42} che {"q": "42"} sono validi se esiste un membro dati `Int` chiamato "q".</span><span class="sxs-lookup"><span data-stu-id="073a8-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="073a8-207">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="073a8-207">Polymorphism</span></span>

<span data-ttu-id="073a8-208">Per serializzazione polimorfa si intende la capacità di serializzare un tipo derivato nei casi in cui è previsto un tipo di base.</span><span class="sxs-lookup"><span data-stu-id="073a8-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="073a8-209">Questa operazione è supportata per la serializzazione JSON da WCF, paragonabile al modo in cui è supportata la serializzazione XML.</span><span class="sxs-lookup"><span data-stu-id="073a8-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="073a8-210">Ad esempio, è possibile serializzare `MyDerivedType` dove è previsto `MyBaseType` o serializzare `Int` in cui è previsto `Object`.</span><span class="sxs-lookup"><span data-stu-id="073a8-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="073a8-211">Le informazioni sul tipo potrebbero andare perdute durante la deserializzazione di un tipo derivato nei casi in cui è previsto un tipo di base, a meno che non si stia deserializzando un tipo complesso.</span><span class="sxs-lookup"><span data-stu-id="073a8-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="073a8-212">Se, ad esempio, viene serializzato <xref:System.Uri> quando è previsto <xref:System.Object>, il risultato sarà una stringa JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="073a8-213">Se la stringa viene deserializzata di nuovo in <xref:System.Object> viene restituito un elemento <xref:System.String> .NET.</span><span class="sxs-lookup"><span data-stu-id="073a8-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="073a8-214">Il deserializzatore non è a conoscenza del fatto che la stringa era inizialmente di tipo <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="073a8-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="073a8-215">In genere, quando è previsto un elemento <xref:System.Object>, tutte le stringhe JSON vengono deserializzate come stringhe .NET, mentre tutte le matrici JSON utilizzate per serializzare i dizionari, le matrici e le raccolte .NET vengono deserializzati come elementi <xref:System.Array> .NET di tipo <xref:System.Object>, indipendentemente da quale fosse il tipo originario.</span><span class="sxs-lookup"><span data-stu-id="073a8-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="073a8-216">Un booleano JSON viene mappato a un elemento <xref:System.Boolean> .NET.</span><span class="sxs-lookup"><span data-stu-id="073a8-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="073a8-217">Tuttavia, quando è previsto un elemento <xref:System.Object>, i numeri JSON vengono deserializzati automaticamente come <xref:System.Int32>, <xref:System.Decimal> o <xref:System.Double> .NET, a seconda del tipo più appropriato.</span><span class="sxs-lookup"><span data-stu-id="073a8-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="073a8-218">In caso di deserializzazione in un tipo di interfaccia, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializza come se il tipo dichiarato fosse un oggetto.</span><span class="sxs-lookup"><span data-stu-id="073a8-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="073a8-219">Quando si lavora con i propri tipi derivati e di base, è generalmente necessario utilizzare <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> o un meccanismo equivalente.</span><span class="sxs-lookup"><span data-stu-id="073a8-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="073a8-220">Se, ad esempio, si dispone di un'operazione con un `Animal` valore restituito e viene effettivamente restituita un'istanza di `Cat` (derivato da `Animal`), è necessario applicare il <xref:System.Runtime.Serialization.KnownTypeAttribute>, al tipo di `Animal` o <xref:System.ServiceModel.ServiceKnownTypeAttribute> all'operazione e specificare il tipo di `Cat` in questi attributi.</span><span class="sxs-lookup"><span data-stu-id="073a8-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="073a8-221">Per ulteriori informazioni, vedere [tipi noti del contratto dati](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="073a8-222">Per dettagli sul funzionamento della serializzazione polimorfica e una discussione su alcune delle restrizioni che è necessario rispettare durante il suo utilizzo, vedere la sezione Informazioni avanzate più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="073a8-223">Versionamento</span><span class="sxs-lookup"><span data-stu-id="073a8-223">Versioning</span></span>

<span data-ttu-id="073a8-224">Le funzionalità di controllo delle versioni dei contratti dati, inclusa l'interfaccia <xref:System.Runtime.Serialization.IExtensibleDataObject> sono pienamente supportate in JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="073a8-225">Inoltre, nella maggior parte di casi è possibile deserializzare un tipo in un formato (ad esempio XML) e quindi serializzarlo in un altro formato (ad esempio JSON), conservando comunque i dati in un elemento <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="073a8-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="073a8-226">Per altre informazioni, vedere [Contratti di dati compatibili con versioni successive](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="073a8-227">Poiché JSON non è ordinato, le informazioni relative all'ordine andranno perse.</span><span class="sxs-lookup"><span data-stu-id="073a8-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="073a8-228">Inoltre, JSON non supporta più coppie chiave/valore con lo stesso nome di chiave.</span><span class="sxs-lookup"><span data-stu-id="073a8-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="073a8-229">Infine, tutte le operazioni su <xref:System.Runtime.Serialization.IExtensibleDataObject> sono intrinsecamente polimorfiche. ovvero i relativi tipi derivati sono assegnati a <xref:System.Object>, il tipo di base per tutti i tipi.</span><span class="sxs-lookup"><span data-stu-id="073a8-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="073a8-230">JSON negli URL</span><span class="sxs-lookup"><span data-stu-id="073a8-230">JSON in URLs</span></span>

<span data-ttu-id="073a8-231">Quando si utilizzano endpoint ASP.NET AJAX con il verbo HTTP GET (utilizzando l'attributo <xref:System.ServiceModel.Web.WebGetAttribute>), nell'URL della richiesta vengono visualizzati i parametri in arrivo anziché il corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="073a8-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="073a8-232">JSON è supportato anche nell'URL della richiesta, pertanto se si dispone di un'operazione che accetta un `Int` denominato "numero" e un `Person` tipo complesso denominato "p", l'URL potrebbe essere simile all'URL seguente.</span><span class="sxs-lookup"><span data-stu-id="073a8-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="073a8-233">Se si utilizzano un controllo Script Manager ASP.NET AJAX e un proxy per chiamare il servizio, l'URL viene automaticamente generato dal proxy e non viene visualizzato.</span><span class="sxs-lookup"><span data-stu-id="073a8-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="073a8-234">Non è possibile utilizzare JSON in URL su endpoint non ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="073a8-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="073a8-235">Informazioni avanzate</span><span class="sxs-lookup"><span data-stu-id="073a8-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="073a8-236">Supporto per ISerializable</span><span class="sxs-lookup"><span data-stu-id="073a8-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="073a8-237">Tipi ISerializable supportati e non supportati</span><span class="sxs-lookup"><span data-stu-id="073a8-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="073a8-238">In generale, i tipi che implementano l'interfaccia <xref:System.Runtime.Serialization.ISerializable> sono completamente supportati durante la serializzazione/deserializzazione di JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="073a8-239">Tuttavia, alcuni di questi tipi (inclusi alcuni tipi .NET Framework) vengono implementati in modo tale che gli aspetti specifici della serializzazione di JSON ne impediscono la corretta deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="073a8-240">Con <xref:System.Runtime.Serialization.ISerializable>, il tipo dei singoli membri dati non è noto in anticipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="073a8-241">Ciò causa una situazione polimorfica simile alla deserializzazione di tipi in un oggetto.</span><span class="sxs-lookup"><span data-stu-id="073a8-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="073a8-242">Come già sottolineato, ciò potrebbe causare la perdita di informazioni sul tipo in JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="073a8-243">Ad esempio, un tipo che serializza un `enum` nella sua implementazione di <xref:System.Runtime.Serialization.ISerializable> e tenta di effettuare la deserializzazione direttamente in un elemento `enum` (senza cast adeguati) non riesce poiché un `enum` viene serializzato utilizzando un numero in JSON mentre i numeri JSON eseguono la deserializzazione in tipi numerici incorporati .NET (Int32 .NET, Decimal o Double).</span><span class="sxs-lookup"><span data-stu-id="073a8-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="073a8-244">Pertanto, l'informazione che il numero utilizzato era in precedenza un valore `enum` viene persa.</span><span class="sxs-lookup"><span data-stu-id="073a8-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="073a8-245">Un tipo <xref:System.Runtime.Serialization.ISerializable> che dipende da un particolare ordine di deserializzazione nel relativo costruttore di deserializzazione potrebbe non riuscire a deserializzare alcuni dati JSON poiché la maggior parte dei serializzatori JSON non garantisce un ordine specifico.</span><span class="sxs-lookup"><span data-stu-id="073a8-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="073a8-246">Tipi Factory</span><span class="sxs-lookup"><span data-stu-id="073a8-246">Factory Types</span></span>

<span data-ttu-id="073a8-247">Mentre l'interfaccia <xref:System.Runtime.Serialization.IObjectReference> è generalmente supportata in JSON, i tipi che richiedono la funzionalità "tipo factory" (che restituisce un'istanza di un tipo differente da <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> rispetto al tipo che implementa l'interfaccia) non sono supportati.</span><span class="sxs-lookup"><span data-stu-id="073a8-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="073a8-248">Formato di trasmissione DateTime</span><span class="sxs-lookup"><span data-stu-id="073a8-248">DateTime Wire Format</span></span>

<span data-ttu-id="073a8-249">I valori <xref:System.DateTime> vengono visualizzati come stringhe JSON nella forma "/Date(700000+0500)/", dove il primo numero (700000 nell'esempio fornito) è il numero di millisecondi nel fuso orario di GMT, orario solare (non ora legale) dalla mezzanotte del 1° gennaio 1970.</span><span class="sxs-lookup"><span data-stu-id="073a8-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="073a8-250">Il numero può essere negativo per rappresentare momenti precedenti.</span><span class="sxs-lookup"><span data-stu-id="073a8-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="073a8-251">La parte rappresentata da "+0500" nell'esempio è facoltativa e indica che l'orario è di tipo <xref:System.DateTimeKind.Local>, ossia dovrebbe essere convertito nel fuso orario locale durante la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="073a8-252">Se assente, l'orario viene deserializzato come <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="073a8-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="073a8-253">Il numero effettivo ("0500" in questo esempio) e il relative segno (+ o -) vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="073a8-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="073a8-254">Durante la serializzazione di <xref:System.DateTime>, gli orari <xref:System.DateTimeKind.Local> e <xref:System.DateTimeKind.Unspecified> sono scritti con uno scostamento, mentre <xref:System.DateTimeKind.Utc> viene scritto senza alcuno scostamento.</span><span class="sxs-lookup"><span data-stu-id="073a8-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="073a8-255">Il codice JavaScript del client ASP.NET AJAX converte automaticamente tali stringhe in istanze `DateTime` JavaScript.</span><span class="sxs-lookup"><span data-stu-id="073a8-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="073a8-256">Verranno convertite anche tutte le altre stringhe che presentano una forma simile e non sono di tipo <xref:System.DateTime> in .NET.</span><span class="sxs-lookup"><span data-stu-id="073a8-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="073a8-257">La conversione viene eseguita solo se i caratteri "/" sono preceduti da un carattere di escape, ovvero il formato JSON è "\\/date (700000 + 0500)\\/") e per questo motivo il codificatore JSON di WCF (abilitato dalla <xref:System.ServiceModel.WebHttpBinding>) esegue sempre l'escape del carattere "/".</span><span class="sxs-lookup"><span data-stu-id="073a8-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="073a8-258">XML nelle stringhe JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="073a8-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="073a8-259">XmlElement</span></span>

<span data-ttu-id="073a8-260"><xref:System.Xml.XmlElement> viene serializzato così com'è, senza incapsulamento.</span><span class="sxs-lookup"><span data-stu-id="073a8-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="073a8-261">Ad esempio, il membro dati "x" di tipo <xref:System.Xml.XmlElement> contenente \<ABC/> è rappresentato come segue:</span><span class="sxs-lookup"><span data-stu-id="073a8-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="073a8-262">Matrici di XmlNode</span><span class="sxs-lookup"><span data-stu-id="073a8-262">Arrays of XmlNode</span></span>

<span data-ttu-id="073a8-263">Gli oggetti <xref:System.Array> di tipo <xref:System.Xml.XmlNode> vengono incapsulati in un elemento denominato ArrayOfXmlNode nello spazio dei nomi del contratto dati standard per il tipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="073a8-264">Se "x" è una matrice contenente il nodo attributo "N" nello spazio dei nomi "ns" che contiene "value" e un nodo elemento vuoto "M", la rappresentazione risulterà quella seguente:</span><span class="sxs-lookup"><span data-stu-id="073a8-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="073a8-265">Gli attributi nello spazio dei nomi vuoto all'inizio della matrice XmlNode (prima di altri elementi) non sono supportati.</span><span class="sxs-lookup"><span data-stu-id="073a8-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="073a8-266">Tipi IXmlSerializable inclusi XElement e DataSet</span><span class="sxs-lookup"><span data-stu-id="073a8-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="073a8-267">I tipi <xref:System.Runtime.Serialization.ISerializable> si suddividono in tipi contenuto, tipi DataSet e tipi elemento.</span><span class="sxs-lookup"><span data-stu-id="073a8-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="073a8-268">Per le definizioni di questi tipi, vedere [tipi XML e ADO.NET nei contratti dati](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="073a8-269">I tipi contenuto e DataSet vengono serializzati in modo simile agli oggetti <xref:System.Array> di <xref:System.Xml.XmlNode> descritti nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="073a8-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="073a8-270">Tali tipi vengono incapsulati in un elemento il cui nome e spazio dei nomi corrisponde al nome e allo spazio dei nomi del contratto dati del tipo in questione.</span><span class="sxs-lookup"><span data-stu-id="073a8-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="073a8-271">I tipi elemento come <xref:System.Xml.Linq.XElement> vengono serializzati così come sono, in modo analogo a <xref:System.Xml.XmlElement>, già descritto in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="073a8-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="073a8-272">Polimorfismo</span><span class="sxs-lookup"><span data-stu-id="073a8-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="073a8-273">Mantenimento delle informazioni sui tipi</span><span class="sxs-lookup"><span data-stu-id="073a8-273">Preserving Type Information</span></span>

<span data-ttu-id="073a8-274">Come già illustrato il polimorfismo è supportato in JSON. con alcune restrizioni.</span><span class="sxs-lookup"><span data-stu-id="073a8-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="073a8-275">JavaScript è un linguaggio con tipizzazione debole e l'identità del tipo non rappresenta solitamente un problema.</span><span class="sxs-lookup"><span data-stu-id="073a8-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="073a8-276">Tuttavia, quando si utilizza JSON per le comunicazioni tra un sistema fortemente tipizzato (.NET) e uno con tipizzazione debole (JavaScript), è utile mantenere l'identità del tipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="073a8-277">Ad esempio, i tipi con nomi di contratto dati "Square" e "Circle" derivano da un tipo con nome di contratto dati "Shape".</span><span class="sxs-lookup"><span data-stu-id="073a8-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="073a8-278">Se "Circle" viene inviato da .NET a JavaScript e viene quindi restituito a un metodo .NET che prevede "Shape", è utile per .NET sapere che l'oggetto in questione è stato originariamente "Circle"; in caso contrario, tutte le informazioni specifiche del tipo derivato (ad esempio il membro dati "radium" in "Circle") potrebbero andare perdute.</span><span class="sxs-lookup"><span data-stu-id="073a8-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="073a8-279">Per mantenere l'identità del tipo, durante la serializzazione di tipi complessi in JSON può essere aggiunto un suggerimento; il deserializzatore riconosce tale suggerimento e agisce di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="073a8-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="073a8-280">"Hint di tipo" è una coppia chiave/valore JSON con il nome della chiave "\_\_tipo" (due caratteri di sottolineatura seguiti dalla parola "Type").</span><span class="sxs-lookup"><span data-stu-id="073a8-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="073a8-281">Il valore è rappresentato da una stringa JSON con forma "DataContractName:DataContractNamespace" (tutto il testo che precede i due punti rappresenta il nome).</span><span class="sxs-lookup"><span data-stu-id="073a8-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="073a8-282">Facendo riferimento all'esempio precedente, "cerchio" può essere serializzato nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="073a8-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="073a8-283">Il suggerimento relativo ai tipi è molto simile all'attributo `xsi:type` definito dallo standard delle istanze di schemi XML e utilizzato durante la serializzazione/deserializzazione dell'XML.</span><span class="sxs-lookup"><span data-stu-id="073a8-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="073a8-284">I membri dati chiamati "\_tipo di \_" non sono consentiti a causa di un potenziale conflitto con l'hint di tipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="073a8-285">Riduzione delle dimensioni del suggerimento relativo al tip006F</span><span class="sxs-lookup"><span data-stu-id="073a8-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="073a8-286">Per ridurre le dimensioni dei messaggi JSON, il prefisso dello spazio dei nomi del contratto dati predefinito (`http://schemas.datacontract.org/2004/07/`) viene sostituito con il carattere "#".</span><span class="sxs-lookup"><span data-stu-id="073a8-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="073a8-287">Per rendere reversibile questa sostituzione, viene utilizzata una regola di escape: se lo spazio dei nomi inizia con i caratteri "#" o "\\", viene accodato con un carattere "\\" aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="073a8-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="073a8-288">Se quindi "Circle" è un tipo nello spazio dei nomi .NET "MyApp. Shapes", viene `http://schemas.datacontract.org/2004/07/MyApp`lo spazio dei nomi del contratto dati predefinito.</span><span class="sxs-lookup"><span data-stu-id="073a8-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="073a8-289">Le forme e la rappresentazione JSON appaiono nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="073a8-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="073a8-290">Sia il troncato (#MyApp. Shapes) che l'oggetto completo (i nomi di http://schemas.datacontract.org/2004/07/MyApp.Shapes) vengono riconosciuti durante la deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="073a8-291">Posizione del suggerimento relativo ai tipi negli oggetti JSON</span><span class="sxs-lookup"><span data-stu-id="073a8-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="073a8-292">Il suggerimento relativo ai tipi deve essere visualizzato innanzitutto nella rappresentazione JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="073a8-293">Questo è il solo caso in cui l'ordine delle coppie chiave/valore è importante nell'elaborazione di JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="073a8-294">Di seguito viene riportato un esempio di modalità non valida per specificare un suggerimento relativo ai tipi.</span><span class="sxs-lookup"><span data-stu-id="073a8-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="073a8-295">Entrambe le <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> utilizzate dalle pagine client WCF e ASP.NET AJAX generano sempre l'hint per il tipo.</span><span class="sxs-lookup"><span data-stu-id="073a8-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="073a8-296">I suggerimenti relativi al tipo si applicano solo ai tipi complessi</span><span class="sxs-lookup"><span data-stu-id="073a8-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="073a8-297">Non è possibile inviare un suggerimento relativo ai tipi a tipi non complessi.</span><span class="sxs-lookup"><span data-stu-id="073a8-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="073a8-298">Ad esempio, se il tipo restituito da un'operazione è <xref:System.Object> ma viene restituito un Circle, la rappresentazione JSON può essere del tipo illustrato in precedenza e le informazioni sul tipo verranno mantenute.</span><span class="sxs-lookup"><span data-stu-id="073a8-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="073a8-299">Tuttavia, se viene restituito l'URI, la rappresentazione JSON sarà una stringa e l'informazione che la stringa utilizzata per rappresentare l'URI viene persa.</span><span class="sxs-lookup"><span data-stu-id="073a8-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="073a8-300">Ciò è valido non solo per i tipi primitivi ma anche per le raccolte e le matrici.</span><span class="sxs-lookup"><span data-stu-id="073a8-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="073a8-301">Invio dei suggerimenti relativi al tipo</span><span class="sxs-lookup"><span data-stu-id="073a8-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="073a8-302">I suggerimenti relativi al tipo possono aumentare significativamente le dimensioni dei messaggi; un modo per limitare questa conseguenza è quello di utilizzare uno spazio dei nomi del contratto dati più breve, se possibile.</span><span class="sxs-lookup"><span data-stu-id="073a8-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="073a8-303">Pertanto, le regole seguenti determinano quali suggerimenti relativi al tipo vengono inviati.</span><span class="sxs-lookup"><span data-stu-id="073a8-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="073a8-304">Se si utilizza ASP.NET AJAX, laddove possibile i suggerimenti relativi al tipo vengono sempre inviati, anche se non esiste un'assegnazione di base/derivata (ad esempio, se un Circle è assegnato a un Circle).</span><span class="sxs-lookup"><span data-stu-id="073a8-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="073a8-305">Ciò è necessario per abilitare completamente il processo di chiamata da un ambiente JSON con tipizzazione debole a un ambiente .NET fortemente tipizzato, senza un imprevista perdita di informazioni.</span><span class="sxs-lookup"><span data-stu-id="073a8-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="073a8-306">Se si utilizzano i servizi ASP.NET AJAX senza integrazione ASP.NET, i suggerimenti relativi al tipo vengono inviati solamente se esiste un'assegnazione di base/derivata, ossia quando Circle viene assegnato a Shape o a <xref:System.Object>, ma non a Circle.</span><span class="sxs-lookup"><span data-stu-id="073a8-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="073a8-307">Ciò garantisce che vengano fornite le informazioni minime necessarie per l'implementazione corretta di un client JavaScript, migliorando in tal modo le prestazioni, ma non offre alcuna protezione contro la perdita delle informazioni sui tipi nei client progettati in modo non corretto.</span><span class="sxs-lookup"><span data-stu-id="073a8-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="073a8-308">Per impedire che si presenti tale problema sul client, evitare di utilizzare le assegnazioni di base/derivate sul server.</span><span class="sxs-lookup"><span data-stu-id="073a8-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="073a8-309">Se si utilizza il tipo <xref:System.Runtime.Serialization.DataContractSerializer>, il parametro di costruttore `alwaysEmitTypeInformation` consente di scegliere tra le due modalità precedenti, mentre l'impostazione predefinita è "`false`" (i suggerimenti sul tipo vengono inviati solo se richiesto).</span><span class="sxs-lookup"><span data-stu-id="073a8-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="073a8-310">Nomi di membro dati duplicati</span><span class="sxs-lookup"><span data-stu-id="073a8-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="073a8-311">Le informazioni sul tipo derivato sono incluse nello stesso oggetto JSON delle informazioni sul tipo di base, in qualsiasi ordine.</span><span class="sxs-lookup"><span data-stu-id="073a8-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="073a8-312">È ad esempio possibile rappresentare `Shape` come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="073a8-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="073a8-313">Circle, invece, potrebbe essere rappresentato nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="073a8-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="073a8-314">Se il tipo di `Shape` di base contiene anche un membro dati denominato "`radius`", ciò comporta una collisione in entrambe le serializzazioni (perché gli oggetti JSON non possono avere nomi di chiave ripetuti) e la deserializzazione (perché non è chiaro se "RADIUS" si riferisce a `Shape.radius` o `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="073a8-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="073a8-315">Pertanto, mentre il concetto di "occultamento della proprietà" (i membri dati con lo stesso nome sulle classi di base e derivate) non viene generalmente consigliato nelle classi del contratto dati, non è assolutamente consentito nel caso di JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="073a8-316">Polimorfismo e tipi IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="073a8-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="073a8-317">In base alle normali regole sui contratti dati, i tipi <xref:System.Xml.Serialization.IXmlSerializable> possono non essere assegnati in modo polimorfico l'uno all'altro come di norma a condizione che siano soddisfatti i requisiti dei tipi noti.</span><span class="sxs-lookup"><span data-stu-id="073a8-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="073a8-318">Tuttavia, la serializzazione di un tipo <xref:System.Xml.Serialization.IXmlSerializable> al posto di <xref:System.Object> causa la perdita di informazioni sul tipo poiché il risultato è una stringa JSON.</span><span class="sxs-lookup"><span data-stu-id="073a8-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="073a8-319">Polimorfismo e determinati tipi di interfaccia</span><span class="sxs-lookup"><span data-stu-id="073a8-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="073a8-320">Non è consentito serializzare una raccolta di tipi o un tipo che implementa <xref:System.Xml.Serialization.IXmlSerializable> nei casi in cui è previsto un tipo non di raccolta diverso da <xref:System.Xml.Serialization.IXmlSerializable> (ad eccezione di <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="073a8-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="073a8-321">Ad esempio, un'interfaccia personalizzata denominata `IMyInterface` e un tipo `MyType` che implementano sia <xref:System.Collections.Generic.IEnumerable%601> di tipo `int` che `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="073a8-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="073a8-322">Non è consentito restituire `MyType` da un'operazione il cui tipo restituito è `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="073a8-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="073a8-323">Questo perché `MyType` deve essere serializzato come matrice JSON e richiede un hint di tipo e, come indicato prima, non è possibile includere un hint di tipo con matrici, solo con tipi complessi.</span><span class="sxs-lookup"><span data-stu-id="073a8-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="073a8-324">Tipi conosciuti e configurazione</span><span class="sxs-lookup"><span data-stu-id="073a8-324">Known Types and Configuration</span></span>

<span data-ttu-id="073a8-325">Tutti i meccanismi relativi ai tipi noti utilizzati dall'elemento <xref:System.Runtime.Serialization.DataContractSerializer> sono supportati anche da <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="073a8-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="073a8-326">Entrambi i serializzatori leggono lo stesso elemento di configurazione, [\<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<System. runtime. Serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)per individuare i tipi noti aggiunti tramite un file di configurazione.</span><span class="sxs-lookup"><span data-stu-id="073a8-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="073a8-327">Raccolte assegnate a un oggetto</span><span class="sxs-lookup"><span data-stu-id="073a8-327">Collections Assigned to Object</span></span>

<span data-ttu-id="073a8-328">Le raccolte assegnate a un oggetto vengono serializzate se implementano <xref:System.Collections.Generic.IEnumerable%601>: una matrice JSON le cui voci dispongono di un suggerimento relativo ai tipi, se si tratta di un tipo complesso.</span><span class="sxs-lookup"><span data-stu-id="073a8-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="073a8-329">Ad esempio, un <xref:System.Collections.Generic.List%601> di tipo `Shape` assegnato a <xref:System.Object> ha un aspetto simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="073a8-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="073a8-330">Se deserializzata di nuovo in <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="073a8-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="073a8-331">`Shape` deve essere presente nell'elenco dei tipi noti.</span><span class="sxs-lookup"><span data-stu-id="073a8-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="073a8-332">La presenza di <xref:System.Collections.Generic.List%601> di tipo `Shape` in tipi noti non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="073a8-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="073a8-333">Si noti che in questo caso non è necessario aggiungere `Shape` ai tipi noti per la serializzazione. questa operazione viene eseguita automaticamente.</span><span class="sxs-lookup"><span data-stu-id="073a8-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="073a8-334">La raccolta viene deserializzata come <xref:System.Array> di tipo <xref:System.Object> che contiene `Shape` istanze.</span><span class="sxs-lookup"><span data-stu-id="073a8-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="073a8-335">Raccolte derivate assegnate a raccolte di base</span><span class="sxs-lookup"><span data-stu-id="073a8-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="073a8-336">Se una raccolta derivata viene assegnata a una raccolta di base, verrà generalmente serializzata come se si trattasse di una raccolta di tipi di base.</span><span class="sxs-lookup"><span data-stu-id="073a8-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="073a8-337">Tuttavia, se il tipo di elemento della raccolta derivata non può essere assegnato al tipo di elemento della raccolta di base, verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="073a8-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="073a8-338">Suggerimenti relativi al tipo e dizionari</span><span class="sxs-lookup"><span data-stu-id="073a8-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="073a8-339">Se un dizionario viene assegnato a un elemento <xref:System.Object>, ciascuna voce Key e Value nel dizionario verrà trattata come se fosse assegnata a <xref:System.Object> e ottiene un suggerimento relativo ai tipi.</span><span class="sxs-lookup"><span data-stu-id="073a8-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="073a8-340">Durante la serializzazione dei tipi di dizionario, l'oggetto JSON che contiene i membri "Key" e "Value" non è interessato dall'impostazione `alwaysEmitTypeInformation` e includerà un suggerimento relativo ai tipi solo se le regole della raccolta precedente lo richiedono.</span><span class="sxs-lookup"><span data-stu-id="073a8-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="073a8-341">Nomi di chiave JSON validi</span><span class="sxs-lookup"><span data-stu-id="073a8-341">Valid JSON Key Names</span></span>

<span data-ttu-id="073a8-342">Il serializzatore XML codifica i nomi delle chiavi che non sono nomi XML validi.</span><span class="sxs-lookup"><span data-stu-id="073a8-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="073a8-343">Ad esempio, un membro dati con il nome "123" avrebbe un nome codificato, ad esempio "\_X0031\_\_x0032\_\_x0033\_" perché "123" è un nome di elemento XML non valido (inizia con una cifra).</span><span class="sxs-lookup"><span data-stu-id="073a8-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="073a8-344">Una situazione simile può presentarsi con alcuni set di caratteri internazioni non validi per i nomi XML.</span><span class="sxs-lookup"><span data-stu-id="073a8-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="073a8-345">Per una spiegazione di questo effetto del codice XML sull'elaborazione JSON, vedere [mapping tra JSON e XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="073a8-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="073a8-346">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="073a8-346">See also</span></span>

- [<span data-ttu-id="073a8-347">Supporto per JSON e altri formati di trasferimento dati</span><span class="sxs-lookup"><span data-stu-id="073a8-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
