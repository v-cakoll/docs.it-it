---
title: Dati di grandi dimensioni e flussi
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 91e53f66fb0f2f94a315c318eb0b203d78427bae
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184674"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="f88f0-102">Dati di grandi dimensioni e flussi</span><span class="sxs-lookup"><span data-stu-id="f88f0-102">Large Data and Streaming</span></span>

<span data-ttu-id="f88f0-103">Windows Communication Foundation (WCF) è un'infrastruttura di comunicazione basata su XML.</span><span class="sxs-lookup"><span data-stu-id="f88f0-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="f88f0-104">Poiché i dati XML sono in genere codificati nel formato di testo standard definito nella [specifica XML 1.0,](https://www.w3.org/TR/REC-xml/)gli sviluppatori e gli architetti di sistemi connessi sono in genere preoccupati per l'impronta del filo (o le dimensioni) dei messaggi inviati attraverso la rete e la codifica basata su testo di XML pone sfide speciali per il trasferimento efficiente dei dati binari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="f88f0-105">Considerazioni di base</span><span class="sxs-lookup"><span data-stu-id="f88f0-105">Basic Considerations</span></span>  
 <span data-ttu-id="f88f0-106">Per fornire informazioni di base sulle informazioni seguenti per WCF, in questa sezione vengono evidenziati alcuni problemi e considerazioni generali per le codifiche, i dati binari e il flusso che in genere si applicano alle infrastrutture di sistemi connessi.</span><span class="sxs-lookup"><span data-stu-id="f88f0-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="f88f0-107">Codifica dei dati: testo o formato binario</span><span class="sxs-lookup"><span data-stu-id="f88f0-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="f88f0-108">Gli sviluppatori hanno espresso preoccupazioni comuni, tra cui la percezione che il codice XML generi un notevole sovraccarico se paragonato ai formati binari a causa della natura ripetitiva dei tag di inizio e fine, l'osservazione che la codifica di valori numerici sia significativamente più grande poiché vengono espressi in valori di testo, e l'opinione che i dati binari non possono essere espressi in modo efficiente perché devono essere codificati appositamente per essere incorporati in un formato di testo.</span><span class="sxs-lookup"><span data-stu-id="f88f0-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="f88f0-109">Sebbene molte di queste e altre preoccupazioni simili siano valide, la differenza effettiva tra messaggi codificati in formato di testo-XML in un ambiente di servizi Web XML e messaggi con codifica binaria in un ambiente legacy di chiamata a procedura remota (RPC) è spesso molto meno significativa di quanto la considerazione iniziale possa suggerire.</span><span class="sxs-lookup"><span data-stu-id="f88f0-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="f88f0-110">Mentre i messaggi con codifica in formato testo-XML sono messaggi leggibili, i messaggi binari sono spesso incomprensibili e difficili da decodificare senza strumenti appropriati.</span><span class="sxs-lookup"><span data-stu-id="f88f0-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="f88f0-111">Questa differenza di leggibilità porta a trascurare il fatto che i messaggi binari spesso contengono metadati inline nel payload, con conseguente aumento del sovraccarico, proprio come con i messaggi di testo-XML.</span><span class="sxs-lookup"><span data-stu-id="f88f0-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="f88f0-112">Questa considerazione è particolarmente valida per i formati binari destinati a fornire funzionalità a regime di controllo libero e di chiamata dinamica.</span><span class="sxs-lookup"><span data-stu-id="f88f0-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="f88f0-113">Tuttavia, i formati binari in genere contengono tali informazioni sui metadati descrittivi in un'intestazione, che dichiara anche il layout dei dati per i record di dati seguenti.</span><span class="sxs-lookup"><span data-stu-id="f88f0-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="f88f0-114">Il payload segue quindi questa dichiarazione del blocco di metadati comuni con un ulteriore sovraccarico minimo.</span><span class="sxs-lookup"><span data-stu-id="f88f0-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="f88f0-115">Diversamente, il formato XML racchiude i singoli elementi di dati in un elemento o attributo in modo che i metadati che li racchiudono vengano inclusi ripetitivamente per ogni oggetto del payload serializzato.</span><span class="sxs-lookup"><span data-stu-id="f88f0-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="f88f0-116">Di conseguenza, le dimensioni di un singolo oggetto del payload serializzato sono simili se si confronta il testo alle rappresentazioni binarie perché alcuni metadati descrittivi devono essere espressi per entrambi, anche se il formato binario trae vantaggio dalla descrizione dei metadati condivisa con ogni oggetto del payload aggiuntivo che viene trasferito a causa del sovraccarico complessivo inferiore.</span><span class="sxs-lookup"><span data-stu-id="f88f0-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="f88f0-117">In ogni modo, per certi tipi di dati, quali i numeri, potrebbe essere svantaggioso utilizzare rappresentazioni numeriche binarie di dimensioni fisse, ad esempio un tipo decimale a 128 bit anziché il testo normale, poiché la rappresentazione in testo normale potrebbe essere di molto inferiore.</span><span class="sxs-lookup"><span data-stu-id="f88f0-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="f88f0-118">Anche i dati di testo potrebbero trarre vantaggio in termini di dimensioni dalle opzioni di codifica in testo-XML tipicamente più flessibili, mentre alcuni formati binari potrebbero impostare come valore predefinito il formato Unicode a 16 bit o anche a 32 bit, che non può essere applicato al formato XML binario di .NET.</span><span class="sxs-lookup"><span data-stu-id="f88f0-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="f88f0-119">Di conseguenza, la scelta tra formato testo e formato binario non può essere basata semplicemente sul fatto che i messaggi binari sono sempre più piccoli dei messaggi in formato testo-XML.</span><span class="sxs-lookup"><span data-stu-id="f88f0-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="f88f0-120">Un chiaro vantaggio dei messaggi in formato testo-XML è che sono basati su standard e offrono la più ampia scelta di opzioni di interoperabilità e supporto di piattaforme.</span><span class="sxs-lookup"><span data-stu-id="f88f0-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="f88f0-121">Per ulteriori informazioni, vedere la sezione "Codifiche" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f88f0-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="f88f0-122">Contenuto binario</span><span class="sxs-lookup"><span data-stu-id="f88f0-122">Binary Content</span></span>  
 <span data-ttu-id="f88f0-123">Un'area in cui le codifiche binarie sono superiori alle codifiche basate su testo, per quanto concerne la dimensione del messaggio risultante, è costituita dai dati binari di grandi dimensioni quali immagini, video, clip audio o qualsiasi altro tipo di dati opachi binari che devono essere scambiati tra servizi e utenti.</span><span class="sxs-lookup"><span data-stu-id="f88f0-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="f88f0-124">Per adattare questi tipi di dati nel testo XML, l'approccio comune è di codificarli utilizzando la codifica Base64.</span><span class="sxs-lookup"><span data-stu-id="f88f0-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="f88f0-125">In una stringa con codifica Base64, ogni carattere rappresenta 6 bit dei dati originali a 8 bit, con un conseguente rapporto di codifica-sovraccarico di 4:3 per Base64, senza contare i caratteri aggiuntivi della formattazione (ritorno a capo/avanzamento riga) che vengono normalmente aggiunti per convenzione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="f88f0-126">Mentre l'importanza delle differenze tra le codifiche XML e binaria dipende in genere dallo scenario, un aumento della dimensione di oltre il 33% durante la trasmissione di un payload da 500 MB non è in genere accettabile.</span><span class="sxs-lookup"><span data-stu-id="f88f0-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="f88f0-127">Per evitare questo sovraccarico della codifica, lo standard MTOM (Message Transmission Optimization Mechanism) consente di esternalizzare i dati di grandi dimensioni contenuti in un messaggio per trasportarli con il messaggio in forma di dati binari senza alcuna codifica speciale.</span><span class="sxs-lookup"><span data-stu-id="f88f0-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="f88f0-128">Con MTOM, i messaggi vengono scambiati in modo simile ai messaggi di posta elettronica SMTP (Simple Mail Transfer Protocol) con allegati o contenuto incorporato (immagini e altri contenuti incorporati); I messaggi MTOM vengono inclusi in un pacchetto come sequenze MIME multipart/correlate con la parte radice che è il messaggio SOAP effettivo.</span><span class="sxs-lookup"><span data-stu-id="f88f0-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="f88f0-129">Un messaggio SOAP MTOM viene modificato rispetto alla versione non codificata in modo che tag di elemento speciali, riferiti alle relative parti MIME, sostituiscano gli elementi originali nel messaggio che conteneva dati binari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="f88f0-130">Di conseguenza, il messaggio SOAP fa riferimento al contenuto binario puntando alle parti MIME inviate con il messaggio stesso, ma contiene solo dati di testo XML.</span><span class="sxs-lookup"><span data-stu-id="f88f0-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="f88f0-131">Poiché questo modello è perfettamente allineato al diffuso modello SMTP, sono disponibili numerosi strumenti di supporto per codificare e decodificare i messaggi MTOM su molte piattaforme. Questa scelta diventa quindi estremamente interoperativa.</span><span class="sxs-lookup"><span data-stu-id="f88f0-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="f88f0-132">Lo standard MTOM, come la codifica Base64, comporta un sovraccarico indispensabile per il formato MIME, pertanto i vantaggi dell'utilizzo di MTOM sono visibili solo quando la dimensione dei dati binari supera 1 KB.</span><span class="sxs-lookup"><span data-stu-id="f88f0-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="f88f0-133">A causa del sovraccarico, i messaggi con codifica MTOM potrebbero essere più grandi dei messaggi con codifica Base64 per i dati binari, se il payload binario rimane sotto tale soglia.</span><span class="sxs-lookup"><span data-stu-id="f88f0-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="f88f0-134">Per ulteriori informazioni, vedere la sezione "Codifiche" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f88f0-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="f88f0-135">Contenuto costituito da dati di grandi dimensioni</span><span class="sxs-lookup"><span data-stu-id="f88f0-135">Large Data Content</span></span>  
 <span data-ttu-id="f88f0-136">A parte il footprint in rete, il payload precedentemente menzionato di 500 MB crea un significativo problema locale anche per il servizio e il client.</span><span class="sxs-lookup"><span data-stu-id="f88f0-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="f88f0-137">Per impostazione predefinita, WCF elabora i messaggi in *modalità buffer.*</span><span class="sxs-lookup"><span data-stu-id="f88f0-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="f88f0-138">Questo vuole dire che l'intero contenuto di un messaggio è presente in memoria prima di essere inviato o dopo essere stato ricevuto.</span><span class="sxs-lookup"><span data-stu-id="f88f0-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="f88f0-139">Sebbene questa strategia si riveli valida per la maggior parte degli scenari e necessaria per le funzionalità di messaggistica quali firme digitali e recapito affidabile, i messaggi di grandi dimensioni potrebbero esaurire le risorse di un sistema.</span><span class="sxs-lookup"><span data-stu-id="f88f0-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="f88f0-140">La strategia adatta per gestire ingenti payload consiste nella trasmissione di flussi.</span><span class="sxs-lookup"><span data-stu-id="f88f0-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="f88f0-141">Anche se i messaggi, in particolar modo quelli espressi in formato XML, sono comunemente considerati pacchetti di dati relativamente compatti, un messaggio può avere dimensioni pari a più gigabyte ed essere più simile a un flusso di dati continuo, anziché a un pacchetto di dati.</span><span class="sxs-lookup"><span data-stu-id="f88f0-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="f88f0-142">Quando i dati vengono trasferiti in modalità flusso anziché in modalità di memorizzazione nel buffer, il mittente rende disponibile il contenuto del corpo del messaggio al destinatario sotto forma di flusso e l'infrastruttura di messaggistica inoltra continuamente i dati dal mittente al destinatario, man mano che sono disponibili.</span><span class="sxs-lookup"><span data-stu-id="f88f0-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="f88f0-143">Lo scenario più comune nel quale si verificano trasferimenti di contenuto costituito da dati di grandi dimensioni è rappresentato dai trasferimenti di oggetti dati binari che:</span><span class="sxs-lookup"><span data-stu-id="f88f0-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="f88f0-144">Non possono essere facilmente suddivisi in una sequenza di messaggi.</span><span class="sxs-lookup"><span data-stu-id="f88f0-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="f88f0-145">Devono essere recapitati in maniera tempestiva.</span><span class="sxs-lookup"><span data-stu-id="f88f0-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="f88f0-146">Non sono disponibili per intero al momento dell'avvio del trasferimento.</span><span class="sxs-lookup"><span data-stu-id="f88f0-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="f88f0-147">Per i dati che non presentano questi vincoli, in genere è consigliabile inviare sequenze di messaggi nell'ambito di una sessione, anziché un solo grande messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="f88f0-148">Per ulteriori informazioni, vedere la sezione "Streaming Data" più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f88f0-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="f88f0-149">Quando si inviano grandi quantità di `maxAllowedContentLength` dati, è necessario impostare l'impostazione IIS `maxReceivedMessageSize` (per ulteriori informazioni, vedere Configurazione dei limiti delle richieste [IIS](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) e l'impostazione di associazione (ad esempio [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) o ). <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A></span><span class="sxs-lookup"><span data-stu-id="f88f0-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="f88f0-150">Il `maxAllowedContentLength` valore predefinito della proprietà è `maxReceivedMessageSize` 28,6 MB e il valore predefinito è 64 KB.</span><span class="sxs-lookup"><span data-stu-id="f88f0-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="f88f0-151">Codifiche</span><span class="sxs-lookup"><span data-stu-id="f88f0-151">Encodings</span></span>  
 <span data-ttu-id="f88f0-152">Una *codifica* definisce un set di regole su come presentare i messaggi in rete.</span><span class="sxs-lookup"><span data-stu-id="f88f0-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="f88f0-153">Un *codificatore* implementa tale codifica ed è responsabile, sul <xref:System.ServiceModel.Channels.Message> lato mittente, per trasformare un in memoria in un flusso di byte o buffer di byte che può essere inviato attraverso la rete.</span><span class="sxs-lookup"><span data-stu-id="f88f0-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="f88f0-154">Sul lato destinatario, il codificatore trasforma una sequenza di byte in un messaggio in memoria.</span><span class="sxs-lookup"><span data-stu-id="f88f0-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="f88f0-155">WCF include tre codificatori e consente di scrivere e collegare i propri codificatori, se necessario.</span><span class="sxs-lookup"><span data-stu-id="f88f0-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="f88f0-156">Per impostazione predefinita, ognuna delle associazioni standard include un codificatore preconfigurato, pertanto le associazioni con il prefisso Net\* utilizzano il codificatore binario (inclusa la classe <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>) mentre le classi <xref:System.ServiceModel.BasicHttpBinding> e <xref:System.ServiceModel.WSHttpBinding> utilizzano il codificatore del messaggio di testo (mediante la classe <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>).</span><span class="sxs-lookup"><span data-stu-id="f88f0-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="f88f0-157">Elemento di associazione del codificatore</span><span class="sxs-lookup"><span data-stu-id="f88f0-157">Encoder binding element</span></span>|<span data-ttu-id="f88f0-158">Descrizione</span><span class="sxs-lookup"><span data-stu-id="f88f0-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="f88f0-159">Il codificatore del messaggio di testo è il codificatore predefinito per tutte le associazioni basate su HTTP e rappresenta la scelta giusta per tutte le associazioni personalizzate in cui l'interoperabilità ha la massima priorità.</span><span class="sxs-lookup"><span data-stu-id="f88f0-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="f88f0-160">Questo codificatore legge e scrive messaggi di testo SOAP 1.1/SOAP 1.2 standard senza gestire in modo particolare i dati binari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="f88f0-161">Se <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> la proprietà di un <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>messaggio è impostata su , il wrapper della busta SOAP viene omesso dall'output e viene serializzato solo il contenuto del corpo del messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="f88f0-162">Il codificatore dei messaggi MTOM è un codificatore di testo che implementa una gestione speciale per i dati binari e, per impostazione predefinita, non viene utilizzato nelle associazioni standard poiché è un'utilità di ottimizzazione che valuta caso per caso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="f88f0-163">Se il messaggio contiene dati binari che superano la soglia entro la quale la codifica MTOM produce un vantaggio, i dati vengono esternalizzati in una parte MIME che segue l'envelope del messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="f88f0-164">Vedere Attivazione di MTOM più avanti in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="f88f0-165">Il codificatore di messaggi binari è il codificatore predefinito per le associazioni Net e la scelta appropriata ogni volta che entrambe le parti comunicanti sono basate su WCF.</span><span class="sxs-lookup"><span data-stu-id="f88f0-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="f88f0-166">Il codificatore di messaggi binari utilizza il formato XML binario di .NET, una rappresentazione binaria specifica per Microsoft degli Infoset (set di informazioni XML) che generalmente produce un footprint più piccolo rispetto alla rappresentazione XML 1.0 equivalente e codifica dati binari come un flusso di byte.</span><span class="sxs-lookup"><span data-stu-id="f88f0-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="f88f0-167">La codifica dei messaggi di testo è in genere la scelta migliore per qualsiasi percorso di comunicazione che richiede interoperabilità, mentre la codifica dei messaggi binari è la scelta migliore per qualsiasi altro percorso di comunicazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="f88f0-168">La codifica dei messaggi binari in genere produce messaggi di dimensioni minori se confrontate al testo per un solo messaggio e progressivamente sempre minori nell'arco di una sessione di comunicazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="f88f0-169">A differenza della codifica di testo, la codifica binaria non deve gestire i dati binari in modo speciale, come nel caso della codifica Base64, ma rappresenta byte per byte.</span><span class="sxs-lookup"><span data-stu-id="f88f0-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="f88f0-170">Se la soluzione in uso non richiede l'interoperabilità, ma si desidera comunque utilizzare il trasporto HTTP, è possibile comporre <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> in un'associazione personalizzata che utilizza la classe <xref:System.ServiceModel.Channels.HttpTransportBindingElement> per il trasporto.</span><span class="sxs-lookup"><span data-stu-id="f88f0-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="f88f0-171">Se alcuni client del servizio richiedono l'interoperabilità, è consigliabile esporre endpoint paralleli per i quali siano abilitate le scelte di codifica e trasporto appropriate per i rispettivi client.</span><span class="sxs-lookup"><span data-stu-id="f88f0-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="f88f0-172">Attivazione di MTOM</span><span class="sxs-lookup"><span data-stu-id="f88f0-172">Enabling MTOM</span></span>  
 <span data-ttu-id="f88f0-173">Quando l'interoperabilità è essenziale e devono essere inviati dati binari di grandi dimensioni, la codifica dei messaggi MTOM è la strategia di codifica alternativa che può essere abilitata sulle associazioni <xref:System.ServiceModel.BasicHttpBinding> o <xref:System.ServiceModel.WSHttpBinding> standard impostando la rispettiva proprietà `MessageEncoding` su <xref:System.ServiceModel.WSMessageEncoding.Mtom> o componendo <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> in una classe <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="f88f0-174">Il codice di esempio seguente estratto dall'esempio [di codifica MTOM](../../../../docs/framework/wcf/samples/mtom-encoding.md) illustra come abilitare MTOM nella configurazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="f88f0-175">Come indicato in precedenza, la decisione di utilizzare la codifica MTOM dipende dal volume dei dati che si intende inviare.</span><span class="sxs-lookup"><span data-stu-id="f88f0-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="f88f0-176">Inoltre, poiché MTOM è abilitato a livello dell'associazione, l'attivazione di MTOM influisce su tutte le operazioni su un endpoint specificato.</span><span class="sxs-lookup"><span data-stu-id="f88f0-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="f88f0-177">Poiché il codificatore MTOM genera sempre un messaggio MIME/multipart con codifica MTOM indipendentemente dal fatto che i dati binari vengano o meno esternalizzati, è in genere consigliabile attivare MTOM solo per gli endpoint che scambiano messaggi contenenti più di 1 KB di dati binari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="f88f0-178">Inoltre, i contratti di servizio progettati per l'utilizzo con gli endpoint abilitati per MTOM devono, quando possibile, essere vincolati a specificare tali operazioni di trasferimento dati.</span><span class="sxs-lookup"><span data-stu-id="f88f0-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="f88f0-179">La relativa funzionalità di controllo deve essere basata su un contratto separato.</span><span class="sxs-lookup"><span data-stu-id="f88f0-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="f88f0-180">Questa regola che prevede l'abilitazione esclusiva di MTOM si applica solo a messaggi inviati tramite un endpoint abilitato per MTOM; il codificatore MTOM può decodificare e analizzare anche i messaggi non MTOM in arrivo.</span><span class="sxs-lookup"><span data-stu-id="f88f0-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="f88f0-181">L'utilizzo del codificatore MTOM è conforme a tutte le altre funzionalità WCF.</span><span class="sxs-lookup"><span data-stu-id="f88f0-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="f88f0-182">Si noti che in alcuni casi non è possibile osservare questa regola, ad esempio quando è richiesto il supporto della sessione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="f88f0-183">Modello di programmazione</span><span class="sxs-lookup"><span data-stu-id="f88f0-183">Programming Model</span></span>  
 <span data-ttu-id="f88f0-184">Indipendentemente da quale dei tre codificatori incorporati viene utilizzato nell'applicazione, l'esperienza di programmazione è identica per quanto concerne il trasferimento di dati binari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="f88f0-185">La differenza sta nel modo in cui WCF gestisce i dati in base ai relativi tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="f88f0-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="f88f0-186">Se si utilizza MTOM, il contratto dati precedente viene serializzato secondo le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="f88f0-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="f88f0-187">Se `binaryBuffer` non è `null` e contiene abbastanza dati per giustificare il sovraccarico di esternalizzazione di MTOM (intestazioni MIME e così via) rispetto alla codifica Base64, i dati vengono esternalizzati e trasportati con il messaggio come una parte MIME binaria.</span><span class="sxs-lookup"><span data-stu-id="f88f0-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="f88f0-188">Se la soglia non viene superata, i dati vengono codificati con il formato Base64.</span><span class="sxs-lookup"><span data-stu-id="f88f0-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="f88f0-189">La stringa (e tutti gli altri tipi non binari) viene sempre rappresentata come una stringa nel corpo del messaggio, indipendentemente dalle dimensioni.</span><span class="sxs-lookup"><span data-stu-id="f88f0-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="f88f0-190">Sia che si utilizzi un contratto dati esplicito, come illustrato nell'esempio precedente, un elenco di parametri in un'operazione, contratti dati annidati o si trasferisca un oggetto contratto dati in una raccolta, l'effetto sulla codifica MTOM è lo stesso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="f88f0-191">Le matrici di byte sono sempre candidate per l'ottimizzazione e vengono ottimizzate se le soglie di ottimizzazione vengono soddisfatte.</span><span class="sxs-lookup"><span data-stu-id="f88f0-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f88f0-192">Non utilizzare tipi derivati da <xref:System.IO.Stream?displayProperty=nameWithType> all'interno di contratti dati.</span><span class="sxs-lookup"><span data-stu-id="f88f0-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="f88f0-193">I dati del flusso devono essere comunicati utilizzando il modello di flusso, illustrato nella sezione "Flusso di dati" seguente.</span><span class="sxs-lookup"><span data-stu-id="f88f0-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="f88f0-194">Flusso di dati</span><span class="sxs-lookup"><span data-stu-id="f88f0-194">Streaming Data</span></span>  
 <span data-ttu-id="f88f0-195">Quando si dispone di una grande quantità di dati da trasferire, la modalità di trasferimento di flusso in WCF è un'alternativa fattibile al comportamento predefinito di memorizzazione nel buffer ed elaborazione dei messaggi in memoria nella loro interezza.</span><span class="sxs-lookup"><span data-stu-id="f88f0-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="f88f0-196">Come indicato in precedenza, attivare il flusso solo per i messaggi di grandi dimensioni (con contenuto di testo o binario) se i dati non possono essere segmentati, se il messaggio deve essere recapitato tempestivamente o se i dati non sono ancora completamente disponibili quando ha inizio il trasferimento.</span><span class="sxs-lookup"><span data-stu-id="f88f0-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="f88f0-197">Restrizioni</span><span class="sxs-lookup"><span data-stu-id="f88f0-197">Restrictions</span></span>  
 <span data-ttu-id="f88f0-198">Non è possibile usare un numero significativo di funzionalità WCF quando è abilitato il flusso:You cannot use a significant number of WCF features when streaming is enabled:</span><span class="sxs-lookup"><span data-stu-id="f88f0-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="f88f0-199">Non è possibile applicare firme digitali al corpo del messaggio poiché richiedono il calcolo di un hash sull'intero contenuto del messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="f88f0-200">Con il flusso, il contenuto non è completamente disponibile quando le intestazioni del messaggio vengono create e inviate e, pertanto, non è possibile calcolare una firma digitale.</span><span class="sxs-lookup"><span data-stu-id="f88f0-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="f88f0-201">Per verificare che i dati siano stati ricostruiti correttamente, la crittografia dipende dalle firme digitali.</span><span class="sxs-lookup"><span data-stu-id="f88f0-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="f88f0-202">Le sessioni affidabili devono memorizzare nel buffer i messaggi inviati sul client per riconsegnare un messaggio qualora si perda durante il trasferimento e devono trattenere i messaggi nel servizio prima di passarli all'implementazione del servizio per preservare l'ordine dei messaggi nel caso in cui i messaggi vengano ricevuti fuori sequenza.</span><span class="sxs-lookup"><span data-stu-id="f88f0-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="f88f0-203">A causa di questi vincoli funzionali, è possibile utilizzare solo opzioni di sicurezza a livello di trasporto per il flusso e non è possibile attivare sessioni affidabili.</span><span class="sxs-lookup"><span data-stu-id="f88f0-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="f88f0-204">Il flusso è disponibile solo con le associazioni definite dal sistema seguenti:</span><span class="sxs-lookup"><span data-stu-id="f88f0-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="f88f0-205">Perché i trasporti sottostanti di <xref:System.ServiceModel.NetTcpBinding> e <xref:System.ServiceModel.NetNamedPipeBinding> possono contare sul recapito affidabile inerente e sul supporto della sessione basato sulla connessione, a differenza di HTTP, in pratica questi vincoli influiscono minimamente su queste due associazioni.</span><span class="sxs-lookup"><span data-stu-id="f88f0-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="f88f0-206">Il flusso non è disponibile con il trasporto dell'accodamento messaggi (MSMQ) e pertanto non può essere utilizzato con la classe <xref:System.ServiceModel.NetMsmqBinding> o <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="f88f0-207">Il trasporto dell'accodamento messaggi supporta solo i trasferimenti di dati memorizzati nel buffer con dimensioni di messaggio vincolate, mentre tutti gli altri trasporti non presentano pressoché alcun limite alle dimensioni dei messaggi per la maggior parte degli scenari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="f88f0-208">Il flusso non è disponibile neanche in caso di utilizzo del trasporto del canale peer, pertanto non è disponibile con <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="f88f0-209">Sessioni e flusso</span><span class="sxs-lookup"><span data-stu-id="f88f0-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="f88f0-210">È possibile ricevere un comportamento imprevisto quando viene eseguito il flusso delle chiamate con un'associazione basata sulla sessione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="f88f0-211">Tutte le chiamate del flusso sono eseguite tramite un solo canale (il canale del datagramma) che non supporta sessioni anche se l'associazione utilizzata è configurata per utilizzare sessioni.</span><span class="sxs-lookup"><span data-stu-id="f88f0-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="f88f0-212">Se più client effettuano un flusso di chiamate allo stesso oggetto servizio con un'associazione basata sulla sessione e la modalità di concorrenza dell'oggetto servizio è impostata su singola e la modalità di contesto dell'istanza è impostata su PerSession, tutte le chiamate devono transitare attraverso il canale del datagramma, pertanto viene elaborata una sola chiamata alla volta.</span><span class="sxs-lookup"><span data-stu-id="f88f0-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="f88f0-213">Uno o più client potrebbero quindi scivolersi. È possibile risolvere questo problema impostando la modalità di contesto di istanza dell'oggetto servizio su PerCall o Concorrenza su Multiplo.</span><span class="sxs-lookup"><span data-stu-id="f88f0-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f88f0-214">In questo caso, MaxConcurrentSessions non ha effetto perché è disponibile una sola "sessione".</span><span class="sxs-lookup"><span data-stu-id="f88f0-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="f88f0-215">Abilitazione del flusso</span><span class="sxs-lookup"><span data-stu-id="f88f0-215">Enabling Streaming</span></span>  
 <span data-ttu-id="f88f0-216">È possibile abilitare il flusso nei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="f88f0-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="f88f0-217">Inviare e accettare richieste in modalità flusso, e accettare e restituire risposte in modalità di memorizzazione nel buffer (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="f88f0-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="f88f0-218">Inviare e accettare richieste in modalità di memorizzazione nel buffer, e accettare e restituire risposte in modalità flusso (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="f88f0-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="f88f0-219">Inviare e ricevere richieste e risposte in modalità flusso in entrambe le direzioni</span><span class="sxs-lookup"><span data-stu-id="f88f0-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="f88f0-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="f88f0-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="f88f0-221">È possibile disabilitare il flusso impostando la modalità di trasferimento su <xref:System.ServiceModel.TransferMode.Buffered>, ovvero l'impostazione predefinita per tutte le associazioni.</span><span class="sxs-lookup"><span data-stu-id="f88f0-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="f88f0-222">Nel codice seguente viene illustrato come impostare la modalità di trasferimento nella configurazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="f88f0-223">Quando si crea un'istanza dell'associazione nel codice, è necessario impostare la rispettiva proprietà `TransferMode` dell'associazione (o l'elemento di associazione del trasporto per la composizione di un'associazione personalizzata) su uno dei valori indicati precedentemente.</span><span class="sxs-lookup"><span data-stu-id="f88f0-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="f88f0-224">È possibile attivare il flusso per le richieste e le risposte o per entrambe le direzioni in modo indipendente su una delle parti in comunicazione senza influire sulla funzionalità.</span><span class="sxs-lookup"><span data-stu-id="f88f0-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="f88f0-225">Tuttavia, è necessario presupporre sempre che la dimensione dei dati trasferita sia talmente significativa da giustificare l'abilitazione del flusso su entrambi gli endpoint di un collegamento di comunicazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="f88f0-226">Per la comunicazione multipiattaforma in cui uno degli endpoint non è implementato con WCF, la possibilità di utilizzare lo streaming dipende dalle funzionalità di streaming della piattaforma.</span><span class="sxs-lookup"><span data-stu-id="f88f0-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="f88f0-227">Un'altra eccezione rara potrebbe essere un scenario incentrato sul consumo di memoria dove un client o un servizio devono ridurre al minimo il working set e possono permettersi solo buffer di piccole dimensioni.</span><span class="sxs-lookup"><span data-stu-id="f88f0-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="f88f0-228">Abilitazione del flusso asincrono</span><span class="sxs-lookup"><span data-stu-id="f88f0-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="f88f0-229">Per abilitare il flusso asincrono, aggiungere il comportamento dell'endpoint <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> all'host del servizio e impostare la relativa proprietà <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> su `true`.</span><span class="sxs-lookup"><span data-stu-id="f88f0-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="f88f0-230">Inoltre è stata aggiunta la funzionalità di un vero flusso asincrono sul lato di invio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="f88f0-231">In questo modo si migliora la scalabilità del servizio negli scenari in cui vengono trasmessi messaggi a più client, alcuni dei quali sono lenti nella lettura, probabilmente a causa della congestione della rete, o non effettuano l'operazione.</span><span class="sxs-lookup"><span data-stu-id="f88f0-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="f88f0-232">In questi scenari, non vengono bloccati i singoli thread sul servizio per client.</span><span class="sxs-lookup"><span data-stu-id="f88f0-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="f88f0-233">In questo modo si assicura che il servizio possa elaborare molti più client, migliorando pertanto la scalabilità del servizio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="f88f0-234">Modello di programmazione per i trasferimenti in flussi</span><span class="sxs-lookup"><span data-stu-id="f88f0-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="f88f0-235">Il modello di programmazione per il flusso è semplice.</span><span class="sxs-lookup"><span data-stu-id="f88f0-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="f88f0-236">Per ricevere flussi di dati, specificare un contratto di operazione con un solo parametro di input tipizzato <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="f88f0-237">Per restituire flussi di dati, restituire un riferimento <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="f88f0-238">L'operazione `Echo` nell'esempio precedente riceve e restituisce un flusso e deve pertanto essere utilizzato su un'associazione con <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="f88f0-239">Per l'operazione `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> è la soluzione ideale, in quanto restituisce solo un <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="f88f0-240">L'operazione unidirezionale è particolarmente indicata per <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="f88f0-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="f88f0-241">Si noti che aggiungendo un secondo parametro alle operazioni `Echo` o `ProvideInfo` successive, il modello di servizio deve ripristinare una strategia di memorizzazione nel buffer e utilizzare la rappresentazione della serializzazione di runtime del flusso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="f88f0-242">Solo le operazioni con un singolo parametro di input del flusso sono compatibili con flusso di richiesta end-to-end.</span><span class="sxs-lookup"><span data-stu-id="f88f0-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="f88f0-243">Questa regola si applica in modo analogo ai contratti di messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="f88f0-244">Come illustrato nel contratto di messaggio seguente, un solo membro del corpo nel contratto del messaggio può essere un flusso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="f88f0-245">Se si desidera comunicare informazioni aggiuntive con il flusso, queste informazioni devono essere incluse nelle intestazioni del messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="f88f0-246">Il corpo del messaggio è riservato esclusivamente al contenuto del flusso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="f88f0-247">Il trasferimento del flusso termina e il messaggio viene chiuso quando il flusso raggiunge la fine del file.</span><span class="sxs-lookup"><span data-stu-id="f88f0-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="f88f0-248">Quando si invia un messaggio (restituendo un valore <xref:System.IO.FileStream> o richiamando un'operazione), è possibile passare un e l'infrastruttura WCF successivamente estrae tutti i dati da tale flusso fino a quando il flusso è stato completamente letto e raggiunto EOF.</span><span class="sxs-lookup"><span data-stu-id="f88f0-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="f88f0-249">Per trasferire flussi di dati per l'origine se non esiste una classe derivata <xref:System.IO.Stream> predefinita, costruire tale classe, sovrapporla all'origine del flusso e utilizzarla come argomento o valore restituito.</span><span class="sxs-lookup"><span data-stu-id="f88f0-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="f88f0-250">Quando si riceve un messaggio, WCF costruisce un flusso sul contenuto del corpo del messaggio con codifica Base64 (o la rispettiva parte MIME se si utilizza MTOM) e il flusso raggiunge EOF quando il contenuto è stato letto.</span><span class="sxs-lookup"><span data-stu-id="f88f0-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="f88f0-251">Il flusso a livello di trasporto funziona anche con qualsiasi altro tipo di contratto di messaggio (elenchi di parametri, argomenti del contratto dati e contratto di messaggio esplicito), ma poiché la serializzazione e deserializzazione di questi tipi di messaggi richiede la memorizzazione nel buffer da parte del serializzatore, l'utilizzo di tali varianti di contratto non è consigliabile.</span><span class="sxs-lookup"><span data-stu-id="f88f0-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="f88f0-252">Considerazioni speciali sulla protezione per i dati di grandi dimensioni</span><span class="sxs-lookup"><span data-stu-id="f88f0-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="f88f0-253">Tutte le associazioni consentono di vincolare le dimensioni dei messaggi in arrivo per impedire attacchi Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="f88f0-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="f88f0-254">La <xref:System.ServiceModel.BasicHttpBinding>proprietà [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize , ad esempio, espone una proprietà System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) che delimita la dimensione del messaggio in arrivo e pertanto delimita anche la quantità massima di memoria a cui si accede durante l'elaborazione del messaggio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="f88f0-255">Questa unità è indicata in byte con un valore predefinito di 65.536 byte.</span><span class="sxs-lookup"><span data-stu-id="f88f0-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="f88f0-256">Un rischio per la sicurezza specifico per gli scenari con flussi di dati di grandi dimensioni provoca un attacco Denial of Service che causa la memorizzazione nel buffer dei dati mentre il destinatario si aspetta che vengano trasmessi in un flusso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="f88f0-257">Ad esempio, WCF memorizza sempre nel buffer le intestazioni SOAP di un messaggio e pertanto un utente malintenzionato può costruire un messaggio dannoso di grandi dimensioni costituito interamente da intestazioni per forzare i dati da memorizzare nel buffer.</span><span class="sxs-lookup"><span data-stu-id="f88f0-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="f88f0-258">Quando il flusso è abilitato, è possibile che `MaxReceivedMessageSize` sia impostato su un valore estremamente elevato, perché il destinatario non si aspetta che l'intero messaggio venga memorizzato immediatamente nel buffer in memoria.</span><span class="sxs-lookup"><span data-stu-id="f88f0-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="f88f0-259">Se WCF è costretto a memorizzare nel buffer il messaggio, si verifica un overflow della memoria.</span><span class="sxs-lookup"><span data-stu-id="f88f0-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="f88f0-260">Di conseguenza, limitare le dimensioni massime del messaggio in arrivo non è sufficiente in questo caso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="f88f0-261">La `MaxBufferSize` proprietà è necessaria per vincolare la memoria memorizzata nel buffer WCF.</span><span class="sxs-lookup"><span data-stu-id="f88f0-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="f88f0-262">È importante impostare questa proprietà su un valore sicuro (o lasciare il valore predefinito) per il flusso.</span><span class="sxs-lookup"><span data-stu-id="f88f0-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="f88f0-263">Ad esempio, si supponga che il servizio debba ricevere file di dimensioni fino a 4 GB e debba archiviarli sul disco locale.</span><span class="sxs-lookup"><span data-stu-id="f88f0-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="f88f0-264">Si supponga inoltre che la memoria sia vincolata in modo da poter memorizzare nel buffer solo 64 KB di dati per volta.</span><span class="sxs-lookup"><span data-stu-id="f88f0-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="f88f0-265">In tal caso, è necessario impostare `MaxReceivedMessageSize` su 4 GB e `MaxBufferSize` su 64 KB.</span><span class="sxs-lookup"><span data-stu-id="f88f0-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="f88f0-266">Inoltre, nell'implementazione del servizio è necessario verificare di poter eseguire solo la lettura dal flusso in ingresso in blocchi di 64 KB, impedendo la lettura del blocco successivo prima che il precedente sia stato scritto su disco ed eliminato dalla memoria.</span><span class="sxs-lookup"><span data-stu-id="f88f0-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="f88f0-267">È inoltre importante comprendere che questa quota limita solo il buffering eseguito da WCF e non può proteggerti da qualsiasi buffering che si esegue nel proprio servizio o nell'implementazione client.</span><span class="sxs-lookup"><span data-stu-id="f88f0-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="f88f0-268">Per ulteriori informazioni sulle considerazioni aggiuntive sulla sicurezza, vedere [Considerazioni sulla sicurezza per](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)i dati .</span><span class="sxs-lookup"><span data-stu-id="f88f0-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f88f0-269">La scelta di utilizzare trasferimenti memorizzati nel buffer o in flussi è una decisione specifica dell'endpoint.</span><span class="sxs-lookup"><span data-stu-id="f88f0-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="f88f0-270">Per i trasporti HTTP, la modalità di trasferimento non si propaga attraverso una connessione o ai server proxy e agli altri intermediari.</span><span class="sxs-lookup"><span data-stu-id="f88f0-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="f88f0-271">L'impostazione della modalità di trasferimento non si riflette nella descrizione dell'interfaccia del servizio.</span><span class="sxs-lookup"><span data-stu-id="f88f0-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="f88f0-272">Dopo aver generato un client WCF a un servizio, è necessario modificare il file di configurazione per i servizi destinati a essere utilizzati con trasferimenti trasmessi per impostare la modalità.</span><span class="sxs-lookup"><span data-stu-id="f88f0-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="f88f0-273">Per i trasporti TCP e named pipe, la modalità di trasferimento viene propagata come asserzione di criteri.</span><span class="sxs-lookup"><span data-stu-id="f88f0-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f88f0-274">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f88f0-274">See also</span></span>

- [<span data-ttu-id="f88f0-275">Procedura: attivare il flusso</span><span class="sxs-lookup"><span data-stu-id="f88f0-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
