---
title: Procedure consigliate per l'ottimizzazione dell'affidabilità
description: Vedere le procedure consigliate per l'affidabilità nelle applicazioni server basate su host .NET, ad esempio SQL Server. Impedire che si verifichino perdite di risorse o che vengano arrestate.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474241"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="a6798-104">Procedure consigliate per l'ottimizzazione dell'affidabilità</span><span class="sxs-lookup"><span data-stu-id="a6798-104">Reliability Best Practices</span></span>

<span data-ttu-id="a6798-105">Le regole seguenti relative all'affidabilità riguardano specificamente SQL Server, ma sono valide anche per qualsiasi applicazione server basata su host.</span><span class="sxs-lookup"><span data-stu-id="a6798-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="a6798-106">È molto importante che nei server, ad esempio SQL Server, non si verifichino problemi di perdita di risorse e arresto.</span><span class="sxs-lookup"><span data-stu-id="a6798-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="a6798-107">Non è tuttavia possibile ottenere questo risultato scrivendo codice di annullamento per ogni metodo che modifica lo stato di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="a6798-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="a6798-108">L'obiettivo da raggiungere non è quello di scrivere codice gestito completamente affidabile, in grado di eseguire il ripristino da qualsiasi errore in qualunque posizione tramite codice di annullamento.</span><span class="sxs-lookup"><span data-stu-id="a6798-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="a6798-109">Sarebbe un'attività estremamente impegnativa con scarse probabilità di successo.</span><span class="sxs-lookup"><span data-stu-id="a6798-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="a6798-110">Common Language Runtime (CLR) non è sempre in grado di offrire garanzie sufficienti per il codice gestito per consentire di scrivere codice perfetto.</span><span class="sxs-lookup"><span data-stu-id="a6798-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="a6798-111">Inoltre, a differenza di ASP.NET, SQL Server usa un solo processo che non può essere riciclato senza disattivare il database per un periodo di tempo eccessivamente lungo.</span><span class="sxs-lookup"><span data-stu-id="a6798-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="a6798-112">In considerazione delle garanzie limitate di CLR e dell'esecuzione di SQL Server in un unico processo, l'affidabilità si basa sull'interruzione dei thread o sul riciclo dei domini delle applicazioni, quando necessario, oltre che sull'adozione di precauzioni per evitare la perdita di risorse del sistema operativo, come handle o memoria.</span><span class="sxs-lookup"><span data-stu-id="a6798-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="a6798-113">Anche in questo modo, comunque, i requisiti per l'affidabilità rimangono rilevanti:</span><span class="sxs-lookup"><span data-stu-id="a6798-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="a6798-114">Non devono mai verificarsi perdite di risorse del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="a6798-115">Tutti i blocchi gestiti, in qualsiasi formato, devono essere identificati in CLR.</span><span class="sxs-lookup"><span data-stu-id="a6798-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="a6798-116">Lo stato condiviso tra domini delle applicazioni non deve mai essere interrotto, in modo da consentire un facile funzionamento del riciclo di <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="a6798-117">Anche se a livello teorico è possibile scrivere codice gestito per gestire le eccezioni <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> e <xref:System.OutOfMemoryException>, non è ragionevole aspettarsi che gli sviluppatori scrivano codice con un tale livello di affidabilità per un'intera applicazione.</span><span class="sxs-lookup"><span data-stu-id="a6798-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="a6798-118">Per questo motivo, le eccezioni fuori banda determinano l'interruzione del thread in esecuzione. Se il thread interrotto sta modificando uno stato condiviso, come si può capire dal fatto che il thread applica un blocco, l'oggetto <xref:System.AppDomain> viene scaricato.</span><span class="sxs-lookup"><span data-stu-id="a6798-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="a6798-119">Quando un metodo che sta modificando lo stato condiviso viene terminato, lo stato risulta danneggiato perché non è possibile scrivere codice di annullamento affidabile per gli aggiornamenti dello stato condiviso.</span><span class="sxs-lookup"><span data-stu-id="a6798-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="a6798-120">In .NET Framework versione 2.0 l'unico host che presenta requisiti di affidabilità è SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="a6798-121">Se l'assembly è destinato all'esecuzione su SQL Server, è opportuno verificare che i requisiti di affidabilità siano soddisfatti per ogni parte dell'assembly, anche se è prevista la disabilitazione di funzionalità specifiche durante l'esecuzione nel database.</span><span class="sxs-lookup"><span data-stu-id="a6798-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="a6798-122">Questa verifica è necessaria perché il motore di analisi del codice esamina il codice a livello di assembly e non è in grado di distinguere il codice disabilitato.</span><span class="sxs-lookup"><span data-stu-id="a6798-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="a6798-123">In ambito di programmazione per SQL Server è anche necessario tenere presente che SQL Server esegue tutti i componenti in un unico processo e che il riciclo di <xref:System.AppDomain> viene usato per la pulizia di tutte le risorse, come la memoria e gli handle del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="a6798-124">Per il codice di annullamento, non è possibile basarsi su finalizzatori, distruttori o blocchi `try/finally`.</span><span class="sxs-lookup"><span data-stu-id="a6798-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="a6798-125">Questi elementi potrebbero venire interrotti o non venire chiamati.</span><span class="sxs-lookup"><span data-stu-id="a6798-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="a6798-126">Possono venire generate eccezioni asincrone in posizioni impreviste, ipoteticamente in ogni istruzione del linguaggio macchina: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> e <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="a6798-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="a6798-127">I thread gestiti non sono necessariamente thread Win32 in SQL, ma possono anche essere fiber.</span><span class="sxs-lookup"><span data-stu-id="a6798-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="a6798-128">La modifica dello stato condiviso modificabile tra domini delle applicazioni o a livello di processo è un'operazione estremamente rischiosa e deve essere evitata, quando possibile.</span><span class="sxs-lookup"><span data-stu-id="a6798-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="a6798-129">Le condizioni di memoria insufficiente non sono rare in SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="a6798-130">Se le librerie ospitate in SQL Server non aggiornano correttamente il loro stato condiviso, è molto probabile che il codice non venga ripristinato fino al riavvio del database.</span><span class="sxs-lookup"><span data-stu-id="a6798-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="a6798-131">In alcuni casi estremi, ciò potrebbe provocare un errore nel processo SQL Server e, di conseguenza, il riavvio del database.</span><span class="sxs-lookup"><span data-stu-id="a6798-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="a6798-132">Il riavvio del database può rendere non disponibile un sito Web o può influire sui processi operativi aziendali, con effetti negativi sulla disponibilità.</span><span class="sxs-lookup"><span data-stu-id="a6798-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="a6798-133">Una perdita lenta di risorse del sistema operativo, come handle o memoria, può impedire al server di allocare gli handle, senza alcuna possibilità di ripristino, oppure può determinare una lenta riduzione delle prestazioni del server e della disponibilità delle applicazioni dei clienti.</span><span class="sxs-lookup"><span data-stu-id="a6798-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="a6798-134">È chiaramente opportuno evitare scenari di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="a6798-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="a6798-135">Regole procedure consigliate</span><span class="sxs-lookup"><span data-stu-id="a6798-135">Best practice rules</span></span>

<span data-ttu-id="a6798-136">Nell'introduzione è stato illustrato cosa è necessario intercettare con la revisione del codice gestito in esecuzione nel server per aumentare la stabilità e l'affidabilità del framework.</span><span class="sxs-lookup"><span data-stu-id="a6798-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="a6798-137">Tutti questi controlli, che sono in genere consigliati in qualsiasi situazione, sono indispensabili nel server.</span><span class="sxs-lookup"><span data-stu-id="a6798-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="a6798-138">In caso di deadlock o di vincoli delle risorse, SQL Server interrompe un thread o elimina un oggetto <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="a6798-139">Quando ciò accade, è garantita solo l'esecuzione del codice di annullamento in un'area a esecuzione vincolata (CER, Constrained Execution Region).</span><span class="sxs-lookup"><span data-stu-id="a6798-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="a6798-140">Utilizzare SafeHandle per evitare perdite di risorse</span><span class="sxs-lookup"><span data-stu-id="a6798-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="a6798-141">In caso di scaricamento di un oggetto <xref:System.AppDomain>, non è possibile dipendere da blocchi `finally` o dall'esecuzione di finalizzatori, quindi è importante astrarre l'accesso a tutte le risorse del sistema operativo tramite la classe <xref:System.Runtime.InteropServices.SafeHandle> invece di <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> o classi simili.</span><span class="sxs-lookup"><span data-stu-id="a6798-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="a6798-142">In questo modo, CLR può tenere traccia degli handle usati e chiuderli, anche in caso di eliminazione di <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="a6798-143"><xref:System.Runtime.InteropServices.SafeHandle> userà un finalizzatore critico, che verrà sempre eseguito da CLR.</span><span class="sxs-lookup"><span data-stu-id="a6798-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="a6798-144">L'handle del sistema operativo rimane archiviato nell'handle Safe dal momento della creazione fino a quello del rilascio.</span><span class="sxs-lookup"><span data-stu-id="a6798-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="a6798-145">In nessun momento può verificarsi un'eccezione <xref:System.Threading.ThreadAbortException> con perdita di un handle.</span><span class="sxs-lookup"><span data-stu-id="a6798-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="a6798-146">Inoltre, la funzionalità platform invoke eseguirà il conteggio dei riferimenti dell'handle, consentendo di tenerne traccia per l'intera durata dell'handle e impedendo un eventuale problema di sicurezza dovuto a una race condition tra `Dispose` e un metodo che fa attualmente uso dell'handle.</span><span class="sxs-lookup"><span data-stu-id="a6798-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="a6798-147">La maggior parte delle classi che attualmente hanno un finalizzatore solo per eliminare un handle del sistema operativo non ne avrà più bisogno.</span><span class="sxs-lookup"><span data-stu-id="a6798-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="a6798-148">Il finalizzatore sarà invece incluso nella classe derivata <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="a6798-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="a6798-149">Si noti che <xref:System.Runtime.InteropServices.SafeHandle> non sostituisce <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a6798-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="a6798-150">L'eliminazione esplicita delle risorse del sistema operativo offre ancora potenziali vantaggi in termini di prestazioni e di risoluzione di conflitti di risorse.</span><span class="sxs-lookup"><span data-stu-id="a6798-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="a6798-151">Basta considerare che i blocchi `finally` che eseguono l'eliminazione esplicita delle risorse potrebbero non venire eseguiti completamente.</span><span class="sxs-lookup"><span data-stu-id="a6798-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="a6798-152"><xref:System.Runtime.InteropServices.SafeHandle> consente di implementare un metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> che esegue le operazioni appropriate per liberare l'handle, ad esempio passando lo stato a una routine di rilascio degli handle del sistema operativo oppure liberando un set di handle in un ciclo.</span><span class="sxs-lookup"><span data-stu-id="a6798-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="a6798-153">L'esecuzione di questo metodo è garantita da CLR.</span><span class="sxs-lookup"><span data-stu-id="a6798-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="a6798-154">È responsabilità dell'autore dell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> garantire che l'handle venga rilasciato in qualsiasi circostanza.</span><span class="sxs-lookup"><span data-stu-id="a6798-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="a6798-155">In caso contrario, l'handle andrà perso e ciò spesso causa una perdita delle risorse native associate all'handle.</span><span class="sxs-lookup"><span data-stu-id="a6798-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="a6798-156">È quindi fondamentale strutturare le classi derivate di <xref:System.Runtime.InteropServices.SafeHandle> in modo che l'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non richieda l'allocazione di alcuna risorsa che potrebbe non essere disponibile al momento della chiamata.</span><span class="sxs-lookup"><span data-stu-id="a6798-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="a6798-157">Si noti che è consentito chiamare metodi che possono generare errori nell'ambito dell'implementazione di <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, a condizione che il codice possa gestire tali errori e rispettare il contratto per rilasciare l'handle nativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="a6798-158">Ai fini del debug, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> restituisce un valore <xref:System.Boolean>, che può essere impostato su `false` qualora si verifichi un errore irreversibile che impedisce il rilascio della risorsa.</span><span class="sxs-lookup"><span data-stu-id="a6798-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="a6798-159">In questo modo, verrà attivato l'assistente al debug gestito [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md), se abilitato, per aiutare nell'identificazione del problema.</span><span class="sxs-lookup"><span data-stu-id="a6798-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="a6798-160">Non ci saranno altri effetti sul runtime. Il metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> non verrà chiamato di nuovo per la stessa risorsa e, di conseguenza, l'handle andrà perso.</span><span class="sxs-lookup"><span data-stu-id="a6798-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="a6798-161">L'oggetto <xref:System.Runtime.InteropServices.SafeHandle> non è appropriato in determinati contesti.</span><span class="sxs-lookup"><span data-stu-id="a6798-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="a6798-162">Poiché il metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> può essere eseguito in un thread finalizzatore <xref:System.GC>, non è opportuno eseguire il wrapping in un oggetto <xref:System.Runtime.InteropServices.SafeHandle> degli handle che devono essere rilasciati in un thread specifico.</span><span class="sxs-lookup"><span data-stu-id="a6798-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="a6798-163">Gli oggetti Runtime Callable Wrapper (RCW) possono essere eliminati da CLR senza codice aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="a6798-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="a6798-164">Il codice che usa platform invoke e tratta un oggetto COM come `IUnknown*` o <xref:System.IntPtr> deve essere riscritto in modo da usare un oggetto RCW.</span><span class="sxs-lookup"><span data-stu-id="a6798-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="a6798-165">L'oggetto <xref:System.Runtime.InteropServices.SafeHandle> potrebbe non essere adatto in questo scenario a causa di un possibile callback al codice gestito da parte di un metodo di rilascio non gestito.</span><span class="sxs-lookup"><span data-stu-id="a6798-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-166">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-166">Code analysis rule</span></span>

<span data-ttu-id="a6798-167">Usare <xref:System.Runtime.InteropServices.SafeHandle> per incapsulare le risorse del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="a6798-168">Non usare <xref:System.Runtime.InteropServices.HandleRef> o campi di tipo <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="a6798-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="a6798-169">Verificare che non sia necessario eseguire i finalizzatori per evitare perdite di risorse del sistema operativo</span><span class="sxs-lookup"><span data-stu-id="a6798-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="a6798-170">Esaminare accuratamente i finalizzatori per accertarsi che, anche se non vengono eseguiti, non si verifichi la perdita di una risorsa critica del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="a6798-171">A differenza di quanto avviene durante il normale scaricamento di <xref:System.AppDomain> quando l'applicazione è in esecuzione in uno stato stabile o quando viene arrestato un server, come SQL Server, durante uno scaricamento improvviso di <xref:System.AppDomain>, gli oggetti non vengono finalizzati.</span><span class="sxs-lookup"><span data-stu-id="a6798-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="a6798-172">Assicurarsi che non si verifichi una perdita di risorse in caso di scaricamento improvviso, perché la corretta esecuzione di un'applicazione non può essere garantita, ma è indispensabile che venga mantenuta l'integrità del server evitando la perdita di risorse.</span><span class="sxs-lookup"><span data-stu-id="a6798-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="a6798-173">Usare <xref:System.Runtime.InteropServices.SafeHandle> per liberare le risorse del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="a6798-174">Verificare che non sia necessario eseguire le clausole finally per evitare perdite di risorse del sistema operativo</span><span class="sxs-lookup"><span data-stu-id="a6798-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="a6798-175">Poiché non è possibile garantire che le clausole `finally` vengano eseguite fuori dalle aree a esecuzione vincolata, gli sviluppatori di librerie non devono basarsi sul codice all'interno di un blocco `finally` per liberare le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="a6798-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="a6798-176">A questo scopo, si consiglia di usare <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="a6798-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-177">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-177">Code analysis rule</span></span>

<span data-ttu-id="a6798-178">Per la pulizia delle risorse del sistema operativo, usare <xref:System.Runtime.InteropServices.SafeHandle> invece di `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="a6798-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="a6798-179">Non usare <xref:System.IntPtr>. Usare <xref:System.Runtime.InteropServices.SafeHandle> per incapsulare le risorse.</span><span class="sxs-lookup"><span data-stu-id="a6798-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="a6798-180">Se è necessario eseguire la clausola finally, inserirla in un'area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="a6798-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="a6798-181">Tutti i blocchi devono passare attraverso il codice di blocco gestito esistente</span><span class="sxs-lookup"><span data-stu-id="a6798-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="a6798-182">CLR deve essere in grado di identificare i casi di blocco del codice, in modo da stabilire se procedere all'eliminazione dell'oggetto <xref:System.AppDomain> invece di interrompere semplicemente il thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="a6798-183">L'interruzione del thread può risultare pericolosa perché i dati elaborati dal thread possono rimanere in uno stato incoerente.</span><span class="sxs-lookup"><span data-stu-id="a6798-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="a6798-184">È pertanto necessario riciclare l'intero oggetto <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="a6798-185">La mancata identificazione di un blocco può causare deadlock o risultati non corretti.</span><span class="sxs-lookup"><span data-stu-id="a6798-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="a6798-186">Per identificare le aree di blocco, usare i metodi <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="a6798-187">Si tratta di metodi statici inclusi nella classe <xref:System.Threading.Thread> che si applicano solo al thread corrente e aiutano a impedire che un thread modifichi il conteggio dei blocchi di un altro thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="a6798-188">Poiché <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> hanno questa notifica CLR incorporata, si consiglia il loro uso. Lo stesso vale per l'[istruzione lock](../../csharp/language-reference/keywords/lock-statement.md), che usa questi metodi.</span><span class="sxs-lookup"><span data-stu-id="a6798-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="a6798-189">Gli altri meccanismi di blocco, ad esempio gli spinlock e l'oggetto <xref:System.Threading.AutoResetEvent>, devono chiamare questi metodi per notificare a CLR l'ingresso in una sezione critica.</span><span class="sxs-lookup"><span data-stu-id="a6798-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="a6798-190">Questi metodi non acquisiscono alcun blocco, ma informano CLR che il codice è in esecuzione in una sezione critica e che l'interruzione del thread può causare problemi di incoerenza dello stato condiviso.</span><span class="sxs-lookup"><span data-stu-id="a6798-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="a6798-191">Se è stato definito un tipo di blocco specifico, ad esempio una classe <xref:System.Threading.ReaderWriterLock> personalizzata, usare questi metodi di conteggio dei blocchi.</span><span class="sxs-lookup"><span data-stu-id="a6798-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-192">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-192">Code analysis rule</span></span>

<span data-ttu-id="a6798-193">Contrassegnare e identificare tutti i blocchi usando <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="a6798-194">Non usare <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A> in un ciclo.</span><span class="sxs-lookup"><span data-stu-id="a6798-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="a6798-195">Non eseguire platform invoke per le varianti Win32 di questi metodi.</span><span class="sxs-lookup"><span data-stu-id="a6798-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="a6798-196">Non usare <xref:System.Threading.Thread.Sleep%2A> in un ciclo.</span><span class="sxs-lookup"><span data-stu-id="a6798-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="a6798-197">Non usare campi volatili.</span><span class="sxs-lookup"><span data-stu-id="a6798-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="a6798-198">Il codice di pulizia deve trovarsi in un blocco finally o catch, non dopo un catch</span><span class="sxs-lookup"><span data-stu-id="a6798-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="a6798-199">Il codice di pulizia non deve mai seguire un blocco `catch`, ma deve essere inserito in un blocco `finally` o nel blocco `catch` stesso.</span><span class="sxs-lookup"><span data-stu-id="a6798-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="a6798-200">Questa dovrebbe essere la normale procedura da seguire.</span><span class="sxs-lookup"><span data-stu-id="a6798-200">This should be a normal good practice.</span></span> <span data-ttu-id="a6798-201">Un blocco `finally` è in genere preferibile perché esegue lo stesso codice sia quando viene generata un'eccezione che quando viene raggiunta normalmente la fine del blocco `try`.</span><span class="sxs-lookup"><span data-stu-id="a6798-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="a6798-202">Se viene generata un'eccezione imprevista, ad esempio <xref:System.Threading.ThreadAbortException>, il codice di pulizia non viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="a6798-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="a6798-203">Per evitare perdite, è opportuno eseguire il wrapping in un oggetto <xref:System.Runtime.InteropServices.SafeHandle> delle risorse non gestite di cui viene normalmente eseguita la pulizia in un blocco `finally`.</span><span class="sxs-lookup"><span data-stu-id="a6798-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="a6798-204">Si noti che per eliminare in modo efficace gli oggetti, inclusi gli handle, è possibile usare la parola chiave `using` C#.</span><span class="sxs-lookup"><span data-stu-id="a6798-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="a6798-205">Anche se il riciclo di <xref:System.AppDomain> può pulire le risorse sul thread finalizzatore, è comunque importante inserire il codice di pulizia nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="a6798-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="a6798-206">Si noti che, se un thread riceve un'eccezione asincrona senza applicare un blocco, CLR tenta di terminare il thread senza eseguire il riciclo di <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="a6798-207">Assicurarsi che la pulizia delle risorse avvenga il prima possibile per aumentarne la disponibilità e gestire meglio la durata.</span><span class="sxs-lookup"><span data-stu-id="a6798-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="a6798-208">Se non si chiude in modo esplicito l'handle di un file in un percorso di codice di errore e si attende la pulizia da parte del finalizzatore <xref:System.Runtime.InteropServices.SafeHandle>, alla successiva esecuzione, il codice potrebbe non riuscire ad accedere allo stesso file se il finalizzatore non è già stato eseguito.</span><span class="sxs-lookup"><span data-stu-id="a6798-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="a6798-209">Per questo motivo è opportuno, anche se non obbligatorio, verificare che il codice di pulizia sia presente e funzioni correttamente, in modo da consentire un ripristino più semplice e veloce dagli errori.</span><span class="sxs-lookup"><span data-stu-id="a6798-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-210">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-210">Code analysis rule</span></span>

<span data-ttu-id="a6798-211">Il codice di pulizia dopo `catch` deve trovarsi in un blocco `finally`.</span><span class="sxs-lookup"><span data-stu-id="a6798-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="a6798-212">Inserire le chiamate per l'eliminazione delle risorse in un blocco finally.</span><span class="sxs-lookup"><span data-stu-id="a6798-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="a6798-213">I blocchi `catch` devono terminare in un elemento throw o rethrow.</span><span class="sxs-lookup"><span data-stu-id="a6798-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="a6798-214">Anche se verranno generate eccezioni, ad esempio durante la verifica della possibilità di stabilire una connessione di rete, in cui può venire generata una di numerose eccezioni possibili, qualsiasi codice che in circostanze normali richiede l'intercettazione di un certo numero di eccezioni dovrebbe indicare la necessità di eseguire test per controllare se l'elaborazione avrà esito positivo.</span><span class="sxs-lookup"><span data-stu-id="a6798-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="a6798-215">Lo stato condiviso modificabile a livello di processo tra i domini applicazione deve essere eliminato o usare un'area a esecuzione vincolata</span><span class="sxs-lookup"><span data-stu-id="a6798-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="a6798-216">Come indicato nell'introduzione, può essere molto difficile scrivere codice gestito che monitora lo stato condiviso a livello di processo tra domini delle applicazioni in modo affidabile.</span><span class="sxs-lookup"><span data-stu-id="a6798-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="a6798-217">Per stato condiviso a livello di processo si intende qualsiasi tipo di struttura dei dati condivisa tra domini delle applicazioni, nel codice Win32, all'interno di CLR o nel codice gestito tramite la comunicazione remota.</span><span class="sxs-lookup"><span data-stu-id="a6798-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="a6798-218">Uno stato condiviso modificabile è molto difficile da scrivere correttamente nel codice gestito e uno stato condiviso statico richiede estrema attenzione.</span><span class="sxs-lookup"><span data-stu-id="a6798-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="a6798-219">Se c'è uno stato condiviso a livello di processo o di computer, trovare un modo per eliminarlo oppure proteggerlo tramite un'area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="a6798-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="a6798-220">Si noti che qualsiasi libreria con stato condiviso non identificato o non corretto può determinare l'arresto anomalo di un host, ad esempio SQL Server, che richiede lo scaricamento pulito di <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="a6798-221">Se il codice usa un oggetto COM, evitare di condividere tale oggetto COM tra domini delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a6798-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="a6798-222">I blocchi non funzionano a livello di processo o tra domini dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="a6798-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="a6798-223">In precedenza, <xref:System.Threading.Monitor.Enter%2A> e l'[istruzione lock](../../csharp/language-reference/keywords/lock-statement.md) venivano usati per creare blocchi di processo globali.</span><span class="sxs-lookup"><span data-stu-id="a6798-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="a6798-224">Ciò si verifica, ad esempio, quando si applica un blocco sulle classi Agile di <xref:System.AppDomain>, ad esempio le istanze di <xref:System.Type> da assembly non condivisi, gli oggetti <xref:System.Threading.Thread>, le stringhe centralizzate e alcune stringhe condivise tra domini delle applicazioni tramite la comunicazione remota.</span><span class="sxs-lookup"><span data-stu-id="a6798-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="a6798-225">Questi blocchi non sono più a livello di processo.</span><span class="sxs-lookup"><span data-stu-id="a6798-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="a6798-226">Per identificare la presenza di un blocco tra diversi domini delle applicazioni a livello di processo, determinare se il codice all'interno del blocco fa uso di risorse esterne persistenti, ad esempio un file su disco o eventualmente un database.</span><span class="sxs-lookup"><span data-stu-id="a6798-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="a6798-227">Si noti che l'acquisizione di un blocco all'interno di un oggetto <xref:System.AppDomain> può provocare problemi se il codice protetto usa una risorsa esterna, perché il codice può essere eseguito simultaneamente tra più domini delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a6798-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="a6798-228">Ciò può costituire un problema quando si scrive in un file di log o si esegue il binding a un socket per l'intero processo.</span><span class="sxs-lookup"><span data-stu-id="a6798-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="a6798-229">Queste modifiche indicano che non esiste un modo semplice, usando il codice gestito, per ottenere un blocco globale del processo, se non usando un'istanza denominata di <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="a6798-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="a6798-230">Creare codice che non viene eseguito simultaneamente in due domini delle applicazioni oppure usare la classe <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="a6798-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="a6798-231">Se non è possibile modificare il codice esistente, non usare un mutex denominato Win32 per ottenere la sincronizzazione, perché l'esecuzione in modalità fiber implica l'impossibilità di garantire che un mutex venga acquisito e rilasciato dallo stesso thread del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="a6798-232">È necessario usare la classe gestita <xref:System.Threading.Mutex>, una classe denominata <xref:System.Threading.ManualResetEvent> o <xref:System.Threading.AutoResetEvent> oppure una classe <xref:System.Threading.Semaphore> per sincronizzare il blocco del codice in modo che CLR ne sia consapevole invece che sincronizzare il blocco tramite codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="a6798-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="a6798-233">Evitare lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="a6798-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="a6798-234">Anche gli oggetti <xref:System.Type> pubblici e privati inclusi negli assembly condivisi, con una sola copia del codice condivisa tra tutti i domini delle applicazioni, presentano problemi.</span><span class="sxs-lookup"><span data-stu-id="a6798-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="a6798-235">Per gli assembly condivisi c'è un'unica istanza di un oggetto <xref:System.Type> per processo e, di conseguenza, più domini delle applicazioni condividono la stessa istanza di <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="a6798-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="a6798-236">L'acquisizione di un blocco su un'istanza di <xref:System.Type> ha effetto sull'intero processo e non solo su <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="a6798-237">Se un oggetto <xref:System.AppDomain> acquisisce un blocco su un oggetto <xref:System.Type>, il thread viene interrotto improvvisamente senza rilasciare il blocco.</span><span class="sxs-lookup"><span data-stu-id="a6798-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="a6798-238">Tale blocco può quindi causare una situazione di deadlock in altri domini delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="a6798-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="a6798-239">Una tecnica efficace per acquisire blocchi nei metodi statici consiste nell'aggiungere al codice un oggetto statico di sincronizzazione interna.</span><span class="sxs-lookup"><span data-stu-id="a6798-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="a6798-240">Questo oggetto può essere inizializzato nel costruttore della classe, se presente, oppure nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="a6798-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="a6798-241">Quando si acquisisce un blocco, usare la proprietà `InternalSyncObject` per ottenere un oggetto a cui applicare il blocco.</span><span class="sxs-lookup"><span data-stu-id="a6798-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="a6798-242">Non è necessario usare questa proprietà se l'oggetto di sincronizzazione interna è stato inizializzato nel costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="a6798-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="a6798-243">Il codice di inizializzazione del blocco per la doppia verifica dovrebbe essere simile all'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="a6798-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="a6798-244">Nota sul blocco (this)</span><span class="sxs-lookup"><span data-stu-id="a6798-244">A note about lock(this)</span></span>

<span data-ttu-id="a6798-245">In genere è possibile acquisire un blocco su un singolo oggetto accessibile pubblicamente.</span><span class="sxs-lookup"><span data-stu-id="a6798-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="a6798-246">Se tuttavia si tratta di un oggetto Singleton, che può causare il deadlock di un intero sottosistema, prendere in considerazione anche la possibilità di usare lo schema progettuale illustrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="a6798-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="a6798-247">Un blocco sul singolo oggetto <xref:System.Security.SecurityManager> può ad esempio causare un deadlock in <xref:System.AppDomain>, rendendo inutilizzabile l'intero oggetto <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="a6798-248">È consigliabile non acquisire alcun blocco su un oggetto accessibile pubblicamente di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="a6798-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="a6798-249">Tuttavia, un blocco su una singola matrice o raccolta non rappresenta in genere un problema.</span><span class="sxs-lookup"><span data-stu-id="a6798-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-250">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-250">Code analysis rule</span></span>

<span data-ttu-id="a6798-251">Non acquisire blocchi su tipi che possono essere usati tra domini delle applicazioni o che non hanno una forte identità.</span><span class="sxs-lookup"><span data-stu-id="a6798-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="a6798-252">Non chiamare <xref:System.Threading.Monitor.Enter%2A> su un oggetto <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> o su qualsiasi oggetto che deriva da <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="a6798-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="a6798-253">Rimuovere GC. Chiamate KeepAlive</span><span class="sxs-lookup"><span data-stu-id="a6798-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="a6798-254">Una quantità significativa di codice esistente non usa <xref:System.GC.KeepAlive%2A> quando opportuno oppure lo usa in casi in cui non è appropriato.</span><span class="sxs-lookup"><span data-stu-id="a6798-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="a6798-255">Dopo la conversione in <xref:System.Runtime.InteropServices.SafeHandle>, non è necessario che le classi chiamino <xref:System.GC.KeepAlive%2A>, presupponendo che non abbiano un finalizzatore ma si basino su <xref:System.Runtime.InteropServices.SafeHandle> per finalizzare gli handle del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="a6798-256">Mentre i costi a livello di prestazioni risultanti dal mantenimento di una chiamata a <xref:System.GC.KeepAlive%2A> sono trascurabili, la percezione che una chiamata a <xref:System.GC.KeepAlive%2A> sia necessaria o sufficiente per la risoluzione di un problema di durata, che potrebbe non esserci più, rende più difficile la gestione del codice.</span><span class="sxs-lookup"><span data-stu-id="a6798-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="a6798-257">Tuttavia, quando si usano gli oggetti Runtime Callable Wrapper CLR di interoperabilità COM, <xref:System.GC.KeepAlive%2A> è ancora necessario per il codice.</span><span class="sxs-lookup"><span data-stu-id="a6798-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-258">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-258">Code analysis rule</span></span>

<span data-ttu-id="a6798-259">Rimuovere <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="a6798-260">Usare l'attributo HostProtection</span><span class="sxs-lookup"><span data-stu-id="a6798-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="a6798-261">La classe <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) consente di usare azioni di sicurezza dichiarative per determinare i requisiti di protezione host. In questo modo, l'host può impedire anche al codice completamente attendibile di chiamare determinati metodi che non sono appropriati per l'host specifico, ad esempio <xref:System.Environment.Exit%2A> o <xref:System.Windows.Forms.MessageBox.Show%2A> per SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="a6798-262">L'attributo di protezione host influisce solo sulle applicazioni non gestite che ospitano Common Language Runtime e implementano la protezione host, ad esempio SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="a6798-263">Quando applicata, l'azione di sicurezza comporta la creazione di una richiesta di collegamento in base alle risorse host esposte dalla classe o dal metodo.</span><span class="sxs-lookup"><span data-stu-id="a6798-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="a6798-264">Se il codice viene eseguito in un'applicazione client o in un server non protetto dall'host, l'attributo non ha alcun effetto. Non viene rilevato e quindi nemmeno applicato.</span><span class="sxs-lookup"><span data-stu-id="a6798-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a6798-265">Lo scopo di questo attributo è quello di imporre le linee guida del modello di programmazione specifico per l'host, non il comportamento di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a6798-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="a6798-266">Anche se per controllare la conformità ai requisiti del modello di programmazione viene usata una richiesta di collegamento, l'oggetto <xref:System.Security.Permissions.HostProtectionAttribute> non è un'autorizzazione di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a6798-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="a6798-267">Se l'host non ha i requisiti del modello di programmazione, le richieste di collegamento non vengono effettuate.</span><span class="sxs-lookup"><span data-stu-id="a6798-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="a6798-268">Questo attributo identifica quanto segue:</span><span class="sxs-lookup"><span data-stu-id="a6798-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="a6798-269">Metodi o classi non idonei per il modello di programmazione dell'host ma benigni.</span><span class="sxs-lookup"><span data-stu-id="a6798-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="a6798-270">Metodi o classi non idonei per il modello di programmazione dell'host e che potrebbero portare alla destabilizzazione del codice utente gestito dal server.</span><span class="sxs-lookup"><span data-stu-id="a6798-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="a6798-271">Metodi o classi non idonei per il modello di programmazione dell'host e che potrebbero portare alla destabilizzazione del processo server stesso.</span><span class="sxs-lookup"><span data-stu-id="a6798-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="a6798-272">Se si crea una libreria di classi che verrà chiamata da applicazioni eseguibili in un ambiente protetto dall'host, è necessario applicare questo attributo ai membri che espongono categorie di risorse <xref:System.Security.Permissions.HostProtectionResource>.</span><span class="sxs-lookup"><span data-stu-id="a6798-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="a6798-273">I membri della libreria di classi .NET Framework con questo attributo provocano solo il controllo del chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="a6798-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="a6798-274">Analogamente, anche i membri della propria libreria devono determinare il controllo del relativo chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="a6798-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="a6798-275">Per altre informazioni sull'attributo di protezione host, vedere <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a6798-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-276">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-276">Code analysis rule</span></span>

<span data-ttu-id="a6798-277">Per SQL Server, tutti i metodi usati per introdurre la sincronizzazione o il threading devono essere identificati con l'attributo di protezione host.</span><span class="sxs-lookup"><span data-stu-id="a6798-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="a6798-278">Tra questi metodi sono inclusi quelli che condividono lo stato, sono sincronizzati o gestiscono processi esterni.</span><span class="sxs-lookup"><span data-stu-id="a6798-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="a6798-279">I valori di <xref:System.Security.Permissions.HostProtectionResource> che influiscono su SQL Server sono <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> e <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="a6798-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="a6798-280">Tuttavia, l'identificazione con un attributo di protezione host è necessaria per tutti i metodi che espongono qualsiasi oggetto <xref:System.Security.Permissions.HostProtectionResource>, non solo per quelli che usano risorse che interessano SQL.</span><span class="sxs-lookup"><span data-stu-id="a6798-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="a6798-281">Non bloccare a tempo indefinito nel codice non gestito</span><span class="sxs-lookup"><span data-stu-id="a6798-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="a6798-282">L'inserimento di un blocco nel codice non gestito invece che in quello gestito può determinare un attacco Denial of Service perché CLR non è in grado di interrompere il thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="a6798-283">Un thread bloccato impedisce a CLR di scaricare <xref:System.AppDomain>, se non mediante l'esecuzione di operazioni assolutamente non sicure.</span><span class="sxs-lookup"><span data-stu-id="a6798-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="a6798-284">Il blocco mediante una primitiva di sincronizzazione di Windows è un esempio chiaro di qualcosa che non è consentito.</span><span class="sxs-lookup"><span data-stu-id="a6798-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="a6798-285">Il blocco in una chiamata a `ReadFile` in un socket deve essere evitato se possibile. idealmente, l'API Windows deve fornire un meccanismo per il timeout di un'operazione di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="a6798-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="a6798-286">Tutti i metodi che effettuano chiamate nel codice nativo dovrebbero usare una chiamata Win32 con un valore finito e ragionevole di timeout.</span><span class="sxs-lookup"><span data-stu-id="a6798-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="a6798-287">Anche se autorizzato a specificare il timeout, l'utente non deve avere la possibilità di impostare un timeout infinito, a meno che non abbia autorizzazioni di sicurezza specifiche.</span><span class="sxs-lookup"><span data-stu-id="a6798-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="a6798-288">Come indicazione generale, tenere presente che, se un metodo si blocca per più di circa 10 secondi, sarà necessario usare una versione che supporta i timeout oppure disporre di supporto CLR aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="a6798-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="a6798-289">Di seguito sono riportati alcuni esempi di API problematiche.</span><span class="sxs-lookup"><span data-stu-id="a6798-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="a6798-290">Unnamed pipe e named pipe possono essere create senza timeout, tuttavia il codice non deve mai chiamare `CreateNamedPipe` né `WaitNamedPipe` con NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="a6798-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="a6798-291">È inoltre possibile che si verifichi un blocco imprevisto anche se è specificato un timeout.</span><span class="sxs-lookup"><span data-stu-id="a6798-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="a6798-292">La chiamata a `WriteFile` su una unnamed pipe causa un blocco finché non vengono scritti tutti i byte e quindi, se il buffer contiene dati non letti, il blocco determinato dalla chiamata a `WriteFile` si protrarrà finché il lettore non libera spazio nel buffer della pipe.</span><span class="sxs-lookup"><span data-stu-id="a6798-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="a6798-293">I socket devono sempre usare API che rispettano un meccanismo di timeout.</span><span class="sxs-lookup"><span data-stu-id="a6798-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-294">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-294">Code analysis rule</span></span>

<span data-ttu-id="a6798-295">Un blocco senza timeout nel codice non gestito è un attacco Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="a6798-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="a6798-296">Non eseguire chiamate di platform invoke su `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` e `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="a6798-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="a6798-297">Non usare NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="a6798-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="a6798-298">Identificare tutte le funzionalità dipendenti da STA</span><span class="sxs-lookup"><span data-stu-id="a6798-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="a6798-299">Identificare il codice che usa apartment a thread singolo (STA, Single-Threaded Apartment) COM.</span><span class="sxs-lookup"><span data-stu-id="a6798-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="a6798-300">Gli apartment a thread singolo sono disabilitati nel processo SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="a6798-301">Le funzionalità che dipendono da `CoInitialize`, ad esempio i contatori delle prestazioni o gli Appunti, devono essere disabilitate in SQL Server.</span><span class="sxs-lookup"><span data-stu-id="a6798-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="a6798-302">Verificare che i finalizzatori siano privi di problemi di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="a6798-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="a6798-303">È possibile che nelle versioni future di .NET Framework ci saranno più thread finalizzatori e che quindi i finalizzatori per istanze diverse dello stesso tipo vengano eseguiti simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="a6798-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="a6798-304">Non è necessario che i finalizzatori siano completamente thread-safe perché il Garbage Collector garantisce che un solo thread eseguirà il finalizzatore per un'istanza di un determinato oggetto.</span><span class="sxs-lookup"><span data-stu-id="a6798-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="a6798-305">È tuttavia necessario che i finalizzatori siano codificati per evitare situazioni di race condition e deadlock quando vengono eseguiti simultaneamente su più istanze di oggetti diverse.</span><span class="sxs-lookup"><span data-stu-id="a6798-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="a6798-306">Quando si usa qualsiasi stato esterno in un finalizzatore, ad esempio per scrivere in un file di log, è necessario gestire i problemi di threading.</span><span class="sxs-lookup"><span data-stu-id="a6798-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="a6798-307">Non fare affidamento sulla finalizzazione per fornire caratteristiche di thread safety.</span><span class="sxs-lookup"><span data-stu-id="a6798-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="a6798-308">Non usare l'archiviazione thread-local, gestita o nativa, per archiviare lo stato nel thread finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="a6798-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-309">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-309">Code analysis rule</span></span>

<span data-ttu-id="a6798-310">I finalizzatori non devono avere alcun problema di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="a6798-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="a6798-311">Non usare uno stato modificabile statico in un finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="a6798-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="a6798-312">Se possibile, evitare la memoria non gestita</span><span class="sxs-lookup"><span data-stu-id="a6798-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="a6798-313">La memoria non gestita può andare perduta, proprio come un handle del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="a6798-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="a6798-314">Se possibile, provare a usare la memoria nello stack tramite [stackalloc](../../csharp/language-reference/operators/stackalloc.md), un oggetto gestito bloccato, come l'[istruzione fixed](../../csharp/language-reference/keywords/fixed-statement.md), o un oggetto <xref:System.Runtime.InteropServices.GCHandle> che fa uso di un byte[].</span><span class="sxs-lookup"><span data-stu-id="a6798-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="a6798-315">Alla fine, <xref:System.GC> eseguirà la pulizia di questi elementi.</span><span class="sxs-lookup"><span data-stu-id="a6798-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="a6798-316">Se tuttavia è necessario allocare memoria non gestita, prendere in considerazione l'uso di una classe che deriva da <xref:System.Runtime.InteropServices.SafeHandle> per eseguire il wrapping dell'allocazione della memoria.</span><span class="sxs-lookup"><span data-stu-id="a6798-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="a6798-317">Si noti che c'è almeno un caso in cui l'oggetto <xref:System.Runtime.InteropServices.SafeHandle> non è adeguato.</span><span class="sxs-lookup"><span data-stu-id="a6798-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="a6798-318">Per le chiamate ai metodi COM che allocano o liberano memoria, viene in genere usata una DLL per allocare la memoria tramite `CoTaskMemAlloc`, seguita da un'altra DLL per liberare la memoria con `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="a6798-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="a6798-319">L'uso di <xref:System.Runtime.InteropServices.SafeHandle> in questi contesti risulta inappropriato perché questo oggetto tenta di legare la durata della memoria non gestita alla durata di <xref:System.Runtime.InteropServices.SafeHandle>, invece di consentire che venga controllata dall'altra DLL.</span><span class="sxs-lookup"><span data-stu-id="a6798-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="a6798-320">Esaminare tutti gli utilizzi di catch (Exception)</span><span class="sxs-lookup"><span data-stu-id="a6798-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="a6798-321">I blocchi catch che intercettano tutte le eccezioni invece di un'eccezione specifica sono ora in grado di intercettare anche le eccezioni asincrone.</span><span class="sxs-lookup"><span data-stu-id="a6798-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="a6798-322">Esaminare ogni blocco catch(Exception) verificando che non sia presente codice di annullamento o di rilascio di risorse importanti che potrebbe essere ignorato oppure un comportamento potenzialmente non corretto nel blocco catch stesso per la gestione di <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> o <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="a6798-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="a6798-323">Si noti che il codice potrebbe registrare o presupporre di poter rilevare solo determinate eccezioni oppure che ogni volta che si verifica un'eccezione la causa è sempre un motivo specifico.</span><span class="sxs-lookup"><span data-stu-id="a6798-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="a6798-324">È possibile che questi presupposti debbano essere aggiornati in modo da includere <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="a6798-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="a6798-325">Prendere in considerazione l'opportunità di modificare tutti i punti in cui vengono intercettate le eccezioni in modo da intercettare un tipo specifico di eccezione che si prevede venga generato, ad esempio un'eccezione <xref:System.FormatException> dai metodi di formattazione delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="a6798-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="a6798-326">In questo modo è possibile impedire l'esecuzione del blocco catch in caso di eccezioni impreviste e garantire che il codice non nasconda bug intercettando eccezioni di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="a6798-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="a6798-327">Come regola generale, evitare sempre di gestire un'eccezione nel codice di libreria (il codice che richiede di intercettare un'eccezione può indicare la presenza di un difetto di progettazione nel codice chiamato).</span><span class="sxs-lookup"><span data-stu-id="a6798-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="a6798-328">In alcuni casi è opportuno intercettare un'eccezione e generarne un'altra di tipo diverso per fornire più dati.</span><span class="sxs-lookup"><span data-stu-id="a6798-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="a6798-329">A tale scopo, usare eccezioni annidate, archiviando la causa effettiva dell'errore nella proprietà <xref:System.Exception.InnerException%2A> della nuova eccezione.</span><span class="sxs-lookup"><span data-stu-id="a6798-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-330">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-330">Code analysis rule</span></span>

<span data-ttu-id="a6798-331">Esaminare tutti i blocchi catch nel codice gestito che intercettano tutti gli oggetti o tutte le eccezioni.</span><span class="sxs-lookup"><span data-stu-id="a6798-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="a6798-332">In C# questo significa contrassegnare sia `catch` {} che `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="a6798-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="a6798-333">Prendere in considerazione l'opportunità di rendere molto specifico il tipo di eccezione oppure esaminare il codice per assicurarsi che non si verifichino comportamenti non corretti qualora venga intercettata un'eccezione di tipo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="a6798-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="a6798-334">Non presupporre che un thread gestito sia un thread Win32, ovvero una fibra</span><span class="sxs-lookup"><span data-stu-id="a6798-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="a6798-335">È possibile usare l'archiviazione thread-local gestita, ma non quella non gestita, né è possibile presupporre che il codice verrà eseguito di nuovo nel thread del sistema operativo corrente.</span><span class="sxs-lookup"><span data-stu-id="a6798-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="a6798-336">Non modificare impostazioni quali le impostazioni locali dei thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="a6798-337">Non chiamare `InitializeCriticalSection` o `CreateMutex` tramite platform invoke perché questi metodi richiedono che un thread del sistema operativo che attiva un blocco possa anche disattivarlo.</span><span class="sxs-lookup"><span data-stu-id="a6798-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="a6798-338">Poiché con i fiber questo non si verifica, non è possibile usare mutex e sezioni critiche Win32 direttamente in SQL.</span><span class="sxs-lookup"><span data-stu-id="a6798-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="a6798-339">Si noti che la classe gestita <xref:System.Threading.Mutex> non gestisce questi problemi di affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="a6798-340">È possibile usare senza alcun rischio la maggior parte dei dati sullo stato in un oggetto <xref:System.Threading.Thread> gestito, tra cui l'archiviazione thread-local gestita e le impostazioni cultura dell'interfaccia utente correnti del thread.</span><span class="sxs-lookup"><span data-stu-id="a6798-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="a6798-341">È anche possibile usare l'oggetto <xref:System.ThreadStaticAttribute>, che rende accessibile il valore di una variabile statica esistente solo al thread gestito corrente. Si tratta di una tecnica alternativa per gestire l'archiviazione locale dei fiber in CLR.</span><span class="sxs-lookup"><span data-stu-id="a6798-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="a6798-342">Per motivi legati al modello di programmazione, non è consentito modificare le impostazioni cultura correnti di un thread durante l'esecuzione in SQL.</span><span class="sxs-lookup"><span data-stu-id="a6798-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-343">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-343">Code analysis rule</span></span>

<span data-ttu-id="a6798-344">SQL Server viene eseguito in modalità fiber. Non usare l'archiviazione thread-local.</span><span class="sxs-lookup"><span data-stu-id="a6798-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="a6798-345">Non eseguire chiamate di platform invoke su `TlsAlloc`, `TlsFree`, `TlsGetValue` e `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="a6798-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="a6798-346">Consentire a SQL Server di gestire la rappresentazione</span><span class="sxs-lookup"><span data-stu-id="a6798-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="a6798-347">Poiché la rappresentazione opera a livello di thread e SQL può essere eseguito in modalità fiber, il codice gestito non deve rappresentare utenti né chiamare `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="a6798-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-348">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-348">Code analysis rule</span></span>

<span data-ttu-id="a6798-349">Consentire a SQL Server di gestire la rappresentazione.</span><span class="sxs-lookup"><span data-stu-id="a6798-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="a6798-350">Non usare `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` o `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="a6798-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="a6798-351">Non chiamare thread:: Suspend</span><span class="sxs-lookup"><span data-stu-id="a6798-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="a6798-352">Nonostante possa sembrare un'operazione semplice, la sospensione di un thread può causare situazioni di deadlock.</span><span class="sxs-lookup"><span data-stu-id="a6798-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="a6798-353">Se un thread che applica un blocco viene sospeso da un secondo thread e quest'ultimo cerca di acquisire lo stesso blocco, si verifica un deadlock.</span><span class="sxs-lookup"><span data-stu-id="a6798-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="a6798-354">Attualmente <xref:System.Threading.Thread.Suspend%2A> può interferire con la sicurezza, il caricamento delle classi, la comunicazione remota e la reflection.</span><span class="sxs-lookup"><span data-stu-id="a6798-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="a6798-355">Regola di analisi codice</span><span class="sxs-lookup"><span data-stu-id="a6798-355">Code analysis rule</span></span>

<span data-ttu-id="a6798-356">Non chiamare <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="a6798-357">Prendere invece in considerazione l'uso di una primitiva di sincronizzazione effettiva, ad esempio un oggetto <xref:System.Threading.Semaphore> o <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="a6798-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="a6798-358">Proteggere le operazioni critiche con le aree di esecuzione vincolate e i contratti di affidabilità</span><span class="sxs-lookup"><span data-stu-id="a6798-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="a6798-359">Quando si esegue un'operazione complessa che aggiorna uno stato condiviso o che deve avere esito completamente positivo o negativo, assicurarsi che sia protetta da un'area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="a6798-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="a6798-360">In questo modo, si garantisce che il codice venga eseguito in ogni caso, anche se si verifica un'interruzione improvvisa del thread o uno scaricamento improvviso di <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="a6798-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="a6798-361">Un'area a esecuzione vincolata consiste in un particolare blocco `try/finally`, immediatamente preceduto da una chiamata a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="a6798-362">In questo modo, il compilatore JIT prepara tutto il codice nel blocco finally prima di eseguire il blocco `try`.</span><span class="sxs-lookup"><span data-stu-id="a6798-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="a6798-363">Si ha così la garanzia che il codice nel blocco finally venga compilato ed eseguito in tutti i casi.</span><span class="sxs-lookup"><span data-stu-id="a6798-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="a6798-364">Non è raro che in un'area a esecuzione vincolata sia presente un blocco `try` vuoto.</span><span class="sxs-lookup"><span data-stu-id="a6798-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="a6798-365">L'uso di un'area di questo tipo garantisce la protezione da interruzioni di thread asincrone ed eccezioni di memoria insufficiente.</span><span class="sxs-lookup"><span data-stu-id="a6798-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="a6798-366">Per un formato di area a esecuzione vincolata in grado di gestire anche gli overflow dello stack per codice eccessivamente dettagliato, vedere <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6798-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="a6798-367">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a6798-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="a6798-368">programmazione per SQL Server e attributi di protezione host</span><span class="sxs-lookup"><span data-stu-id="a6798-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
