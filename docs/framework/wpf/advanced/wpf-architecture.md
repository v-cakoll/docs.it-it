---
title: Architettura
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: db9938f26f31506737eb0395fa389da01a1ee444
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 01/24/2020
ms.locfileid: "76735073"
---
# <a name="wpf-architecture"></a><span data-ttu-id="f3d28-102">Architettura WPF</span><span class="sxs-lookup"><span data-stu-id="f3d28-102">WPF Architecture</span></span>
<span data-ttu-id="f3d28-103">In questo argomento viene fornita una presentazione guidata della gerarchia di classi Windows Presentation Foundation (WPF).</span><span class="sxs-lookup"><span data-stu-id="f3d28-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="f3d28-104">Viene illustrata la maggior parte dei principali sottosistemi di WPF e viene descritta la modalità di interazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="f3d28-105">Vengono inoltre illustrate alcune delle scelte effettuate dagli architetti di WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="f3d28-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="f3d28-106">System.Object</span></span>  
 <span data-ttu-id="f3d28-107">Il modello di programmazione WPF primario viene esposto tramite codice gestito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="f3d28-108">Nelle fasi iniziali della fase di progettazione di WPF sono state illustrate alcune discussioni sulla posizione in cui deve essere disegnata la linea tra i componenti gestiti del sistema e quelli non gestiti.</span><span class="sxs-lookup"><span data-stu-id="f3d28-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="f3d28-109">CLR fornisce una serie di funzionalità che rendono lo sviluppo più produttivo e affidabile (inclusa la gestione della memoria, la gestione degli errori, Common Type System e così via), ma hanno un costo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="f3d28-110">I componenti principali di WPF sono illustrati nella figura seguente.</span><span class="sxs-lookup"><span data-stu-id="f3d28-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="f3d28-111">Le sezioni rosse del diagramma (PresentationFramework, PresentationCore e milcore) sono le parti principali del codice di WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="f3d28-112">Di queste, solo milcore è un componente non gestito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="f3d28-113">Milcore è scritto in codice non gestito per consentire una stretta integrazione con DirectX.</span><span class="sxs-lookup"><span data-stu-id="f3d28-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="f3d28-114">Tutte le visualizzazioni in WPF vengono eseguite tramite il motore DirectX, consentendo un efficiente rendering dell'hardware e del software.</span><span class="sxs-lookup"><span data-stu-id="f3d28-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="f3d28-115">WPF necessitava anche di un controllo accurato sulla memoria e sull'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="f3d28-116">Il motore di composizione in milcore è estremamente sensibile alle prestazioni ed è necessario rinunciare a molti vantaggi di CLR per ottenere prestazioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="f3d28-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="f3d28-117">![Posizione di WPF all'interno dell'.NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="f3d28-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="f3d28-118">La comunicazione tra le parti gestite e non gestite di WPF viene discussa più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="f3d28-119">Il resto del modello di programmazione gestito viene descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="f3d28-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="f3d28-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="f3d28-121">La maggior parte degli oggetti in WPF deriva da <xref:System.Windows.Threading.DispatcherObject>, che fornisce i costrutti di base per la gestione della concorrenza e del threading.</span><span class="sxs-lookup"><span data-stu-id="f3d28-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="f3d28-122">WPF si basa su un sistema di messaggistica implementato dal dispatcher.</span><span class="sxs-lookup"><span data-stu-id="f3d28-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="f3d28-123">Funziona in modo molto simile a quello del messaggio Win32 familiare; in realtà, il dispatcher WPF USA messaggi User32 per l'esecuzione di chiamate cross-thread.</span><span class="sxs-lookup"><span data-stu-id="f3d28-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="f3d28-124">Esistono due concetti principali da comprendere quando si discute la concorrenza in WPF, ovvero il dispatcher e l'affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="f3d28-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="f3d28-125">Durante la fase di progettazione di WPF, lo scopo era quello di passare a un singolo thread di esecuzione, ma a un modello "creata un'affinità" non thread.</span><span class="sxs-lookup"><span data-stu-id="f3d28-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="f3d28-126">L'affinità di thread si verifica quando un componente utilizza l'identità del thread in esecuzione per archiviare un tipo di stato.</span><span class="sxs-lookup"><span data-stu-id="f3d28-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="f3d28-127">Nella forma più comune, per archiviare lo stato viene utilizzata l'archiviazione locale di thread (TLS).</span><span class="sxs-lookup"><span data-stu-id="f3d28-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="f3d28-128">L'affinità di thread richiede che ciascun thread di esecuzione logico appartenga a un solo thread fisico del sistema operativo, che può richiedere un elevato consumo di memoria.</span><span class="sxs-lookup"><span data-stu-id="f3d28-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="f3d28-129">Alla fine, il modello di threading di WPF è stato tenuto in sincronia con il modello di threading User32 esistente dell'esecuzione a thread singolo con affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="f3d28-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="f3d28-130">Il motivo principale di questa interoperabilità è che i sistemi, ad esempio OLE 2,0, gli appunti e Internet Explorer, richiedono l'esecuzione di affinità a thread singolo (STA).</span><span class="sxs-lookup"><span data-stu-id="f3d28-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="f3d28-131">Disponendo di oggetti con threading STA, è necessaria una modalità di comunicazione tra thread e di conferma di utilizzo del thread corretto.</span><span class="sxs-lookup"><span data-stu-id="f3d28-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="f3d28-132">Qui si colloca il ruolo del dispatcher.</span><span class="sxs-lookup"><span data-stu-id="f3d28-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="f3d28-133">Il dispatcher è un sistema di base di invio di messaggi con più code in ordine di priorità.</span><span class="sxs-lookup"><span data-stu-id="f3d28-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="f3d28-134">Gli esempi di messaggi includono le notifiche di input non elaborato (spostamenti del mouse), le funzionalità del framework (layout) o i comandi utente (esecuzione di metodi).</span><span class="sxs-lookup"><span data-stu-id="f3d28-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="f3d28-135">Derivando da <xref:System.Windows.Threading.DispatcherObject>, viene creato un oggetto CLR con un comportamento STA e viene assegnato un puntatore a un dispatcher in fase di creazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="f3d28-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="f3d28-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="f3d28-137">Una delle principali filosofie dell'architettura utilizzate nella creazione di WPF era una preferenza per le proprietà di metodi o eventi.</span><span class="sxs-lookup"><span data-stu-id="f3d28-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="f3d28-138">Le proprietà sono dichiarative e consentono di specificare più facilmente lo scopo anziché l'azione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="f3d28-139">In tal modo veniva anche supportato un sistema basato sui modelli o sui dati per la visualizzazione dei contenuti dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="f3d28-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="f3d28-140">Lo scopo di tale approccio era di creare un maggior numero di proprietà con cui stabilire l'associazione per poter controllare meglio il comportamento di un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="f3d28-141">Per avere un maggior numero di sistemi basati sulle proprietà, è necessario un sistema di proprietà più completo rispetto a quello fornito da CLR.</span><span class="sxs-lookup"><span data-stu-id="f3d28-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="f3d28-142">Un semplice esempio è rappresentato dalle notifiche di modifica.</span><span class="sxs-lookup"><span data-stu-id="f3d28-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="f3d28-143">Per abilitare l'associazione bidirezionale, è necessario che entrambi i lati supportino la notifica di modifica.</span><span class="sxs-lookup"><span data-stu-id="f3d28-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="f3d28-144">Per associare il comportamento a valori di proprietà, è necessario ricevere una notifica quando tale valore viene modificato.</span><span class="sxs-lookup"><span data-stu-id="f3d28-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="f3d28-145">Il Framework Microsoft .NET dispone di un'interfaccia, **INotifyPropertyChange**, che consente a un oggetto di pubblicare notifiche di modifica, ma è facoltativo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="f3d28-146">WPF fornisce un sistema di proprietà più completo, derivato dal tipo di <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="f3d28-147">Il sistema di proprietà è effettivamente un sistema di proprietà delle "dipendenze" nel senso che tiene traccia delle dipendenze tra espressioni di proprietà e riconvalida automaticamente i valori delle proprietà quando tali dipendenze vengono modificate.</span><span class="sxs-lookup"><span data-stu-id="f3d28-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="f3d28-148">Se, ad esempio, si dispone di una proprietà che eredita (come <xref:System.Windows.Controls.Control.FontSize%2A>), il sistema viene aggiornato automaticamente se la proprietà viene modificata in un elemento padre di un elemento che eredita il valore.</span><span class="sxs-lookup"><span data-stu-id="f3d28-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="f3d28-149">La base del sistema di proprietà WPF è il concetto di espressione di proprietà.</span><span class="sxs-lookup"><span data-stu-id="f3d28-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="f3d28-150">Nella prima versione di WPF, il sistema di espressioni di proprietà viene chiuso e tutte le espressioni vengono fornite come parte del Framework.</span><span class="sxs-lookup"><span data-stu-id="f3d28-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="f3d28-151">Le espressioni rappresentano il motivo per cui il sistema di proprietà non dispone di associazione dati, stili o ereditarietà hardcoded forniti invece dai livelli successivi all'interno del framework.</span><span class="sxs-lookup"><span data-stu-id="f3d28-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="f3d28-152">Il sistema di proprietà, inoltre, presenta possibilità limitate di archiviazione per i valori di proprietà.</span><span class="sxs-lookup"><span data-stu-id="f3d28-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="f3d28-153">Poiché gli oggetti hanno decine, se non centinaia, di proprietà e la maggior parte dei valori si trova nel relativo stato predefinito (ereditato, impostato per stile e così via), non tutte le istanze di un oggetto devono avere il peso di ciascuna proprietà in esso definita.</span><span class="sxs-lookup"><span data-stu-id="f3d28-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="f3d28-154">La nuova funzionalità finale del sistema di proprietà è la nozione di proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="f3d28-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="f3d28-155">Gli elementi WPF sono basati sul principio della composizione e sul riutilizzo dei componenti.</span><span class="sxs-lookup"><span data-stu-id="f3d28-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="f3d28-156">Spesso è necessario che un elemento contenitore, ad esempio un elemento di layout <xref:System.Windows.Controls.Grid>, richieda dati aggiuntivi sugli elementi figlio per controllarne il comportamento, ad esempio le informazioni sulla riga o sulla colonna.</span><span class="sxs-lookup"><span data-stu-id="f3d28-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="f3d28-157">Anziché associare tutte queste proprietà a ciascun elemento, un oggetto può fornire le definizioni delle proprietà per qualsiasi altro oggetto,</span><span class="sxs-lookup"><span data-stu-id="f3d28-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="f3d28-158">come avviene per le funzionalità "expando" di JavaScript.</span><span class="sxs-lookup"><span data-stu-id="f3d28-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="f3d28-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="f3d28-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="f3d28-160">Dopo avere definito un sistema, è necessario ottenere pixel disegnati sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="f3d28-161">La classe <xref:System.Windows.Media.Visual> fornisce per la compilazione di una struttura ad albero di oggetti visivi, ognuno dei quali contiene facoltativamente istruzioni di disegno e metadati su come eseguire il rendering di tali istruzioni (ritaglio, trasformazione e così via).</span><span class="sxs-lookup"><span data-stu-id="f3d28-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="f3d28-162"><xref:System.Windows.Media.Visual> è progettato per essere estremamente leggero e flessibile, la maggior parte delle funzionalità non hanno un'esposizione API pubblica e si basano molto sulle funzioni di callback protette.</span><span class="sxs-lookup"><span data-stu-id="f3d28-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="f3d28-163"><xref:System.Windows.Media.Visual> è effettivamente il punto di ingresso del sistema di composizione WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="f3d28-164"><xref:System.Windows.Media.Visual> è il punto di connessione tra questi due sottosistemi, l'API gestita e il milcore non gestito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="f3d28-165">WPF Visualizza i dati attraversando le strutture di dati non gestite gestite da milcore.</span><span class="sxs-lookup"><span data-stu-id="f3d28-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="f3d28-166">Queste strutture, denominate nodi di composizione, rappresentano una struttura di visualizzazione gerarchica ad albero con istruzioni di rendering in ciascun nodo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="f3d28-167">La struttura ad albero, illustrata a destra nella figura riportata di seguito, è accessibile solo mediante un protocollo di messaggistica.</span><span class="sxs-lookup"><span data-stu-id="f3d28-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="f3d28-168">Quando si programma WPF, si creano <xref:System.Windows.Media.Visual> elementi e tipi derivati, che comunicano internamente all'albero della composizione tramite questo protocollo di messaggistica.</span><span class="sxs-lookup"><span data-stu-id="f3d28-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="f3d28-169">Ogni <xref:System.Windows.Media.Visual> in WPF può creare uno, nessuno o più nodi di composizione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="f3d28-170">![Struttura ad albero visuale Windows Presentation Foundation.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="f3d28-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="f3d28-171">In questo caso va notato un dettaglio molto importante relativo all'architettura: l'intera struttura ad albero degli elementi visivi e delle istruzioni di disegno è memorizzata nella cache.</span><span class="sxs-lookup"><span data-stu-id="f3d28-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="f3d28-172">Nei termini grafici, WPF usa un sistema di rendering mantenuto.</span><span class="sxs-lookup"><span data-stu-id="f3d28-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="f3d28-173">Ciò fornisce al sistema elevate frequenze di aggiornamento senza che il sistema di composizione si blocchi sui callback al codice utente</span><span class="sxs-lookup"><span data-stu-id="f3d28-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="f3d28-174">e consente di impedire la visualizzazione di applicazioni che non rispondono.</span><span class="sxs-lookup"><span data-stu-id="f3d28-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="f3d28-175">Un altro dettaglio importante, non facilmente individuabile nel diagramma, è il modo in cui il sistema esegue effettivamente la composizione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="f3d28-176">In User32 e GDI il sistema funziona in un sistema di ritaglio in modalità immediata.</span><span class="sxs-lookup"><span data-stu-id="f3d28-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="f3d28-177">Quando è necessario eseguire il rendering di un componente, il sistema stabilisce un limite di ritaglio al di fuori del quale il componente non può toccare i pixel; successivamente, viene chiesto al componente di disegnare i pixel in tale casella.</span><span class="sxs-lookup"><span data-stu-id="f3d28-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="f3d28-178">Questo sistema funziona molto bene nei sistemi con memoria limitata poiché quando vengono apportate modifiche basta intervenire solo sul componente interessato. Non sono mai richiesti due componenti per il colore di un singolo pixel.</span><span class="sxs-lookup"><span data-stu-id="f3d28-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="f3d28-179">WPF usa un modello di disegno "algoritmo del pittore".</span><span class="sxs-lookup"><span data-stu-id="f3d28-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="f3d28-180">Ciò significa che anziché ritagliare ogni componente, viene richiesto il rendering di ciascun componente dallo sfondo al primo piano della visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="f3d28-181">In tal modo ciascun componente viene disegnato sulla visualizzazione del componente precedente.</span><span class="sxs-lookup"><span data-stu-id="f3d28-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="f3d28-182">Il vantaggio di questo modello è la possibilità di avere forme complesse, parzialmente trasparenti.</span><span class="sxs-lookup"><span data-stu-id="f3d28-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="f3d28-183">Con l'attuale hardware grafico moderno, questo modello è relativamente veloce, che non era il caso in cui User32/GDI fosse stato creato.</span><span class="sxs-lookup"><span data-stu-id="f3d28-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="f3d28-184">Come indicato in precedenza, una filosofia di base di WPF consiste nel passare a un modello di programmazione più dichiarativo "incentrato sulle proprietà".</span><span class="sxs-lookup"><span data-stu-id="f3d28-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="f3d28-185">Nel sistema visuale questo è evidente in un paio di punti interessanti.</span><span class="sxs-lookup"><span data-stu-id="f3d28-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="f3d28-186">Innanzitutto, se si pensa al sistema grafico in modalità memorizzata, si nota un deciso allontanamento da un modello imperativo di tipo DrawLine/DrawLine verso un modello orientato ai dati di tipo new Line()/new Line().</span><span class="sxs-lookup"><span data-stu-id="f3d28-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="f3d28-187">Questo spostamento verso il rendering basato sui dati consente operazioni complesse sulle istruzioni di disegno da esprimere utilizzando le proprietà.</span><span class="sxs-lookup"><span data-stu-id="f3d28-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="f3d28-188">I tipi che derivano da <xref:System.Windows.Media.Drawing> sono in effetti il modello a oggetti per il rendering.</span><span class="sxs-lookup"><span data-stu-id="f3d28-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="f3d28-189">In secondo luogo, se si esamina il sistema di animazione appare evidente che è quasi completamente dichiarativo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="f3d28-190">Anziché richiedere a uno sviluppatore di calcolare la posizione o il colore successivo, è possibile esprimere le animazioni come un set di proprietà su un oggetto di animazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="f3d28-191">Le animazioni possono quindi esprimere l'intenzione dello sviluppatore o del progettista (spostare questo pulsante da questa a quella posizione in 5 secondi) e il sistema può stabilire il modo più efficace per raggiungere tale scopo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="f3d28-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="f3d28-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="f3d28-193"><xref:System.Windows.UIElement> definisce sottosistemi di base, tra cui layout, input ed eventi.</span><span class="sxs-lookup"><span data-stu-id="f3d28-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="f3d28-194">Il layout è un concetto di base di WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="f3d28-195">In molti sistemi è presente un insieme fisso di modelli di layout (HTML supporta tre modelli di layout: flusso, assoluto e tabelle) oppure non è presente alcun modello di layout (User32 supporta effettivamente solo il posizionamento assoluto).</span><span class="sxs-lookup"><span data-stu-id="f3d28-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="f3d28-196">WPF ha iniziato con il presupposto che gli sviluppatori e i progettisti volevano un modello di layout flessibile ed estendibile, che poteva essere basato su valori di proprietà anziché su una logica imperativa.</span><span class="sxs-lookup"><span data-stu-id="f3d28-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="f3d28-197">A livello di <xref:System.Windows.UIElement>, viene introdotto il contratto di base per il layout, ovvero un modello a due fasi con <xref:System.Windows.UIElement.Measure%2A> e <xref:System.Windows.UIElement.Arrange%2A>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="f3d28-198"><xref:System.Windows.UIElement.Measure%2A> consente a un componente di determinare la quantità di dimensioni che si desidera eseguire.</span><span class="sxs-lookup"><span data-stu-id="f3d28-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="f3d28-199">Si tratta di una fase separata da <xref:System.Windows.UIElement.Arrange%2A> perché in molte situazioni un elemento padre chiede a un figlio di misurare più volte per determinare la posizione e le dimensioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="f3d28-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="f3d28-200">Il fatto che gli elementi padre chiedano agli elementi figlio di misurare dimostrano un'altra filosofia chiave di WPF, ovvero le dimensioni del contenuto.</span><span class="sxs-lookup"><span data-stu-id="f3d28-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="f3d28-201">Tutti i controlli in WPF supportano la possibilità di ridimensionare le dimensioni naturali del contenuto.</span><span class="sxs-lookup"><span data-stu-id="f3d28-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="f3d28-202">Tutto ciò semplifica il processo di localizzazione e consente il layout dinamico degli elementi quando gli oggetti vengono ridimensionati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="f3d28-203">La fase <xref:System.Windows.UIElement.Arrange%2A> consente a un elemento padre di posizionare e determinare le dimensioni finali di ogni elemento figlio.</span><span class="sxs-lookup"><span data-stu-id="f3d28-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="f3d28-204">Spesso si parla del lato output di WPF, <xref:System.Windows.Media.Visual> e degli oggetti correlati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="f3d28-205">Esiste, tuttavia, una straordinaria quantità di innovazione anche sul lato input.</span><span class="sxs-lookup"><span data-stu-id="f3d28-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="f3d28-206">Probabilmente la modifica più importante nel modello di input per WPF è il modello coerente in base al quale gli eventi di input vengono instradati attraverso il sistema.</span><span class="sxs-lookup"><span data-stu-id="f3d28-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="f3d28-207">L'input come segnale proviene da un driver di dispositivo in modalità kernel e viene indirizzato verso il processo e il thread corretti mediante un complicato processo che interessa il kernel di Windows e User32.</span><span class="sxs-lookup"><span data-stu-id="f3d28-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="f3d28-208">Una volta che il messaggio User32 corrispondente all'input viene indirizzato a WPF, viene convertito in un messaggio di input non elaborato WPF e inviato al dispatcher.</span><span class="sxs-lookup"><span data-stu-id="f3d28-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="f3d28-209">WPF consente la conversione di eventi di input non elaborati in più eventi effettivi, consentendo l'implementazione di funzionalità come "MouseEnter" a un livello basso del sistema con recapito garantito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="f3d28-210">Ciascun evento di input viene convertito in almeno due eventi: un evento in "anteprima" e l'evento effettivo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="f3d28-211">Tutti gli eventi in WPF hanno una nozione di routing nell'albero degli elementi.</span><span class="sxs-lookup"><span data-stu-id="f3d28-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="f3d28-212">Gli eventi vengono detti "bolle" se passano da una destinazione verso l'alto nell'albero alla radice e vengono detti "tunnel" se iniziano alla radice e passano a una destinazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="f3d28-213">Gli eventi di input in anteprima effettuano il tunneling consentendo a qualsiasi elemento della struttura ad albero di filtrare o svolgere un'azione sull'evento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="f3d28-214">Gli eventi regolari (non in anteprima) vengono propagati dalla destinazione fino alla radice.</span><span class="sxs-lookup"><span data-stu-id="f3d28-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="f3d28-215">Questa suddivisione tra fase di tunneling e fase di bubbling consente di implementare funzionalità, quali i tasti di scelta rapida, in modo coerente in un contesto composito.</span><span class="sxs-lookup"><span data-stu-id="f3d28-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="f3d28-216">In User32 i tasti di scelta rapida vengono implementati con una sola tabella globale che contiene tutti i tasti da supportare (mapping di Ctrl+N su "Nuovo").</span><span class="sxs-lookup"><span data-stu-id="f3d28-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="f3d28-217">Nel dispatcher dell'applicazione viene chiamato **TranslateAccelerator** che rileva la presenza dei messaggi di input in User32 e stabilisce se esiste una corrispondenza con un tasto di scelta rapida registrato.</span><span class="sxs-lookup"><span data-stu-id="f3d28-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="f3d28-218">In WPF questa operazione non funzionerebbe perché il sistema è completamente "componibile", qualsiasi elemento può gestire e utilizzare qualsiasi tasto di scelta rapida.</span><span class="sxs-lookup"><span data-stu-id="f3d28-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="f3d28-219">Questo modello a due fasi per l'input consente ai componenti di implementare il proprio "TranslateAccelerator".</span><span class="sxs-lookup"><span data-stu-id="f3d28-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="f3d28-220">Per eseguire ulteriormente questo passaggio, <xref:System.Windows.UIElement> introduce anche il concetto di CommandBindings.</span><span class="sxs-lookup"><span data-stu-id="f3d28-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="f3d28-221">Il sistema di comandi WPF consente agli sviluppatori di definire le funzionalità in termini di un punto finale del comando, ovvero un elemento che implementa <xref:System.Windows.Input.ICommand>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="f3d28-222">Le associazioni di comandi consentono a un elemento di definire un mapping tra un movimento di input (Ctrl+N) e un comando (Nuovo).</span><span class="sxs-lookup"><span data-stu-id="f3d28-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="f3d28-223">I movimenti di input e le definizioni dei comandi sono estendibili e possono essere collegati al momento dell'utilizzo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="f3d28-224">In tal modo, ad esempio, è possibile consentire a un utente finale di personalizzare le combinazioni di tasti da utilizzare in un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="f3d28-225">Fino a questo punto nell'argomento, le funzionalità di base di WPF, ovvero le funzionalità implementate nell'assembly PresentationCore, hanno avuto lo stato attivo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="f3d28-226">Quando si compila WPF, è stata ottenuta una netta separazione tra le parti fondamentali (ad esempio il contratto per il layout con **misura** e **disposizione**) e le parti del Framework, ad esempio l'implementazione di un layout specifico come <xref:System.Windows.Controls.Grid>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="f3d28-227">Lo scopo era quello di fornire un punto di estendibilità basso nello stack per consentire agli sviluppatori esterni di creare i propri framework, se necessario.</span><span class="sxs-lookup"><span data-stu-id="f3d28-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="f3d28-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="f3d28-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="f3d28-229"><xref:System.Windows.FrameworkElement> possono essere esaminati in due modi diversi.</span><span class="sxs-lookup"><span data-stu-id="f3d28-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="f3d28-230">Introduce un set di criteri e personalizzazioni nei sottosistemi introdotti in livelli inferiori di WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="f3d28-231">e dall'altro un insieme di nuovi sottosistemi.</span><span class="sxs-lookup"><span data-stu-id="f3d28-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="f3d28-232">Il criterio principale introdotto da <xref:System.Windows.FrameworkElement> riguarda il layout dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="f3d28-233"><xref:System.Windows.FrameworkElement> si basa sul contratto di layout di base introdotto da <xref:System.Windows.UIElement> e aggiunge la nozione di "slot" del layout che rende più semplice per gli autori di layout avere un set coerente di semantica di layout basata su Proprietà.</span><span class="sxs-lookup"><span data-stu-id="f3d28-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="f3d28-234">Proprietà quali <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>e <xref:System.Windows.FrameworkElement.Margin%2A> (per citarne alcune) forniscono tutti i componenti derivati da <xref:System.Windows.FrameworkElement> comportamento coerente all'interno dei contenitori di layout.</span><span class="sxs-lookup"><span data-stu-id="f3d28-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="f3d28-235"><xref:System.Windows.FrameworkElement> offre anche un'esposizione più semplice delle API a molte funzionalità disponibili nei livelli principali di WPF.</span><span class="sxs-lookup"><span data-stu-id="f3d28-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="f3d28-236">Ad esempio, <xref:System.Windows.FrameworkElement> fornisce accesso diretto all'animazione tramite il metodo <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="f3d28-237">Un <xref:System.Windows.Media.Animation.Storyboard> consente di creare script per più animazioni rispetto a un set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="f3d28-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="f3d28-238">I due aspetti più importanti che <xref:System.Windows.FrameworkElement> introduce sono data binding e gli stili.</span><span class="sxs-lookup"><span data-stu-id="f3d28-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="f3d28-239">Il sottosistema data binding in WPF dovrebbe essere relativamente familiare a chiunque abbia utilizzato [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] o ASP.NET per la creazione di un'applicazione [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="f3d28-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="f3d28-240">In ciascuno di questi sistemi è possibile effettuare in modo semplice l'associazione di una o più proprietà di un dato elemento a un blocco di dati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="f3d28-241">WPF dispone del supporto completo per l'associazione di proprietà, trasformazione ed elenco.</span><span class="sxs-lookup"><span data-stu-id="f3d28-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="f3d28-242">Una delle funzionalità più interessanti di data binding in WPF è l'introduzione dei modelli di dati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="f3d28-243">che consentono di specificare in modo dichiarativo come deve essere visualizzato un blocco di dati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="f3d28-244">Anziché creare un'interfaccia utente personalizzata che può essere associata ai dati, è possibile aggirare il problema e fare in modo che siano i dati a stabilire il tipo di visualizzazione da creare.</span><span class="sxs-lookup"><span data-stu-id="f3d28-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="f3d28-245">L'applicazione degli stili è effettivamente un tipo di associazione dati semplice</span><span class="sxs-lookup"><span data-stu-id="f3d28-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="f3d28-246">e il suo utilizzo consente di associare un set di proprietà di una definizione condivisa a una o più istanze di un elemento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="f3d28-247">Gli stili vengono applicati a un elemento in base al riferimento esplicito (impostando la proprietà <xref:System.Windows.FrameworkElement.Style%2A>) o in modo implicito associando uno stile al tipo CLR dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="f3d28-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="f3d28-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="f3d28-249">La funzionalità più significativa dei controlli è l'applicazione di modelli.</span><span class="sxs-lookup"><span data-stu-id="f3d28-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="f3d28-250">Considerando il sistema di composizione di WPF come un sistema di rendering in modalità memorizzata, l'applicazione di modelli consente a un controllo di descriverne il rendering in modo dichiarativo e con parametri.</span><span class="sxs-lookup"><span data-stu-id="f3d28-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="f3d28-251">Una <xref:System.Windows.Controls.ControlTemplate> non è nient'altro che uno script per creare un set di elementi figlio, con binding alle proprietà offerte dal controllo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="f3d28-252"><xref:System.Windows.Controls.Control> fornisce un set di proprietà predefinite, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A><xref:System.Windows.Controls.Control.Padding%2A>, per citarne alcuni, che possono quindi essere utilizzati dagli autori di modelli per personalizzare la visualizzazione di un controllo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="f3d28-253">L'implementazione di un controllo fornisce un modello dati e un modello di interazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="f3d28-254">Il modello di interazione definisce un set di comandi (ad esempio, Chiudi per una finestra) e di associazioni a movimenti di input (ad esempio, fare clic sulla X rossa nell'angolo superiore della finestra).</span><span class="sxs-lookup"><span data-stu-id="f3d28-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="f3d28-255">Il modello dati fornisce un set di proprietà per la personalizzazione del modello di interazione o della visualizzazione (stabilita dal modello).</span><span class="sxs-lookup"><span data-stu-id="f3d28-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="f3d28-256">Questa suddivisione tra modello dati (proprietà), modello di interazione (comandi ed eventi) e modello di visualizzazione (modelli) consente una personalizzazione completa dell'aspetto e del comportamento di un controllo.</span><span class="sxs-lookup"><span data-stu-id="f3d28-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="f3d28-257">Una caratteristica comune del modello dati dei controlli è il modello di contenuto.</span><span class="sxs-lookup"><span data-stu-id="f3d28-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="f3d28-258">Se si osserva un controllo come <xref:System.Windows.Controls.Button>, si noterà che è presente una proprietà denominata "Content" di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f3d28-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="f3d28-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] e ASP.NET questa proprietà è in genere una stringa, ma limita il tipo di contenuto che è possibile inserire in un pulsante.</span><span class="sxs-lookup"><span data-stu-id="f3d28-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="f3d28-260">Il contenuto di un pulsante può essere una stringa semplice, un oggetto dati complesso o l'intera struttura ad albero di un elemento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="f3d28-261">Nel caso di un oggetto dati, il modello dati viene utilizzato per costruire una visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="f3d28-262">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="f3d28-262">Summary</span></span>  
 <span data-ttu-id="f3d28-263">WPF è progettato per consentire la creazione di sistemi di presentazione dinamici basati sui dati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="f3d28-264">Ogni parte del sistema è progettata per la creazione di oggetti utilizzando set di proprietà che ne definiscono il comportamento.</span><span class="sxs-lookup"><span data-stu-id="f3d28-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="f3d28-265">L'associazione dati è una parte fondamentale del sistema ed è integrata a ogni livello.</span><span class="sxs-lookup"><span data-stu-id="f3d28-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="f3d28-266">Le applicazioni tradizionali creano una visualizzazione e associano successivamente i dati.</span><span class="sxs-lookup"><span data-stu-id="f3d28-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="f3d28-267">In WPF tutte le informazioni sul controllo, ogni aspetto dello schermo, vengono generate da un tipo di data binding.</span><span class="sxs-lookup"><span data-stu-id="f3d28-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="f3d28-268">Il testo che si trova nei pulsanti viene visualizzato creando un controllo composto all'interno del pulsante e associando la relativa visualizzazione alla proprietà del contenuto del pulsante.</span><span class="sxs-lookup"><span data-stu-id="f3d28-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="f3d28-269">Quando si inizia a sviluppare applicazioni basate su WPF, il suo aspetto è molto familiare.</span><span class="sxs-lookup"><span data-stu-id="f3d28-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="f3d28-270">È possibile impostare proprietà, usare oggetti e associare dati nello stesso modo in cui è possibile usare [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] o ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="f3d28-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET.</span></span> <span data-ttu-id="f3d28-271">Con un'analisi più approfondita dell'architettura di WPF, si noterà che esiste la possibilità di creare applicazioni molto più ricche che considerano fondamentalmente i dati come driver di base dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="f3d28-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f3d28-272">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f3d28-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="f3d28-273">Cenni preliminari sull'associazione dati</span><span class="sxs-lookup"><span data-stu-id="f3d28-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="f3d28-274">Layout</span><span class="sxs-lookup"><span data-stu-id="f3d28-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="f3d28-275">Cenni preliminari sull'animazione</span><span class="sxs-lookup"><span data-stu-id="f3d28-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
