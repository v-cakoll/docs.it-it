---
title: Impostazione degli eventi indirizzati come gestiti e gestione delle classi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 8cce3d1effa163c35cd219a6a52504b0f4d98c73
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/28/2019
ms.locfileid: "64598649"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="fd4e8-102">Impostazione degli eventi indirizzati come gestiti e gestione delle classi</span><span class="sxs-lookup"><span data-stu-id="fd4e8-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="fd4e8-103">I gestori per un evento indirizzato possono contrassegnare l'evento come gestito all'interno dei dati dell'evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="fd4e8-104">La gestione dell'evento abbrevia efficacemente la route.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="fd4e8-105">La gestione delle classi è un concetto di programmazione supportato dagli eventi indirizzati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="fd4e8-106">Un gestore classi ha l'opportunità di gestire un evento indirizzato specifico a livello di classe con un gestore richiamato prima di qualsiasi gestore istanze in qualsiasi istanza di classe.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="fd4e8-107">Prerequisiti</span><span class="sxs-lookup"><span data-stu-id="fd4e8-107">Prerequisites</span></span>  
 <span data-ttu-id="fd4e8-108">Questo argomento elabora i concetti introdotti in [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="fd4e8-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="fd4e8-109">Quando contrassegnare eventi come gestiti</span><span class="sxs-lookup"><span data-stu-id="fd4e8-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="fd4e8-110">Quando si imposta il valore della <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà `true` nell'evento dati per un evento indirizzato, ciò è detto "contrassegnare l'evento come gestito".</span><span class="sxs-lookup"><span data-stu-id="fd4e8-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="fd4e8-111">Non esiste una regola assoluta riguardo a quando contrassegnare gli eventi indirizzati come gestiti, né per un autore di applicazioni né per un autore di controlli che risponde a eventi indirizzati esistenti o implementa nuovi eventi indirizzati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="fd4e8-112">Per la maggior parte dei casi, il concetto di "gestito" se applicato ai dati dell'evento indirizzato deve essere usato come protocollo limitato per le risposte dell'applicazione a diversi eventi indirizzati esposti nelle [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché per tutti gli eventi indirizzati personalizzati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="fd4e8-113">Un altro modo di considerare il concetto di "gestito" è che in genere è necessario contrassegnare un evento indirizzato come gestito se il codice ha risposto all'evento indirizzato in modo significativo e relativamente completo.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="fd4e8-114">In genere, deve essere presente una sola risposta significativa che richiede implementazioni del gestore separate per qualsiasi singola occorrenza di un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="fd4e8-115">Se sono necessarie più risposte, il codice richiesto deve essere implementato tramite logica dell'applicazione concatenata a un singolo gestore, anziché usare il sistema degli eventi indirizzati per l'inoltro.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="fd4e8-116">Anche il concetto di "significativo" è soggettivo e dipende dall'applicazione o dal codice.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="fd4e8-117">Come indicazione generale, ecco alcuni esempi di "risposta significativa": impostazione dello stato attivo, modifica dello stato pubblico, impostazione delle proprietà che influiscono sulla rappresentazione visiva e generazione di altri nuovi eventi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="fd4e8-118">Ecco inoltre alcuni esempi di risposte non significative: modifica dello stato privato (senza alcun impatto visivo o sulla rappresentazione programmatica), registrazione di eventi o esame degli argomenti di un evento e scelta di non rispondervi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="fd4e8-119">Il comportamento del sistema eventi indirizzati rafforza questo modello di "risposta significativa" per l'uso dello stato gestito di un evento indirizzato, perché i gestori aggiunti in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] o la firma comune di <xref:System.Windows.UIElement.AddHandler%2A> non vengono richiamati in risposta a un evento indirizzato in cui l'evento i dati sono già contrassegnato come gestiti.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="fd4e8-120">È necessario eseguire un'ulteriore operazione di aggiunta di un gestore con la `handledEventsToo` versione del parametro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) per gestire gli eventi indirizzati contrassegnati come gestiti da partecipanti precedenti nella route dell'evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="fd4e8-121">In alcuni casi, i controlli stessi contrassegnano determinati eventi indirizzati come gestiti.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="fd4e8-122">Un evento indirizzato gestito rappresenta una decisione da parte degli autori di controlli [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in base alla quale le azioni del controllo in risposta all'evento indirizzato sono significative o complete come parte dell'implementazione del controllo e che l'evento non richiede gestione aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="fd4e8-123">Questo avviene in genere aggiungendo un gestore classi per un evento oppure eseguendo l'override di uno dei metodi virtuali del gestore classi presenti in una classe base.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="fd4e8-124">Se necessario, è comunque possibile trovare soluzioni alternative per questa gestione degli eventi. Vedere [Soluzioni alternative all'eliminazione di eventi da parte dei controlli](#WorkingAroundEventSuppressionByControls) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="fd4e8-125">Confronto tra eventi (di tunneling) "di anteprima" ed eventi di bubbling e gestione degli eventi</span><span class="sxs-lookup"><span data-stu-id="fd4e8-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="fd4e8-126">Gli eventi indirizzati di anteprima sono eventi che seguono una route di tunneling attraverso l'albero degli elementi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="fd4e8-127">Il termine "anteprima" usato nella convenzione di denominazione è indicativo del principio generale per gli eventi di input in base al quale gli eventi indirizzati (di tunneling) di anteprima vengono generati prima dell'evento indirizzato di bubbling equivalente.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="fd4e8-128">Inoltre, gli eventi indirizzati di input dotati di una coppia di tunneling e bubbling hanno una logica di gestione distinta.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="fd4e8-129">Se l'evento indirizzato di tunneling/anteprima viene contrassegnato come gestito da un listener di eventi, l'evento indirizzato di bubbling verrà contrassegnato come gestito anche prima che qualsiasi listener dell'evento indirizzato di bubbling lo riceva.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="fd4e8-130">Gli eventi indirizzati di tunneling e bubbling sono tecnicamente eventi separati, ma condividono intenzionalmente la stessa istanza dei dati degli eventi per permettere questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="fd4e8-131">La connessione tra gli eventi indirizzati di tunneling e bubbling viene eseguita tramite l'implementazione interna del modo in cui ogni classe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifica genera i propri eventi indirizzati dichiarati e questo avviene per gli eventi indirizzati di input associati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="fd4e8-132">Tuttavia, se questa implementazione a livello di classe non esiste, non vi è alcuna connessione tra un evento indirizzato di tunneling e un evento indirizzato di bubbling che condividono lo schema di denominazione: senza questa implementazione, i due eventi indirizzati sono completamente separati e non vengono generati in sequenza né condividono i dati degli eventi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="fd4e8-133">Per altre informazioni su come implementare coppie di eventi indirizzati di input di tunneling/bubbling in una classe personalizzata, vedere [Creare un evento indirizzato personalizzato](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="fd4e8-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="fd4e8-134">Gestori classi e gestori istanze</span><span class="sxs-lookup"><span data-stu-id="fd4e8-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="fd4e8-135">Gli eventi indirizzati considerano due tipi diversi di listener per l'evento: listener di classi e listener di istanze.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="fd4e8-136">I listener di classe esistano perché i tipi hanno chiamato un determinato <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, nel proprio costruttore statico o hanno eseguito l'override di un metodo virtuale del gestore della classe dalla classe di base di un elemento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="fd4e8-137">Listener di istanze sono istanze/elementi di classe specifico in cui sono stati associati uno o più gestori per l'evento indirizzato da una chiamata a <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="fd4e8-138">Esistente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] gli eventi indirizzati di effettuano chiamate a <xref:System.Windows.UIElement.AddHandler%2A> come parte delle [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper di eventi aggiungere{} e rimuovere{} implementazioni dell'evento, vale a dire anche come il semplice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] meccanismo di collegamento i gestori di eventi tramite una sintassi per attributi è abilitata.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="fd4e8-139">Pertanto, anche il semplice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] utilizzo equivale in definitiva a una <xref:System.Windows.UIElement.AddHandler%2A> chiamare.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="fd4e8-140">Gli elementi all'interno dell'albero visuale vengono controllati per individuare le eventuali implementazioni di gestori registrati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="fd4e8-141">I gestori vengono potenzialmente richiamati lungo la route, nell'ordine ereditato nel tipo della strategia di routing per l'evento indirizzato specifico.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="fd4e8-142">Ad esempio, gli eventi indirizzati di bubbling richiameranno prima di tutto i gestori collegati allo stesso elemento che ha generato l'evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="fd4e8-143">L'evento indirizzato viene propagato al successivo elemento padre e così via fino a raggiungere l'elemento radice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="fd4e8-144">Dal punto di vista dell'elemento radice in una route di bubbling, se la gestione delle classi o qualsiasi elemento più vicino all'origine dell'evento indirizzato richiama gestori che contrassegnano gli argomenti dell'evento come gestiti, i gestori negli elementi radice non vengono richiamati e la route dell'evento viene abbreviata in modo efficace prima di raggiungere l'elemento radice.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="fd4e8-145">Tuttavia, la route non viene completamente interrotta, perché è possibile aggiungere gestori con una speciale condizione in base alla quale devono comunque essere richiamati, anche se un gestore classi o un gestore istanze ha contrassegnato l'evento indirizzato come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="fd4e8-146">Questo comportamento viene descritto in [Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="fd4e8-147">A un livello più profondo rispetto a quello della route degli eventi esistono potenzialmente anche più gestori classi che agiscono su qualsiasi istanza specifica di una classe.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="fd4e8-148">Questo avviene perché il modello di gestione delle classi per eventi indirizzati permette a tutte le possibili classi in una gerarchia di classi di registrare ciascuna il proprio gestore classi per ogni evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="fd4e8-149">Ogni gestore classi viene aggiunto a un archivio interno e quando viene creata la route degli eventi per un'applicazione, i gestori classi vengono tutti aggiunti alla route.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="fd4e8-150">I gestori classi vengono aggiunti alla route in modo che venga richiamato per primo il gestore della classe più derivata, richiamando quindi i gestori classi da ogni classe base successiva.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="fd4e8-151">In genere i gestori classi non sono registrati in modo da rispondere anche a eventi indirizzati già contrassegnati come gestiti.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="fd4e8-152">Di conseguenza, questo meccanismo di gestione delle classi permette di scegliere tra due opzioni:</span><span class="sxs-lookup"><span data-stu-id="fd4e8-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="fd4e8-153">Le classi derivate possono completare la gestione delle classi ereditata dalla classe base aggiungendo un gestore che non contrassegna l'evento indirizzato come gestito, perché il gestore della classe base verrà richiamato in un momento successivo al gestore delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="fd4e8-154">Le classi derivate possono sostituire la gestione delle classi dalla classe base tramite l'aggiunta di un gestore classi che contrassegna l'evento indirizzato come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="fd4e8-155">È necessario usare questo approccio con cautela, perché potrebbe modificare la progettazione dei controlli di base desiderata, ad esempio in aree come l'aspetto visivo, la logica di stato, la gestione degli input e la gestione dei comandi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="fd4e8-156">Gestione delle classi degli eventi indirizzati tramite classi di base dei controlli</span><span class="sxs-lookup"><span data-stu-id="fd4e8-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="fd4e8-157">Nel nodo di ogni elemento specifico in una route di eventi i listener di classi possono rispondere all'evento indirizzato prima di qualsiasi listener di istanze per l'elemento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="fd4e8-158">Per questo motivo, i gestori classi vengono usati talvolta per eliminare gli eventi indirizzati che l'implementazione di una determinata classe di controlli non desidera propagare ulteriormente oppure per fornire una gestione speciale dell'evento indirizzato che è una caratteristica della classe.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="fd4e8-159">Ad esempio, una classe potrebbe generare il proprio evento specifico della classe che contiene più specifiche sul significato di una certa condizione di input utente nel contesto di una determinata classe.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="fd4e8-160">L'implementazione della classe potrebbe quindi contrassegnare come gestito l'evento indirizzato più generale.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="fd4e8-161">I gestori classi vengono generalmente aggiunti in modo che non vengano richiamati per instradati gli eventi in cui i dati degli eventi condivisi sono già stati contrassegnati come gestiti, ma per alcuni casi è inoltre disponibile un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> firma che registra i gestori classi per richiamare anche se non sono eventi indirizzati contrassegnato come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="fd4e8-162">Metodi virtuali dei gestori classi</span><span class="sxs-lookup"><span data-stu-id="fd4e8-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="fd4e8-163">Alcuni elementi, in particolare gli elementi di base, ad esempio <xref:System.Windows.UIElement>, espongono vuoto "in \* evento" e "OnPreview\*evento" metodi virtuali che corrispondono al rispettivo elenco degli eventi indirizzati pubblici.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="fd4e8-164">È possibile eseguire l'override di questi metodi virtuali per implementare un gestore classi per l'evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="fd4e8-165">Le classi di elementi di base registrano questi metodi virtuali come gestori classi per ognuno di tali basata sul routing di eventi utilizzando <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> come descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="fd4e8-166">I metodi virtuali On\*Event semplificano notevolmente l'implementazione della gestione delle classi per gli eventi indirizzati pertinenti, senza richiedere attività di inizializzazione speciali nei costruttori statici per ogni tipo.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="fd4e8-167">Ad esempio, è possibile aggiungere la gestione delle classi il <xref:System.Windows.UIElement.DragEnter> eventi in uno <xref:System.Windows.UIElement> classe derivata eseguendo l'override di <xref:System.Windows.UIElement.OnDragEnter%2A> metodo virtuale.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="fd4e8-168">All'interno dell'override è possibile gestire l'evento indirizzato, generare altri eventi, avviare una logica specifica della classe che può modificare le proprietà degli elementi nelle istanze o scegliere qualsiasi combinazione di queste azioni.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="fd4e8-169">È in genere consigliabile chiamare l'implementazione base in questi override, anche se si contrassegna l'evento come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="fd4e8-170">La chiamata dell'implementazione base è fortemente consigliata perché il metodo virtuale è incluso nella classe base.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="fd4e8-171">Il modello virtuale protetto standard costituito dalla chiamata delle implementazioni base da ogni metodo virtuale essenzialmente sostituisce ed eguaglia un meccanismo simile che è nativo per la gestione delle classi degli eventi indirizzati, in cui i gestori classi per tutte le classi in una gerarchia di classi vengono chiamati in qualsiasi istanza specifica, a partire dal gestore della classe più derivata e continuando fino al gestore della classe base.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="fd4e8-172">È necessario omettere la chiamata dell'implementazione base solo se la classe prevede un requisito intenzionale relativo alla modifica della logica di gestione delle classi base.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="fd4e8-173">Se si chiamerà l'implementazione base prima o dopo l'override del codice dipende dalla natura dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="fd4e8-174">Gestione delle classi degli eventi di input</span><span class="sxs-lookup"><span data-stu-id="fd4e8-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="fd4e8-175">I metodi virtuali dei gestori classi vengono tutti registrati in modo da essere richiamati solo in presenza di dati degli eventi condivisi che non sono già stati contrassegnati come gestiti.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="fd4e8-176">Inoltre, solo per gli eventi di input, le versioni di tunneling e bubbling vengono normalmente generate in sequenza e condividono i dati degli eventi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="fd4e8-177">Di conseguenza, per una specifica coppia di gestori classi di eventi di input in cui uno corrisponde alla versione di tunneling e l'altro alla versione di bubbling, si potrebbe non voler contrassegnare immediatamente l'evento come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="fd4e8-178">Se si implementa il metodo virtuale della gestione delle classi di tunneling per contrassegnare l'evento come gestito, si impedirà al gestore classi di bubbling di essere richiamato, oltre a impedire la chiamata dei gestori istanze normalmente registrati per l'evento di tunneling o di bubbling.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="fd4e8-179">Quando la gestione delle classi in un nodo è completa, vengono presi in considerazione i listener di istanze.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="fd4e8-180">Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti</span><span class="sxs-lookup"><span data-stu-id="fd4e8-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="fd4e8-181">Il <xref:System.Windows.UIElement.AddHandler%2A> metodo fornisce un overload specifico che consente di aggiungere gestori che verranno richiamati dal sistema degli eventi ogni volta che un evento raggiunge l'elemento di gestione nella route, anche se un altro gestore ha già modificato i dati dell'evento per contrassegnare che evento come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="fd4e8-182">Questo non è il comportamento più comune.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-182">This is not typically done.</span></span> <span data-ttu-id="fd4e8-183">In genere, i gestori possono essere scritti in modo da modificare tutte le aree del codice dell'applicazione che potrebbero essere influenzate da un evento, indipendentemente dal punto in cui questo è stato gestito nell'albero degli elementi, anche nei casi in cui si desiderano più risultati finali.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="fd4e8-184">Inoltre, in genere, un solo elemento deve rispondere all'evento e la logica dell'applicazione appropriata è già stata applicata.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="fd4e8-185">Tuttavia, è disponibile l'overload `handledEventsToo` per i casi eccezionali in cui un altro elemento in un albero di elementi o in una composizione di controlli ha già contrassegnato un evento come gestito, ma altri elementi in posizione superiore o inferiore nell'albero degli elementi (a seconda della route) vogliono comunque che i rispettivi gestori vengano richiamati.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="fd4e8-186">Quando contrassegnare eventi gestiti come non gestiti</span><span class="sxs-lookup"><span data-stu-id="fd4e8-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="fd4e8-187">In generale, gli eventi indirizzati contrassegnati come gestiti non devono essere contrassegnati come non gestiti (<xref:System.Windows.RoutedEventArgs.Handled%2A> reimpostato `false`) anche da gestori che agiscono su `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="fd4e8-188">Tuttavia, alcuni eventi di input hanno rappresentazioni di eventi di alto livello e di livello inferiore che possono sovrapporsi quando l'evento di alto livello viene visualizzato in una posizione nell'albero e quello di basso livello viene visualizzato in un'altra posizione.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="fd4e8-189">Ad esempio, si consideri il caso in cui un elemento figlio è in attesa di un evento di tasto ad alto livello, ad esempio <xref:System.Windows.UIElement.TextInput> mentre un elemento padre è in ascolto, ad esempio a un evento di basso livello <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="fd4e8-190">Se l'elemento padre gestisce l'evento di basso livello, l'evento di livello superiore può essere eliminato anche nell'elemento figlio che dovrebbe avere la prima opportunità di gestire l'evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="fd4e8-191">In queste situazioni può essere necessario aggiungere gestori sia agli elementi padre sia agli elementi figlio per l'evento di basso livello.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="fd4e8-192">L'implementazione del gestore dell'elemento figlio può contrassegnare l'evento di basso livello come gestito, ma l'implementazione del gestore dell'elemento padre lo imposterebbe di nuovo come non gestito per permettere ad altri elementi di livello superiore nell'albero (nonché all'evento di alto livello) di rispondere.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="fd4e8-193">Questa situazione dovrebbe essere piuttosto rara.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="fd4e8-194">Eliminazione intenzionale di eventi di input per la composizione dei controlli</span><span class="sxs-lookup"><span data-stu-id="fd4e8-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="fd4e8-195">Lo scenario principale in cui viene usata la gestione delle classi per eventi indirizzati riguarda gli eventi di input e i controlli compositi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="fd4e8-196">Un controllo composito è per definizione composto da più controlli pratici o classi base di controlli.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="fd4e8-197">Spesso l'autore del controllo desidera comporre in modo uniforme tutti i possibili eventi di input che possono essere generati da ognuno dei sottocomponenti, per segnalare l'intero controllo come singola origine evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="fd4e8-198">In alcuni casi, l'autore del controllo potrebbe desiderare di eliminare interamente gli eventi dai componenti oppure sostituire un evento definito da un componente che contiene più informazioni o implica un comportamento più specifico.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="fd4e8-199">L'esempio classico immediatamente evidente a qualsiasi autore di componenti è come una [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> gestisce qualsiasi evento del mouse che verrà risolto nell'evento intuitivo tutti i pulsanti: un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="fd4e8-200">Il <xref:System.Windows.Controls.Button> classe di base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva da <xref:System.Windows.Controls.Control> che a sua volta deriva da <xref:System.Windows.FrameworkElement> e <xref:System.Windows.UIElement>e gran parte dell'infrastruttura di evento necessaria per l'elaborazione dell'input del controllo è disponibile all'indirizzo il <xref:System.Windows.UIElement> livello.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="fd4e8-201">In particolare <xref:System.Windows.UIElement> elabora generali <xref:System.Windows.Input.Mouse> eventi che gestiscono gli hit test per il cursore del mouse all'interno dei limiti e fornisce eventi distinti per i più comuni sul pulsante azioni, ad esempio <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="fd4e8-202"><xref:System.Windows.UIElement> fornisce inoltre un oggetto virtuale vuoto <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> come il gestore classi preregistrato <xref:System.Windows.UIElement.MouseLeftButtonDown>, e <xref:System.Windows.Controls.Primitives.ButtonBase> ne esegue l'override.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="fd4e8-203">Analogamente, <xref:System.Windows.Controls.Primitives.ButtonBase> Usa gestori di classi per <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="fd4e8-204">Nell'override, a cui vengono passati i dati dell'evento, le implementazioni contrassegnano che <xref:System.Windows.RoutedEventArgs> dell'istanza come gestita impostando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `true`, e che i dati dell'evento stesso sono continuano lungo il resto della route da altri gestori di classi e anche a gestori istanze o setter di eventi.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="fd4e8-205">Inoltre, il <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override successivamente genererà il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="fd4e8-206">Il risultato finale per la maggior parte dei listener sarà che il <xref:System.Windows.UIElement.MouseLeftButtonDown> e <xref:System.Windows.UIElement.MouseLeftButtonUp> eventi "scompaiono" e la relativa sostituzione con <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un evento più significativo poiché è noto che questo evento ha avuto origine da un pulsante true e non solo alcuni composito di parti del pulsante o da un altro elemento interamente.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="fd4e8-207">Soluzioni alternative all'eliminazione di eventi da parte dei controlli</span><span class="sxs-lookup"><span data-stu-id="fd4e8-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="fd4e8-208">A volte questo comportamento di eliminazione di eventi all'interno di singoli controlli può interferire con alcune intenzioni più generali della logica di gestione degli eventi per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="fd4e8-209">Ad esempio, se per qualche motivo l'applicazione include un gestore per <xref:System.Windows.UIElement.MouseLeftButtonDown> si trova in corrispondenza dell'elemento radice dell'applicazione, è possibile notare che qualsiasi clic del mouse su un pulsante non richiama <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> gestori eventi a livello di radice.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="fd4e8-210">L'evento stesso è stato effettivamente propagato. Come già detto, le route degli eventi non vengono davvero completate, ma il sistema degli eventi indirizzati ne modifica il comportamento di chiamata del gestore dopo che gli eventi sono stati contrassegnati come gestiti.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="fd4e8-211">Quando l'evento indirizzato raggiunge il pulsante, il <xref:System.Windows.Controls.Primitives.ButtonBase> la gestione delle classi contrassegnato il <xref:System.Windows.UIElement.MouseLeftButtonDown> gestito perché per sostituire il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventi con maggiore significato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="fd4e8-212">Pertanto, qualsiasi standard <xref:System.Windows.UIElement.MouseLeftButtonDown> gestore più avanzato le route non viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="fd4e8-213">Esistono due tecniche che è possibile usare per garantire che i gestori vengano richiamati in questo caso.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="fd4e8-214">La prima tecnica consiste nell'aggiungere intenzionalmente il gestore usando il `handledEventsToo` firma dei <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="fd4e8-215">Una limitazione di questo approccio è che la tecnica di collegamento di un gestore eventi è possibile solo dal codice, non dal markup.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="fd4e8-216">La semplice sintassi per specificare il nome del gestore eventi come valore di attributo dell'evento tramite [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] non permette questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="fd4e8-217">La seconda tecnica può essere usata solo per gli eventi di input, le cui versioni di tunneling e bubbling dell'evento indirizzato sono associate.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="fd4e8-218">Per questi eventi indirizzati, è invece possibile aggiungere gestori all'evento indirizzato di anteprima/tunneling equivalente.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="fd4e8-219">Poiché l'evento indirizzato percorre tramite tunneling la route a partire dalla radice, il codice di gestione delle classi del pulsante non lo intercetta, presumendo che il gestore di anteprima sia stato collegato a livello di un elemento predecessore nell'albero degli elementi dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="fd4e8-220">Se si usa questo approccio, contrassegnare con cautela qualsiasi evento di anteprima come gestito.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="fd4e8-221">Per l'esempio fornito con <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> gestito nell'elemento radice, se è stata contrassegnata come dell'evento <xref:System.Windows.RoutedEventArgs.Handled%2A> nell'implementazione del gestore, verrà in realtà eliminato il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="fd4e8-222">Questo non è un comportamento consigliato.</span><span class="sxs-lookup"><span data-stu-id="fd4e8-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd4e8-223">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="fd4e8-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="fd4e8-224">Eventi di anteprima</span><span class="sxs-lookup"><span data-stu-id="fd4e8-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="fd4e8-225">Creare un evento indirizzato personalizzato</span><span class="sxs-lookup"><span data-stu-id="fd4e8-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="fd4e8-226">Cenni preliminari sugli eventi indirizzati</span><span class="sxs-lookup"><span data-stu-id="fd4e8-226">Routed Events Overview</span></span>](routed-events-overview.md)
