---
title: Metodo ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 12ef215253ca02048a5a3fc2c7c682823233929f
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/23/2019
ms.locfileid: "61779821"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="e2f02-102">Metodo ICorProfilerInfo2::DoStackSnapshot</span><span class="sxs-lookup"><span data-stu-id="e2f02-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="e2f02-103">Descrive i frame gestiti nello stack per il thread specificato e invia informazioni al profiler tramite un callback.</span><span class="sxs-lookup"><span data-stu-id="e2f02-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="e2f02-104">Sintassi</span><span class="sxs-lookup"><span data-stu-id="e2f02-104">Syntax</span></span>  
  
```  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="e2f02-105">Parametri</span><span class="sxs-lookup"><span data-stu-id="e2f02-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="e2f02-106">[in] L'ID del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="e2f02-107">Il passaggio di null in `thread` viene generato uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="e2f02-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="e2f02-108">Se un `ThreadID` di viene passato un altro thread, common language runtime (CLR) sospende il thread in questione, esegue lo snapshot e viene ripresa.</span><span class="sxs-lookup"><span data-stu-id="e2f02-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="e2f02-109">[in] Un puntatore all'implementazione del [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) metodo, che viene chiamata da CLR per fornire il profiler con le informazioni su ogni frame gestito e ogni esecuzione dei frame non gestiti.</span><span class="sxs-lookup"><span data-stu-id="e2f02-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="e2f02-110">Il `StackSnapshotCallback` metodo è implementato dal writer del profiler.</span><span class="sxs-lookup"><span data-stu-id="e2f02-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="e2f02-111">[in] Valore di [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumerazione che specifica la quantità di dati da passare per ciascun frame `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="e2f02-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="e2f02-112">[in] Un puntatore ai dati client, che vengano passati direttamente tramite il `StackSnapshotCallback` funzione di callback.</span><span class="sxs-lookup"><span data-stu-id="e2f02-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="e2f02-113">[in] Un puntatore a un Win32 `CONTEXT` struttura, che viene utilizzato per inizializzare il percorso dello stack.</span><span class="sxs-lookup"><span data-stu-id="e2f02-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="e2f02-114">Win32 `CONTEXT` struttura contiene i valori dei registri della CPU e rappresenta lo stato della CPU in un determinato momento nel tempo.</span><span class="sxs-lookup"><span data-stu-id="e2f02-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="e2f02-115">Il valore di inizializzazione consente a CLR di determinare il punto di inizio analisi dello stack, se l'inizio dello stack del codice di supporto non gestita; in caso contrario, il valore di inizializzazione viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="e2f02-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="e2f02-116">Per una verifica asincrona, è necessario specificare un valore di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="e2f02-117">Se si sta eseguendo una procedura sincrona, non è necessario alcun valore di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="e2f02-118">Il `context` parametro è valido solo se è stato passato il flag COR_PRF_SNAPSHOT_CONTEXT il `infoFlags` parametro.</span><span class="sxs-lookup"><span data-stu-id="e2f02-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="e2f02-119">[in] Le dimensioni dei `CONTEXT` struttura, a cui fa riferimento il `context` parametro.</span><span class="sxs-lookup"><span data-stu-id="e2f02-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="e2f02-120">Note</span><span class="sxs-lookup"><span data-stu-id="e2f02-120">Remarks</span></span>  
 <span data-ttu-id="e2f02-121">Passare null per `thread` viene generato uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="e2f02-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="e2f02-122">Gli snapshot possono essere creati degli altri thread solo se il thread di destinazione viene sospeso al momento.</span><span class="sxs-lookup"><span data-stu-id="e2f02-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="e2f02-123">Quando il profiler richiede la analizzare lo stack, chiama `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="e2f02-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="e2f02-124">Prima che Common Language Runtime restituito dalla chiamata, viene chiamato il `StackSnapshotCallback` più volte, una volta per ogni frame gestito (o esecuzione di frame non gestiti) nello stack.</span><span class="sxs-lookup"><span data-stu-id="e2f02-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="e2f02-125">Quando vengono rilevati i frame non gestiti, è necessario verificarli manualmente.</span><span class="sxs-lookup"><span data-stu-id="e2f02-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="e2f02-126">L'ordine in cui viene esaminato lo stack è il contrario del modo in cui i frame sono stati inseriti nello stack: foglia ultimo fotogramma (inserito per ultimo) prima di tutto, principale fotogramma (inserito per primo).</span><span class="sxs-lookup"><span data-stu-id="e2f02-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="e2f02-127">Per altre informazioni sulla programmazione del profiler per esaminare chiamate negli stack gestiti, vedere [analisi dello Stack del Profiler in .NET Framework 2.0: Concetti di base e](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="e2f02-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>  
  
 <span data-ttu-id="e2f02-128">Un percorso stack può essere sincrono o asincrono, come illustrato nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="e2f02-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="e2f02-129">Analisi dello stack sincrono</span><span class="sxs-lookup"><span data-stu-id="e2f02-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="e2f02-130">Un percorso stack sincrona prevede i percorsi nello stack del thread corrente in risposta a un callback.</span><span class="sxs-lookup"><span data-stu-id="e2f02-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="e2f02-131">Non richiede il seeding o sospensione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="e2f02-132">Rendere sincrono, chiamare in risposta a CLR una chiamata a uno del profiler [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (o [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) metodi, si chiama `DoStackSnapshot` per analizzare lo stack del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="e2f02-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="e2f02-133">Ciò è utile quando si desidera visualizzare lo stack di un aspetto analogo a una notifica, ad esempio [ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="e2f02-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="e2f02-134">È sufficiente chiamare `DoStackSnapshot` dall'interno di `ICorProfilerCallback` metodo, il passaggio di null nel `context` e `thread` parametri.</span><span class="sxs-lookup"><span data-stu-id="e2f02-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="e2f02-135">Analisi dello stack asincrona</span><span class="sxs-lookup"><span data-stu-id="e2f02-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="e2f02-136">Un percorso stack asincrona comporta i percorsi nello stack di un altro thread o i percorsi nello stack del thread corrente, non in risposta a un callback, ma assumendo puntatore dell'istruzione del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="e2f02-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="e2f02-137">Una verifica asincrona richiede un valore di inizializzazione se l'inizio dello stack è il codice non gestito che non fa parte di una piattaforma invoke (PInvoke) o chiamata COM, ma il codice helper in CLR.</span><span class="sxs-lookup"><span data-stu-id="e2f02-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="e2f02-138">Ad esempio, codice che esegue la compilazione o la garbage collection di (JIT) di just-in-time è codice helper.</span><span class="sxs-lookup"><span data-stu-id="e2f02-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="e2f02-139">Per ottenere un valore di inizializzazione, direttamente la sospensione del thread di destinazione e walking relativo stack frame manualmente, fino a individuare il livello più alto gestito.</span><span class="sxs-lookup"><span data-stu-id="e2f02-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="e2f02-140">Dopo che il thread di destinazione viene sospesa, ottenere il contesto di registro corrente del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="e2f02-141">Successivamente, determinare se il contesto di registro punta al codice non gestito mediante la chiamata [GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — se viene restituito un `FunctionID` uguale a zero, il frame è codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="e2f02-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="e2f02-142">A questo punto, analizzare lo stack fino a raggiunge il primo frame gestito e quindi calcola il contesto di inizializzazione basato sul contesto di registro per quel fotogramma.</span><span class="sxs-lookup"><span data-stu-id="e2f02-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="e2f02-143">Chiamare `DoStackSnapshot` con il contesto del valore di inizializzazione per iniziare il percorso stack asincrona.</span><span class="sxs-lookup"><span data-stu-id="e2f02-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="e2f02-144">Se non si specifica un valore di inizializzazione, `DoStackSnapshot` potrebbe ignorare i frame gestiti nella parte superiore dello stack e, di conseguenza, verrà visualizzato un percorso stack incompleto.</span><span class="sxs-lookup"><span data-stu-id="e2f02-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="e2f02-145">Se si specifica un valore di inizializzazione, deve puntare a compilazione JIT o Native Image Generator (Ngen.exe)-generato codice. in caso contrario, `DoStackSnapshot` restituisce il codice di errore CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="e2f02-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="e2f02-146">Analisi dello stack asincrona può facilmente causare deadlock o violazioni di accesso, a meno che non si seguono queste linee guida:</span><span class="sxs-lookup"><span data-stu-id="e2f02-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="e2f02-147">Quando si sospendono direttamente thread, tenere presente che solo un thread che non ha mai eseguito il codice gestito può sospendere un altro thread.</span><span class="sxs-lookup"><span data-stu-id="e2f02-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="e2f02-148">Blocca sempre [ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback fino al completamento dello stack del thread.</span><span class="sxs-lookup"><span data-stu-id="e2f02-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="e2f02-149">Non mantenere un blocco mentre il profiler chiama una funzione CLR che possono attivare una garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e2f02-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="e2f02-150">Vale a dire, non mantenere un blocco se il thread proprietario può effettuare una chiamata che attiva un'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e2f02-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="e2f02-151">È inoltre disponibile un rischio di deadlock se si chiama `DoStackSnapshot` da un thread che ha creato il profiler in modo che è possibile analizzare lo stack di un thread di destinazione distinto.</span><span class="sxs-lookup"><span data-stu-id="e2f02-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="e2f02-152">La prima volta che il thread è stato creato viene inserito determinati `ICorProfilerInfo*` metodi (inclusi `DoStackSnapshot`), CLR dovrà eseguire per ogni thread, l'inizializzazione di CLR specifici su tale thread.</span><span class="sxs-lookup"><span data-stu-id="e2f02-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="e2f02-153">Se il profiler ha sospeso il thread di destinazione cui stack desiderata per esaminare e se il thread di destinazione è successo a un blocco di proprietà necessario per eseguire tale inizializzazione per ogni thread, si verificherà un deadlock.</span><span class="sxs-lookup"><span data-stu-id="e2f02-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="e2f02-154">Per evitare il deadlock, effettuare una chiamata iniziale in `DoStackSnapshot` dal thread profiler creato per verificare il thread di destinazione un oggetto separato, ma non sospendere il thread di destinazione prima di tutto.</span><span class="sxs-lookup"><span data-stu-id="e2f02-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="e2f02-155">Questa chiamata iniziale assicura che l'inizializzazione di singoli thread può essere completato senza deadlock.</span><span class="sxs-lookup"><span data-stu-id="e2f02-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="e2f02-156">Se `DoStackSnapshot` ha esito positivo e i report almeno un frame, da quel punto, sarà sicuro per il thread profiler-creazione di sospendere qualsiasi thread di destinazione e chiamare `DoStackSnapshot` per analizzare lo stack di thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="e2f02-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="e2f02-157">Requisiti</span><span class="sxs-lookup"><span data-stu-id="e2f02-157">Requirements</span></span>  
 <span data-ttu-id="e2f02-158">**Piattaforme:** Vedere [Requisiti di sistema](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="e2f02-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="e2f02-159">**Intestazione:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="e2f02-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="e2f02-160">**Libreria:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="e2f02-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="e2f02-161">**Versioni di .NET Framework:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="e2f02-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e2f02-162">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e2f02-162">See also</span></span>

- [<span data-ttu-id="e2f02-163">Interfaccia ICorProfilerInfo</span><span class="sxs-lookup"><span data-stu-id="e2f02-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)
- [<span data-ttu-id="e2f02-164">Interfaccia ICorProfilerInfo2</span><span class="sxs-lookup"><span data-stu-id="e2f02-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
