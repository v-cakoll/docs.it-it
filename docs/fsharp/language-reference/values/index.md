---
title: Valori (F#)
description: Informazioni su come i valori in F# sono quantità che hanno un tipo specifico.
ms.date: 05/16/2016
ms.openlocfilehash: f645481ce8395c11ae920aee06cbf07955aeb684
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/02/2018
ms.locfileid: "45991168"
---
# <a name="values"></a><span data-ttu-id="f73bc-103">Valori</span><span class="sxs-lookup"><span data-stu-id="f73bc-103">Values</span></span>

<span data-ttu-id="f73bc-104">I valori in F# sono quantità che hanno un tipo specifico. I valori possono essere numeri interi o numeri a virgola mobile, caratteri o testo, elenchi, sequenze, matrici, tuple, unioni discriminate, record, tipi di classe o valori di funzioni.</span><span class="sxs-lookup"><span data-stu-id="f73bc-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="f73bc-105">Associazione di un valore</span><span class="sxs-lookup"><span data-stu-id="f73bc-105">Binding a Value</span></span>

<span data-ttu-id="f73bc-106">Il termine *associazione* indica il processo di associare, ovvero collegare, un nome a una definizione.</span><span class="sxs-lookup"><span data-stu-id="f73bc-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="f73bc-107">La parola chiave `let` associa un valore, come illustrato negli esempi seguenti:</span><span class="sxs-lookup"><span data-stu-id="f73bc-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="f73bc-108">Il tipo di valore viene dedotto dalla definizione.</span><span class="sxs-lookup"><span data-stu-id="f73bc-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="f73bc-109">Per un tipo primitivo, ad esempio un numero intero o a virgola mobile, il tipo è determinato dal tipo di valore letterale.</span><span class="sxs-lookup"><span data-stu-id="f73bc-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="f73bc-110">Nell'esempio precedente il compilatore deduce quindi il tipo di `b` come `unsigned int`, mentre il tipo di `a` come `int`.</span><span class="sxs-lookup"><span data-stu-id="f73bc-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="f73bc-111">Il tipo di valore di una funzione è determinato dal valore restituito nel corpo della funzione.</span><span class="sxs-lookup"><span data-stu-id="f73bc-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="f73bc-112">Per altre informazioni sui tipi di valori delle funzioni, vedere [Funzioni](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="f73bc-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="f73bc-113">Per altre informazioni sui tipi di valori letterali, vedere [Valori letterali](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="f73bc-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="f73bc-114">Il compilatore non genera diagnostica sulle associazioni inutilizzate per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="f73bc-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="f73bc-115">Per ricevere questi messaggi, Abilita avviso 1182 nel file di progetto o se l'utilizzo del compilatore (vedere `--warnon` sotto [le opzioni del compilatore](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="f73bc-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="f73bc-116">Valori non modificabili</span><span class="sxs-lookup"><span data-stu-id="f73bc-116">Why Immutable?</span></span>

<span data-ttu-id="f73bc-117">I valori non modificabili sono valori che non possono essere modificati nel corso dell'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="f73bc-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="f73bc-118">Se si ha familiarità con i linguaggi di programmazione, ad esempio, C++, Visual Basic o C#, potrebbe sembrare inconsueto che F# dia più importanza ai valori non modificabili piuttosto che alle variabili alle quali è possibile assegnare nuovi valori durante l'esecuzione di un programma.</span><span class="sxs-lookup"><span data-stu-id="f73bc-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="f73bc-119">I dati non modificabili sono elementi importanti nella programmazione funzionale.</span><span class="sxs-lookup"><span data-stu-id="f73bc-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="f73bc-120">In un ambiente a thread multipli, è molto difficile gestire le variabili condivise che possono essere modificate da thread diversi.</span><span class="sxs-lookup"><span data-stu-id="f73bc-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="f73bc-121">Con le variabili modificabili può talvolta essere anche difficile sapere se una variabile può essere modificata quando viene passata a un'altra funzione.</span><span class="sxs-lookup"><span data-stu-id="f73bc-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="f73bc-122">Nei linguaggi funzionali puri, non ci sono variabili e le funzioni si comportano esattamente come le funzioni matematiche.</span><span class="sxs-lookup"><span data-stu-id="f73bc-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="f73bc-123">Se un codice di un linguaggio procedurale usa un'assegnazione di variabile per modificare un valore, l'equivalente codice in un linguaggio funzionale ha un valore non modificabile che è l'input, una funzione non modificabile e diversi valori non modificabili come output.</span><span class="sxs-lookup"><span data-stu-id="f73bc-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="f73bc-124">Questa precisione matematica consente un ragionamento più rigido sul comportamento del programma.</span><span class="sxs-lookup"><span data-stu-id="f73bc-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="f73bc-125">Questo ragionamento più specifico è ciò che consente ai compilatori di controllare il codice in modo più rigoroso e ottimizzarlo in modo più efficace, rendendo più semplice l'analisi e la scrittura di codice corretto per gli sviluppatori.</span><span class="sxs-lookup"><span data-stu-id="f73bc-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="f73bc-126">È quindi probabilmente più semplice eseguire il debug di codice funzionale rispetto al debug di un codice procedurale ordinario.</span><span class="sxs-lookup"><span data-stu-id="f73bc-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="f73bc-127">F# non è un linguaggio funzionale puro, ma supporta completamente la programmazione funzionale.</span><span class="sxs-lookup"><span data-stu-id="f73bc-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="f73bc-128">L'uso di valori non modificabili è una buona pratica perché ciò consente al codice di trarre vantaggio da un importante aspetto delle programmazione funzionale.</span><span class="sxs-lookup"><span data-stu-id="f73bc-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="f73bc-129">Variabili modificabili</span><span class="sxs-lookup"><span data-stu-id="f73bc-129">Mutable Variables</span></span>

<span data-ttu-id="f73bc-130">È possibile usare la parola chiave `mutable` per specificare una variabile modificabile.</span><span class="sxs-lookup"><span data-stu-id="f73bc-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="f73bc-131">Le variabili modificabili in F# dovrebbero in genere avere un ambito limitato, ad esempio un campo di un tipo o un valore locale.</span><span class="sxs-lookup"><span data-stu-id="f73bc-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="f73bc-132">Le variabili modificabili con un ambito limitato sono più semplici da controllare e hanno meno probabilità di essere modificate in modo incorretto.</span><span class="sxs-lookup"><span data-stu-id="f73bc-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="f73bc-133">È possibile assegnare un valore iniziale a una variabile modificabile tramite la parola chiave `let` nello stesso modo in cui si definisce un valore.</span><span class="sxs-lookup"><span data-stu-id="f73bc-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="f73bc-134">La differenza tuttavia è che successivamente è possibile assegnare nuovi valori alle variabili modificabili tramite l'operatore `<-`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="f73bc-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="f73bc-135">I valori contrassegnati `mutable` può essere automaticamente promossa a `'a ref` se acquisiti da una chiusura, tra cui moduli che creano chiusure, ad esempio `seq` generatori.</span><span class="sxs-lookup"><span data-stu-id="f73bc-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="f73bc-136">Se si vuole ricevere una notifica in questo caso, attivare l'avviso 3180 nel file di progetto o quando si richiama il compilatore.</span><span class="sxs-lookup"><span data-stu-id="f73bc-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f73bc-137">Argomenti correlati</span><span class="sxs-lookup"><span data-stu-id="f73bc-137">Related Topics</span></span>

|<span data-ttu-id="f73bc-138">Titolo</span><span class="sxs-lookup"><span data-stu-id="f73bc-138">Title</span></span>|<span data-ttu-id="f73bc-139">Descrizione</span><span class="sxs-lookup"><span data-stu-id="f73bc-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="f73bc-140">Associazioni let</span><span class="sxs-lookup"><span data-stu-id="f73bc-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="f73bc-141">Fornisce informazioni sull'uso di `let` parola chiave da associare nomi a valori e le funzioni.</span><span class="sxs-lookup"><span data-stu-id="f73bc-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="f73bc-142">Funzioni</span><span class="sxs-lookup"><span data-stu-id="f73bc-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="f73bc-143">Include una panoramica delle funzioni in F#.</span><span class="sxs-lookup"><span data-stu-id="f73bc-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="f73bc-144">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f73bc-144">See also</span></span>

- [<span data-ttu-id="f73bc-145">Valori Null</span><span class="sxs-lookup"><span data-stu-id="f73bc-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="f73bc-146">Riferimenti per il linguaggio F#</span><span class="sxs-lookup"><span data-stu-id="f73bc-146">F# Language Reference</span></span>](../index.md)
