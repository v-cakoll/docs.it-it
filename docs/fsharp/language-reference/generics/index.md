---
title: Generics (F#)
description: "Informazioni su come usare funzioni F # generiche e tipi che consentono di scrivere codice che funziona con un'ampia gamma di tipi senza ripetere codice."
ms.date: 05/16/2016
ms.openlocfilehash: fc061f19c6c7fa737f7ca05aae83fd42c0010b37
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/06/2018
ms.locfileid: "43876132"
---
# <a name="generics"></a><span data-ttu-id="a57a0-103">Generics</span><span class="sxs-lookup"><span data-stu-id="a57a0-103">Generics</span></span>

<span data-ttu-id="a57a0-104">I valori, i metodi, le proprietà delle funzioni F# e i tipi di aggregazione quali classi, record e unioni discriminate possono essere *generici*.</span><span class="sxs-lookup"><span data-stu-id="a57a0-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="a57a0-105">I costrutti generici contengono almeno un parametro di tipo, specificato in genere dall'utente del costrutto generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="a57a0-106">Le funzioni e i tipi generici consentono di scrivere codice che può essere usato con un'ampia gamma di tipi senza ripetere il codice per ogni tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="a57a0-107">In F# è possibile rendere generico un codice in maniera semplice, perché spesso il codice viene dedotto in modo implicito come generico dall'inferenza del tipo di compilatore e dai meccanismi di generalizzazione automatica.</span><span class="sxs-lookup"><span data-stu-id="a57a0-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="a57a0-108">Sintassi</span><span class="sxs-lookup"><span data-stu-id="a57a0-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="a57a0-109">Note</span><span class="sxs-lookup"><span data-stu-id="a57a0-109">Remarks</span></span>

<span data-ttu-id="a57a0-110">La dichiarazione di una funzione o di un tipo esplicitamente generico è molto simile a quella di una funzione o di un tipo non generico, ad eccezione per la specifica (e uso) dei parametri di tipo, che si trovano in parentesi acute dopo il nome della funzione o del tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="a57a0-111">Le dichiarazioni sono spesso implicitamente generiche.</span><span class="sxs-lookup"><span data-stu-id="a57a0-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="a57a0-112">Se non si specifica completamente il tipo di ogni parametro usato per creare una funzione o un tipo, il compilatore prova a dedurre il tipo di ogni parametro, del valore e della variabile dal codice scritto.</span><span class="sxs-lookup"><span data-stu-id="a57a0-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="a57a0-113">Per altre informazioni, vedere [Type Inference](../type-inference.md) (Inferenza del tipo).</span><span class="sxs-lookup"><span data-stu-id="a57a0-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="a57a0-114">Se il codice per il tipo o per la funzione non vincola i tipi di parametri, la funzione o il tipo è implicitamente generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="a57a0-115">Questo processo è denominato *generalizzazione automatica*.</span><span class="sxs-lookup"><span data-stu-id="a57a0-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="a57a0-116">Ci sono alcuni limiti per la generalizzazione automatica.</span><span class="sxs-lookup"><span data-stu-id="a57a0-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="a57a0-117">Ad esempio, se il compilatore F# non è in grado di dedurre i tipi per un costrutto generico, segnala un errore che fa riferimento a una limitazione definita *limitazione valore*.</span><span class="sxs-lookup"><span data-stu-id="a57a0-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="a57a0-118">In tal caso, potrebbe essere necessario aggiungere alcune annotazioni di tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="a57a0-119">Per altre informazioni sulla generalizzazione automatica e la limitazione valori e su come modificare il codice per risolvere il problema, vedere [Generalizzazione automatica](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="a57a0-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="a57a0-120">Nella sintassi precedente, *type-parameters* (parametri_tipo) è un elenco delimitato da virgole di parametri che rappresentano tipi sconosciuti, ognuno dei quali inizia con una virgoletta singola, facoltativamente con una clausola di vincolo che limita ulteriormente i tipi che possono essere usati per il parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="a57a0-121">Per informazioni sui vincoli e sulla sintassi per le clausole di vincolo di vari tipi, vedere [Vincoli](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="a57a0-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="a57a0-122">*type-definition* (definizione_tipo) nella sintassi è identica alla definizione del tipo per un tipo non generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="a57a0-123">Include i parametri del costruttore per un tipo di classe, una clausola `as` facoltativa, il simbolo di uguaglianza, i campi di record, la clausola `inherit`, le opzioni per un'unione discriminata, le associazioni `let` e `do`, le definizioni dei membri e altri elementi consentiti in una definizione di tipo non generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="a57a0-124">Gli altri elementi di sintassi sono gli stessi di quelli per le funzioni e i tipi non generici.</span><span class="sxs-lookup"><span data-stu-id="a57a0-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="a57a0-125">Ad esempio, *object-identifier* (identificatore_oggetto) è un identificatore che rappresenta l'oggetto che contiene se stesso.</span><span class="sxs-lookup"><span data-stu-id="a57a0-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="a57a0-126">Le proprietà, i campi e i costruttori non possono essere più generici del tipo che li contiene.</span><span class="sxs-lookup"><span data-stu-id="a57a0-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="a57a0-127">I valori in un modulo non possono essere generici.</span><span class="sxs-lookup"><span data-stu-id="a57a0-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="a57a0-128">Costrutti implicitamente generici</span><span class="sxs-lookup"><span data-stu-id="a57a0-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="a57a0-129">Quando il compilatore F# deduce i tipi nel codice, considera automaticamente come generica qualsiasi funzione che può essere generica.</span><span class="sxs-lookup"><span data-stu-id="a57a0-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="a57a0-130">Se si specifica un tipo in modo esplicito, ad esempio un tipo di parametro, si evita la generalizzazione automatica.</span><span class="sxs-lookup"><span data-stu-id="a57a0-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="a57a0-131">Nell'esempio di codice seguente, `makeList` è generico, anche se il codice e i relativi parametri non sono dichiarati esplicitamente come generici.</span><span class="sxs-lookup"><span data-stu-id="a57a0-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="a57a0-132">La firma della funzione viene dedotta come `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="a57a0-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="a57a0-133">Si noti che `a` e `b` in questo esempio vengono considerati come elementi dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="a57a0-134">Ciò si verifica perché sono inclusi nello stesso elenco e tutti gli elementi di un elenco devono essere dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="a57a0-135">È anche possibile rendere una funzione generica usando la sintassi con virgoletta singola in un'annotazione di tipo per indicare che un tipo di parametro è un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="a57a0-136">Nel codice seguente, `function1` è generico perché i parametri vengono dichiarati in questo modo, come parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="a57a0-137">Costrutti esplicitamente generici</span><span class="sxs-lookup"><span data-stu-id="a57a0-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="a57a0-138">È anche possibile rendere una funzione generica dichiarando in modo esplicito i parametri di tipo in parentesi acute (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="a57a0-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="a57a0-139">Questa condizione è illustrata nel codice che segue.</span><span class="sxs-lookup"><span data-stu-id="a57a0-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="a57a0-140">Uso di costrutti generici</span><span class="sxs-lookup"><span data-stu-id="a57a0-140">Using Generic Constructs</span></span>

<span data-ttu-id="a57a0-141">Quando si usano funzioni o metodi generici, potrebbe non essere necessario specificare gli argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="a57a0-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="a57a0-142">Il compilatore usa l'inferenza del tipo per dedurre gli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="a57a0-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="a57a0-143">Se c'è ancora ambiguità, è possibile specificare gli argomenti di tipo in parentesi acute, separando più argomenti di tipo con una virgola.</span><span class="sxs-lookup"><span data-stu-id="a57a0-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="a57a0-144">Il codice seguente illustra l'uso delle funzioni definite nelle sezioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a57a0-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

>[!NOTE]
<span data-ttu-id="a57a0-145">Ci sono due modi per fare riferimento a un tipo generico in base al nome.</span><span class="sxs-lookup"><span data-stu-id="a57a0-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="a57a0-146">Ad esempio, `list<int>` e `int list` sono due modi per fare riferimento a un tipo generico `list` che ha un solo argomento di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="a57a0-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="a57a0-147">La seconda forma viene comunemente usata solo con i tipi F# predefiniti, ad esempio `list` e `option`.</span><span class="sxs-lookup"><span data-stu-id="a57a0-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="a57a0-148">Se ci sono più argomenti di tipo, in genere si usa la sintassi `Dictionary<int, string>` ma è anche possibile usare la sintassi `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="a57a0-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="a57a0-149">Caratteri jolly come argomenti di tipo</span><span class="sxs-lookup"><span data-stu-id="a57a0-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="a57a0-150">Per specificare che un argomento di tipo deve essere dedotto dal compilatore, è possibile usare il carattere di sottolineatura o un carattere jolly (`_`), anziché un argomento di tipo denominato.</span><span class="sxs-lookup"><span data-stu-id="a57a0-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="a57a0-151">Questo comportamento viene mostrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="a57a0-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="a57a0-152">Vincoli in funzioni e tipi generici</span><span class="sxs-lookup"><span data-stu-id="a57a0-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="a57a0-153">In una definizione di funzione o tipo generico, è possibile usare solo questi costrutti disponibili nel parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="a57a0-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="a57a0-154">Ciò è necessario per abilitare la verifica delle chiamate di funzioni e metodi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="a57a0-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="a57a0-155">Se si dichiarano in modo esplicito i parametri di tipo, è possibile applicare un vincolo esplicito a un parametro di tipo generico per notificare al compilatore che sono disponibili alcuni metodi e funzioni.</span><span class="sxs-lookup"><span data-stu-id="a57a0-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="a57a0-156">Se tuttavia si consente al compilatore F# di dedurre i tipi di parametri generici, il compilatore determinerà i vincoli appropriati.</span><span class="sxs-lookup"><span data-stu-id="a57a0-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="a57a0-157">Per altre informazioni, vedere [Vincoli](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="a57a0-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="a57a0-158">Parametri di tipo risolti staticamente</span><span class="sxs-lookup"><span data-stu-id="a57a0-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="a57a0-159">Ci sono due tipi di parametri di tipo che possono essere usati in programmi F#.</span><span class="sxs-lookup"><span data-stu-id="a57a0-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="a57a0-160">Il primo tipo include parametri di tipo generico del tipo descritto nelle sezioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="a57a0-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="a57a0-161">Il primo tipo di parametro di tipo è equivalente ai parametri di tipo generico che vengono usati in linguaggi quali Visual Basic e C#.</span><span class="sxs-lookup"><span data-stu-id="a57a0-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="a57a0-162">Un altro tipo di parametro di tipo è specifico di F# e viene definito come *parametro di tipo risolto staticamente*.</span><span class="sxs-lookup"><span data-stu-id="a57a0-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="a57a0-163">Per informazioni su questi costrutti, vedere [Statically Resolved Type Parameters](statically-resolved-type-parameters.md) (Parametri di tipo risolti staticamente).</span><span class="sxs-lookup"><span data-stu-id="a57a0-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="a57a0-164">Esempi</span><span class="sxs-lookup"><span data-stu-id="a57a0-164">Examples</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="a57a0-165">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="a57a0-165">See also</span></span>

- [<span data-ttu-id="a57a0-166">Riferimenti per il linguaggio</span><span class="sxs-lookup"><span data-stu-id="a57a0-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="a57a0-167">Tipi</span><span class="sxs-lookup"><span data-stu-id="a57a0-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="a57a0-168">Parametri di tipo risolti staticamente</span><span class="sxs-lookup"><span data-stu-id="a57a0-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="a57a0-169">Generics in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="a57a0-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="a57a0-170">Generalizzazione automatica</span><span class="sxs-lookup"><span data-stu-id="a57a0-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="a57a0-171">Vincoli</span><span class="sxs-lookup"><span data-stu-id="a57a0-171">Constraints</span></span>](constraints.md)
