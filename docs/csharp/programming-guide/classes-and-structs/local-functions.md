---
title: Funzioni locali - Guida per programmatori C#
description: Le funzioni locali in C# sono metodi privati annidati in un altro membro e possono essere chiamati dal membro contenitore.
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 9987d6d5ad57c1dceb3a4bffbae22a81c240c794
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864527"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="88343-103">Funzioni locali (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="88343-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="88343-104">A partire dalla versione 7.0, C# supporta le *funzioni locali*.</span><span class="sxs-lookup"><span data-stu-id="88343-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="88343-105">Le funzioni locali sono metodi privati di un tipo annidati in un altro membro.</span><span class="sxs-lookup"><span data-stu-id="88343-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="88343-106">Possono essere chiamate solo dal relativo membro contenitore.</span><span class="sxs-lookup"><span data-stu-id="88343-106">They can only be called from their containing member.</span></span> <span data-ttu-id="88343-107">Le funzioni locali, in particolare, possono essere dichiarate in e chiamate da:</span><span class="sxs-lookup"><span data-stu-id="88343-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="88343-108">Metodi, soprattutto metodi iteratori e metodi asincroni</span><span class="sxs-lookup"><span data-stu-id="88343-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="88343-109">Costruttori</span><span class="sxs-lookup"><span data-stu-id="88343-109">Constructors</span></span>
- <span data-ttu-id="88343-110">Funzioni di accesso alle proprietà</span><span class="sxs-lookup"><span data-stu-id="88343-110">Property accessors</span></span>
- <span data-ttu-id="88343-111">Funzioni di accesso agli eventi</span><span class="sxs-lookup"><span data-stu-id="88343-111">Event accessors</span></span>
- <span data-ttu-id="88343-112">Metodi anonimi</span><span class="sxs-lookup"><span data-stu-id="88343-112">Anonymous methods</span></span>
- <span data-ttu-id="88343-113">Espressioni lambda</span><span class="sxs-lookup"><span data-stu-id="88343-113">Lambda expressions</span></span>
- <span data-ttu-id="88343-114">Finalizzatori</span><span class="sxs-lookup"><span data-stu-id="88343-114">Finalizers</span></span>
- <span data-ttu-id="88343-115">Altre funzioni locali</span><span class="sxs-lookup"><span data-stu-id="88343-115">Other local functions</span></span>

<span data-ttu-id="88343-116">Le funzioni locali, tuttavia, non possono essere dichiarate all'interno di un membro con corpo di espressione.</span><span class="sxs-lookup"><span data-stu-id="88343-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="88343-117">In alcuni casi, è possibile usare un'espressione lambda per implementare le funzionalità supportate anche da una funzione locale.</span><span class="sxs-lookup"><span data-stu-id="88343-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="88343-118">Per un confronto, vedere [funzioni locali rispetto alle espressioni lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="88343-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="88343-119">Le funzioni locali rendono chiaro l'obiettivo del codice.</span><span class="sxs-lookup"><span data-stu-id="88343-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="88343-120">Chiunque legga il codice può vedere che il metodo non è richiamabile, ad eccezione del metodo contenitore.</span><span class="sxs-lookup"><span data-stu-id="88343-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="88343-121">Per i progetti in team, le funzioni locali impediscono anche a un altro sviluppatore di chiamare per errore il metodo direttamente da un altro punto della classe o dello struct.</span><span class="sxs-lookup"><span data-stu-id="88343-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="88343-122">Sintassi delle funzioni locali</span><span class="sxs-lookup"><span data-stu-id="88343-122">Local function syntax</span></span>

<span data-ttu-id="88343-123">Una funzione locale viene definita come metodo annidato all'interno di un membro contenitore.</span><span class="sxs-lookup"><span data-stu-id="88343-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="88343-124">La definizione presenta la sintassi seguente:</span><span class="sxs-lookup"><span data-stu-id="88343-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="88343-125">Le funzioni locali possono usare i modificatori [async](../../language-reference/keywords/async.md) e [unsafe](../../language-reference/keywords/unsafe.md).</span><span class="sxs-lookup"><span data-stu-id="88343-125">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="88343-126">Tutte le variabili locali definite nel membro contenitore, inclusi i relativi parametri di metodo, sono accessibili nella funzione locale.</span><span class="sxs-lookup"><span data-stu-id="88343-126">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="88343-127">Diversamente da una definizione di metodo, una definizione di funzione locale non può includere il modificatore di accesso ai membri.</span><span class="sxs-lookup"><span data-stu-id="88343-127">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="88343-128">Poiché tutte le funzioni locali sono private, l'integrazione di un modificatore di accesso come la parola chiave `private` genera l'errore del compilatore CS0106: "Il modificatore 'private' non è valido per questo elemento".</span><span class="sxs-lookup"><span data-stu-id="88343-128">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="88343-129">Prima di C# 8,0, le funzioni locali non possono includere il `static` modificatore.</span><span class="sxs-lookup"><span data-stu-id="88343-129">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="88343-130">L'integrazione della parola chiave `static` genera l'errore del compilatore CS0106: "Il modificatore 'private' non è valido per questo elemento".</span><span class="sxs-lookup"><span data-stu-id="88343-130">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="88343-131">Non è possibile, inoltre, applicare attributi alla funzione locale o ai relativi parametri e parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="88343-131">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="88343-132">L'esempio seguente definisce una funzione locale denominata `AppendPathSeparator`, privata di un metodo denominato `GetText`:</span><span class="sxs-lookup"><span data-stu-id="88343-132">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="88343-133">Funzioni locali ed eccezioni</span><span class="sxs-lookup"><span data-stu-id="88343-133">Local functions and exceptions</span></span>

<span data-ttu-id="88343-134">Le funzioni locali offrono il vantaggio di consentire alle eccezioni di essere rilevate immediatamente.</span><span class="sxs-lookup"><span data-stu-id="88343-134">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="88343-135">Nel caso degli iteratori di metodo, le eccezioni vengono rilevate solo nel momento in cui la sequenza restituita viene enumerata e non quando viene recuperato l'iteratore.</span><span class="sxs-lookup"><span data-stu-id="88343-135">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="88343-136">Nel caso dei metodi asincroni, qualsiasi eccezione generata viene rilevata mentre è attesa l'attività restituita.</span><span class="sxs-lookup"><span data-stu-id="88343-136">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="88343-137">L'esempio seguente definisce un metodo `OddSequence` che enumera i numeri dispari in un intervallo specifico.</span><span class="sxs-lookup"><span data-stu-id="88343-137">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="88343-138">Poiché al metodo enumeratore `OddSequence` viene trasmesso un numero maggiore di 100, il metodo genera una <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="88343-138">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="88343-139">Come illustrato dall'output dell'esempio, l'eccezione viene rilevata solo nel momento in cui vengono iterati i numeri e non quando si recupera l'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="88343-139">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="88343-140">È possibile tuttavia generare un'eccezione mentre si esegue la convalida e prima di recuperare l'iteratore restituendo l'iteratore da una funzione locale, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="88343-140">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="88343-141">Le funzioni locali possono essere usate in modo analogo anche per gestire eccezioni esterne all'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="88343-141">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="88343-142">In genere, le eccezioni generate in un metodo asincrono richiedono che vengano esaminate le eccezioni interne di una <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="88343-142">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="88343-143">Le funzioni locali consentono al codice di adottare un approccio "fail fast" e alle eccezioni di essere generate e osservate in modo sincrono.</span><span class="sxs-lookup"><span data-stu-id="88343-143">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="88343-144">Nell'esempio seguente viene usato un metodo asincrono denominato `GetMultipleAsync` per sospendere l'operazione per un determinato numero di secondi e restituire un valore che sia un multiplo casuale del numero di secondi specificato.</span><span class="sxs-lookup"><span data-stu-id="88343-144">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="88343-145">Il ritardo massimo consentito è 5 secondi. Se il valore è superiore a 5, viene generata una <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="88343-145">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="88343-146">Come illustrato nell'esempio seguente, l'eccezione generata quando al metodo `GetMultipleAsync` viene passato il valore 6 viene sottoposta a wrapping in una <xref:System.AggregateException> dopo che il metodo `GetMultipleAsync` inizia l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="88343-146">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="88343-147">Come per l'iteratore di metodo, è possibile effettuare il refactoring del codice dell'esempio per eseguire la convalida prima di chiamare il metodo asincrono.</span><span class="sxs-lookup"><span data-stu-id="88343-147">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="88343-148">Come illustrato dall'output dell'esempio seguente, l'eccezione <xref:System.ArgumentOutOfRangeException> non viene sottoposta a wrapping in un'eccezione <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="88343-148">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="88343-149">Funzioni locali ed espressioni lambda</span><span class="sxs-lookup"><span data-stu-id="88343-149">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="88343-150">A prima vista, le funzioni locali e le [espressioni lambda](../statements-expressions-operators/lambda-expressions.md) sono molto simili.</span><span class="sxs-lookup"><span data-stu-id="88343-150">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="88343-151">In molti casi, la scelta tra l'uso di funzioni locali ed espressioni lambda è una questione di stile e preferenze personali.</span><span class="sxs-lookup"><span data-stu-id="88343-151">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="88343-152">Esistono tuttavia differenze reali di cui è necessario essere consapevoli nei casi in cui è possibile usare le une o le altre.</span><span class="sxs-lookup"><span data-stu-id="88343-152">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="88343-153">Si esamineranno ora le differenze tra implementazioni di funzioni locali e implementazioni di espressioni lambda dell'algoritmo fattoriale.</span><span class="sxs-lookup"><span data-stu-id="88343-153">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="88343-154">Si analizzerà per prima la versione che usa una funzione locale:</span><span class="sxs-lookup"><span data-stu-id="88343-154">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="88343-155">Confrontare l'implementazione con una versione che usa le espressioni lambda:</span><span class="sxs-lookup"><span data-stu-id="88343-155">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="88343-156">Le funzioni locali hanno nomi.</span><span class="sxs-lookup"><span data-stu-id="88343-156">The local functions have names.</span></span> <span data-ttu-id="88343-157">Le espressioni lambda sono metodi anonimi che vengono assegnati a variabili di tipo `Func` o `Action`.</span><span class="sxs-lookup"><span data-stu-id="88343-157">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="88343-158">Quando si dichiara una funzione locale, i tipi di argomento e il tipo restituito fanno parte della dichiarazione della funzione.</span><span class="sxs-lookup"><span data-stu-id="88343-158">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="88343-159">Anziché far parte del corpo dell'espressione lambda, i tipi di argomento e il tipo restituito fanno parte della dichiarazione del tipo di variabile dell'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-159">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="88343-160">Queste due differenze possono avere come risultato una maggiore chiarezza del codice.</span><span class="sxs-lookup"><span data-stu-id="88343-160">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="88343-161">Le funzioni locali hanno regole diverse per l'assegnazione certa rispetto alle espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-161">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="88343-162">A una dichiarazione di funzione locale si può fare riferimento da qualsiasi posizione di codice nel cui ambito la funzione si trova.</span><span class="sxs-lookup"><span data-stu-id="88343-162">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="88343-163">Un'espressione lambda deve essere assegnata a una variabile delegata prima che sia possibile accedervi o chiamarla tramite il delegato che fa riferimento all'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-163">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="88343-164">Si noti che la versione che usa l'espressione lambda deve dichiarare e inizializzare l'espressione lambda `nthFactorial` prima di definirla.</span><span class="sxs-lookup"><span data-stu-id="88343-164">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="88343-165">In caso contrario, si verifica un errore di compilazione per fare riferimento a `nthFactorial` prima di assegnarla.</span><span class="sxs-lookup"><span data-stu-id="88343-165">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="88343-166">Queste differenze fanno sì che gli algoritmi ricorsivi sino più facili da creare usando funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="88343-166">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="88343-167">È possibile dichiarare e definire una funzione locale che chiama se stessa.</span><span class="sxs-lookup"><span data-stu-id="88343-167">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="88343-168">Le espressioni lambda devono essere dichiarate e a queste deve essere assegnato un valore predefinito prima che sia possibile riassegnarle a un corpo che fa riferimento alla stessa espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-168">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="88343-169">Le regole di assegnazione certa influiscono anche su tutte le variabili acquisite dalla funzione locale o dall'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-169">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="88343-170">Sia le regole delle funzioni locali che quelle delle espressioni lambda richiedono che tutte le variabili acquisite siano assegnate in modo certo nel momento in cui la funzione locale o l'espressione lambda viene convertita in delegato.</span><span class="sxs-lookup"><span data-stu-id="88343-170">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="88343-171">La differenza è che le espressioni lambda vengono convertite in delegati quando vengono dichiarate.</span><span class="sxs-lookup"><span data-stu-id="88343-171">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="88343-172">Le funzioni locali vengono convertite in delegati solo quando vengono usate come delegati.</span><span class="sxs-lookup"><span data-stu-id="88343-172">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="88343-173">Se si dichiara una funzione locale e si fa riferimento a questa solo chiamandola come un metodo, non verrà convertita in delegato.</span><span class="sxs-lookup"><span data-stu-id="88343-173">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="88343-174">Tale regola consente di dichiarare una funzione locale in qualsiasi posizione comoda all'interno dell'ambito che la comprende.</span><span class="sxs-lookup"><span data-stu-id="88343-174">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="88343-175">È una pratica comune dichiarare funzioni locali alla fine del metodo padre, dopo le istruzioni Return.</span><span class="sxs-lookup"><span data-stu-id="88343-175">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="88343-176">In terzo luogo, il compilatore può eseguire un'analisi statica che consente alle funzioni locali di assegnare in modo certo variabili acquisite nell'ambito che le contiene.</span><span class="sxs-lookup"><span data-stu-id="88343-176">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="88343-177">Considerare questo esempio:</span><span class="sxs-lookup"><span data-stu-id="88343-177">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="88343-178">Il compilatore può determinare che `LocalFunction` assegna in modo certo `y` quando viene chiamata.</span><span class="sxs-lookup"><span data-stu-id="88343-178">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="88343-179">Poiché `LocalFunction` viene chiamata prima dell'istruzione `return`, `y` viene assegnata in modo certo in corrispondenza dell'istruzione `return`.</span><span class="sxs-lookup"><span data-stu-id="88343-179">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="88343-180">L'analisi che consente l'analisi di esempio consente la quarta differenza.</span><span class="sxs-lookup"><span data-stu-id="88343-180">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="88343-181">A seconda del loro uso, le funzioni locali possono evitare le allocazioni di heap, che sono sempre necessarie per le espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-181">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="88343-182">Se una funzione locale non viene mai convertita in delegato e nessuna delle variabili acquisite dalla funzione locale viene acquisita da altre espressioni lambda o funzioni locali convertite in delegati, il compilatore può evitare allocazioni di heap.</span><span class="sxs-lookup"><span data-stu-id="88343-182">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="88343-183">Si consideri questo esempio asincrono:</span><span class="sxs-lookup"><span data-stu-id="88343-183">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="88343-184">La chiusura per questa espressione lambda contiene le variabili `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="88343-184">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="88343-185">Nel caso delle funzioni locali, l'oggetto che implementa la chiusura può essere di tipo `struct`</span><span class="sxs-lookup"><span data-stu-id="88343-185">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="88343-186">Tale tipo struct verrebbe passato per riferimento alla funzione locale.</span><span class="sxs-lookup"><span data-stu-id="88343-186">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="88343-187">Questa differenza di implementazione consentirebbe di risparmiare un'allocazione.</span><span class="sxs-lookup"><span data-stu-id="88343-187">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="88343-188">La creazione di istanze necessaria per le espressioni lambda comporta allocazioni di memoria aggiuntive che possono ridurre le prestazioni nei percorsi di codice in cui il tempo è un fattore cruciale.</span><span class="sxs-lookup"><span data-stu-id="88343-188">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="88343-189">Questo sovraccarico non si verifica per le funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="88343-189">Local functions do not incur this overhead.</span></span> <span data-ttu-id="88343-190">Nell'esempio precedente, la versione con funzioni locali presenta due allocazioni in meno rispetto alla versione con espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-190">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="88343-191">La funzione locale equivalente di questo metodo usa anche una classe per la chiusura.</span><span class="sxs-lookup"><span data-stu-id="88343-191">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="88343-192">Se la chiusura di una funzione locale viene implementata come `class` o `struct` non ha molta importanza.</span><span class="sxs-lookup"><span data-stu-id="88343-192">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="88343-193">Una funzione locale può usare `struct` mentre un'espressione lambda userà sempre `class`.</span><span class="sxs-lookup"><span data-stu-id="88343-193">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="88343-194">Come ultimo vantaggio, non illustrato in questo esempio, le funzioni locali possono essere implementate come iteratori usando la sintassi `yield return` per produrre una sequenza di valori.</span><span class="sxs-lookup"><span data-stu-id="88343-194">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="88343-195">L'istruzione `yield return` non è consentita nelle espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="88343-195">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="88343-196">Sebbene le funzioni locali possano apparire ridondanti rispetto alle espressioni lambda, in realtà hanno finalità e usi diversi.</span><span class="sxs-lookup"><span data-stu-id="88343-196">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="88343-197">Le funzioni locali sono più efficienti nel caso si voglia scrivere una funzione che viene chiamata solo dal contesto di un altro metodo.</span><span class="sxs-lookup"><span data-stu-id="88343-197">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="88343-198">Vedi anche</span><span class="sxs-lookup"><span data-stu-id="88343-198">See also</span></span>

- [<span data-ttu-id="88343-199">Metodi</span><span class="sxs-lookup"><span data-stu-id="88343-199">Methods</span></span>](methods.md)
