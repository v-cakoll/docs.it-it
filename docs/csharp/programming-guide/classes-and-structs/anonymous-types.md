---
title: Tipi anonimi - Guida per programmatori C#
description: I tipi anonimi in C# incapsulano un set di proprietà di sola lettura in un oggetto senza dover definire in modo esplicito un tipo. Il compilatore genera un nome.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: ccdee1a86ab0c292721e69346cb7cedb03d4c28b
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474501"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="26ff9-104">Tipi anonimi (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="26ff9-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="26ff9-105">I tipi anonimi offrono un modo pratico per incapsulare un set di proprietà di sola lettura in un singolo oggetto, senza dover definire prima un tipo in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="26ff9-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="26ff9-106">Il nome del tipo viene generato dal compilatore e non è disponibile a livello di codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="26ff9-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="26ff9-107">Il tipo di ogni proprietà è dedotto dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="26ff9-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="26ff9-108">Per creare tipi anonimi, si usa l'operatore [new](../../language-reference/operators/new-operator.md) insieme a un inizializzatore di oggetto.</span><span class="sxs-lookup"><span data-stu-id="26ff9-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="26ff9-109">Per altre informazioni sugli inizializzatori di oggetto, vedere [Inizializzatori di oggetto e di raccolte](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="26ff9-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="26ff9-110">L'esempio seguente mostra un tipo anonimo inizializzato con due proprietà denominate `Amount` e `Message`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="26ff9-111">I tipi anonimi vengono in genere usati nella clausola [select](../../language-reference/keywords/select-clause.md) di un'espressione di query per restituire un subset delle proprietà da ogni oggetto della sequenza di origine.</span><span class="sxs-lookup"><span data-stu-id="26ff9-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="26ff9-112">Per ulteriori informazioni sulle query, vedere [LINQ in C#](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="26ff9-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="26ff9-113">I tipi anonimi contengono una o più proprietà pubbliche di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="26ff9-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="26ff9-114">Non sono validi altri tipi di membri della classe, ad esempio metodi o eventi.</span><span class="sxs-lookup"><span data-stu-id="26ff9-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="26ff9-115">L'espressione usata per inizializzare una proprietà non può essere `null`, una funzione anonima o un tipo di puntatore.</span><span class="sxs-lookup"><span data-stu-id="26ff9-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="26ff9-116">Lo scenario più comune consiste nell'inizializzare un tipo anonimo con proprietà di un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="26ff9-117">Nell'esempio seguente si presuppone l'esistenza di una classe denominata `Product`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="26ff9-118">La classe `Product` include le proprietà `Color` e `Price`, insieme ad altre proprietà non pertinenti.</span><span class="sxs-lookup"><span data-stu-id="26ff9-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="26ff9-119">La variabile `products` è una raccolta di oggetti `Product`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="26ff9-120">La dichiarazione di tipo anonimo inizia con la parola chiave `new`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="26ff9-121">La dichiarazione inizializza un nuovo tipo che usa solo due proprietà della classe `Product`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="26ff9-122">In questo modo la query restituisce una quantità di dati inferiore.</span><span class="sxs-lookup"><span data-stu-id="26ff9-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="26ff9-123">Se nel tipo anonimo non si specificano i nomi dei membri, il compilatore assegna ai membri di tipo anonimo lo stesso nome della proprietà usata per inizializzarli.</span><span class="sxs-lookup"><span data-stu-id="26ff9-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="26ff9-124">Per una proprietà inizializzata con un'espressione è necessario fornire un nome, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="26ff9-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="26ff9-125">Nell'esempio seguente i nomi delle proprietà del tipo anonimo sono `Color` e `Price`.</span><span class="sxs-lookup"><span data-stu-id="26ff9-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="26ff9-126">In genere, quando si usa un tipo anonimo per inizializzare una variabile, è necessario dichiarare la variabile come locale tipizzata in modo implicito tramite [var](../../language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="26ff9-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="26ff9-127">Il nome del tipo non può essere specificato nella dichiarazione di variabile, perché solo il compilatore ha accesso al nome sottostante del tipo anonimo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="26ff9-128">Per altre informazioni su `var`, vedere [Variabili locali tipizzate in modo implicito](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="26ff9-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="26ff9-129">È possibile creare una matrice di elementi tipizzati in modo anonimo combinando una variabile locale tipizzata in modo implicito e una matrice tipizzata in modo implicito, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="26ff9-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="26ff9-130">Osservazioni</span><span class="sxs-lookup"><span data-stu-id="26ff9-130">Remarks</span></span>  
 <span data-ttu-id="26ff9-131">I tipi anonimi sono tipi [class](../../language-reference/keywords/class.md) che derivano da un tipo [object](../../language-reference/builtin-types/reference-types.md) e dei quali non può essere eseguito il cast ad alcun tipo, eccetto al tipo [object](../../language-reference/builtin-types/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="26ff9-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="26ff9-132">Il compilatore fornisce un nome per qualsiasi tipo anonimo, anche se l'applicazione non può accedervi.</span><span class="sxs-lookup"><span data-stu-id="26ff9-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="26ff9-133">Dal punto di vista di Common Language Runtime, un tipo anonimo non è diverso da qualsiasi altro tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="26ff9-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="26ff9-134">Se due o più inizializzatori di oggetti anonimi in un assembly specificano una sequenza di proprietà nello stesso ordine e con gli stessi nomi e tipi, il compilatore considera gli oggetti come istanze dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="26ff9-135">Condividono le stesse informazioni sul tipo generate dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="26ff9-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="26ff9-136">Non è possibile dichiarare un campo, una proprietà, un evento o il tipo restituito di un metodo specificando un tipo anonimo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="26ff9-137">In modo analogo, non è possibile dichiarare un parametro formale di un metodo, una proprietà, un costruttore o un indicizzatore specificando un tipo anonimo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="26ff9-138">Per passare un tipo anonimo o una raccolta contenente tipi anonimi come argomento a un metodo, è possibile dichiarare il parametro come oggetto di tipo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="26ff9-139">In questo modo si annulla tuttavia lo scopo della tipizzazione forte.</span><span class="sxs-lookup"><span data-stu-id="26ff9-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="26ff9-140">Se è necessario archiviare i risultati delle query o passarli oltre i limiti del metodo, si consideri l'uso di uno struct o una classe con nome normale invece di un tipo anonimo.</span><span class="sxs-lookup"><span data-stu-id="26ff9-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="26ff9-141">I metodi <xref:System.Object.Equals%2A> e <xref:System.Object.GetHashCode%2A> nei tipi anonimi sono definiti in termini di metodi delle proprietà `Equals` e `GetHashCode`, di conseguenza due istanze dello stesso tipo anonimo sono uguali solo se tutte le relative proprietà sono uguali.</span><span class="sxs-lookup"><span data-stu-id="26ff9-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="26ff9-142">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="26ff9-142">See also</span></span>

- [<span data-ttu-id="26ff9-143">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="26ff9-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="26ff9-144">Inizializzatori di oggetto e di raccolta</span><span class="sxs-lookup"><span data-stu-id="26ff9-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="26ff9-145">Nozioni di base su LINQ in C#</span><span class="sxs-lookup"><span data-stu-id="26ff9-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="26ff9-146">LINQ in C#</span><span class="sxs-lookup"><span data-stu-id="26ff9-146">LINQ in C#</span></span>](../../linq/index.md)
