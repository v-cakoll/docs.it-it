---
title: Polimorfismo - Guida per programmatori C#
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 58980bd0d70d8a778cdb208f56d31ee8465871a4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170169"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="f7fe0-102">Polimorfismo (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="f7fe0-102">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="f7fe0-103">Il polimorfismo è spesso definito il terzo pilastro della programmazione orientata a oggetti, dopo l'incapsulamento e l'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="f7fe0-104">Polimorfismo è una parola che deriva dal greco e significa "multiforme". Il polimorfismo presenta due aspetti distinti:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="f7fe0-105">In fase di esecuzione, oggetti di una classe derivata possono essere trattati come oggetti di una classe base in posizioni quali parametri del metodo e raccolte o matrici.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="f7fe0-106">Quando si verifica questo polimorfismo, il tipo dichiarato dell'oggetto non è più identico al tipo in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-106">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="f7fe0-107">Le classi di base possono definire e implementare *metodi* [virtuali](../../language-reference/keywords/virtual.md) e le classi derivate possono [eseguirne l'override,](../../language-reference/keywords/override.md) il che significa che forniscono la propria definizione e implementazione.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="f7fe0-108">Durante la fase di esecuzione, quando il codice client chiama il metodo, CLR cerca il tipo in fase di esecuzione dell'oggetto e richiama quell'override del metodo virtuale.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="f7fe0-109">Nel codice sorgente è possibile chiamare un metodo su una classe base e causare la versione del metodo di una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-109">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="f7fe0-110">I metodi virtuali consentono di usare gruppi di oggetti correlati in modo uniforme.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="f7fe0-111">Si supponga ad esempio di avere un'applicazione di disegno che consenta a un utente di creare vari tipi di forme in un'area di disegno.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="f7fe0-112">In fase di compilazione non è possibile sapere i tipi specifici di forme che l'utente creerà.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="f7fe0-113">L'applicazione deve tuttavia tenere traccia di tutti i vari tipi di forme create e deve aggiornarli in risposta alle azioni del mouse dell'utente.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="f7fe0-114">È possibile usare il polimorfismo per risolvere questo problema in due passaggi di base:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-114">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="f7fe0-115">Creare una gerarchia di classi nella quale ogni classe della forma specifica deriva da una classe base comune.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="f7fe0-116">Usare un metodo virtuale per richiamare il metodo adatto su qualsiasi classe derivata tramite una sola chiamata al metodo della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="f7fe0-117">Prima di tutto, creare una classe base denominata `Shape` e delle classi derivate quali `Rectangle`, `Circle` e `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="f7fe0-118">Definire nella classe `Shape` un metodo virtuale denominato `Draw` ed eseguirne l'override in ogni classe derivata per disegnare la particolare forma che la classe rappresenta.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="f7fe0-119">Creare `List<Shape>` un oggetto `Circle`e `Triangle`aggiungervi un oggetto , e `Rectangle` ad esso.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-119">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="f7fe0-120">Per aggiornare l'area di disegno, usare un ciclo [foreach](../../language-reference/keywords/foreach-in.md) per scorrere l'elenco e chiamare il metodo `Draw` su ogni oggetto `Shape` nell'elenco.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="f7fe0-121">Anche se ogni oggetto nell'elenco `Shape`dispone di un tipo dichiarato di , è il tipo in fase di esecuzione (la versione sottoposta a override del metodo in ogni classe derivata) che verrà richiamato.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-121">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="f7fe0-122">In C# ogni tipo è polimorfico perché tutti i tipi, incluso i tipi definiti dall'utente, ereditano da <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="f7fe0-123">Panoramica del polimorfismo</span><span class="sxs-lookup"><span data-stu-id="f7fe0-123">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="f7fe0-124">Membri virtuali</span><span class="sxs-lookup"><span data-stu-id="f7fe0-124">Virtual members</span></span>

<span data-ttu-id="f7fe0-125">Quando una classe derivata eredita da una classe base, ottiene tutti i metodi, i campi, le proprietà e gli eventi della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-125">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="f7fe0-126">La finestra di progettazione della classe derivata può scegliere diverse per il comportamento dei metodi virtuali:The designer of the derived class can different choices for the behavior of virtual methods:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-126">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="f7fe0-127">La classe derivata può eseguire l'override dei membri virtuali nella classe base, definendo un nuovo comportamento.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-127">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="f7fe0-128">La classe derivata eredita il metodo della classe base più vicino senza eseguirne l'override, preservando il comportamento esistente ma consentendo alle altre classi derivate di eseguire l'override del metodo.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-128">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="f7fe0-129">La classe derivata può definire una nuova implementazione non virtuale dei membri che nascondono le implementazioni della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-129">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="f7fe0-130">Una classe derivata può eseguire l'override di un membro della classe base solo se quest'ultimo è dichiarato come [virtuale](../../language-reference/keywords/virtual.md) o [astratto](../../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="f7fe0-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="f7fe0-131">Il membro derivato deve usare la parola chiave [override](../../language-reference/keywords/override.md) per indicare esplicitamente che il metodo deve partecipare alla chiamata virtuale.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="f7fe0-132">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-132">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="f7fe0-133">I campi non possono essere virtuali; solo metodi, proprietà, eventi e indicizzatori possono essere virtuali.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-133">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="f7fe0-134">Quando una classe derivata esegue l'override di un membro virtuale, quest'ultimo viene chiamato anche nel caso in cui si acceda a un'istanza di tale classe come istanza della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="f7fe0-135">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-135">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="f7fe0-136">Metodi virtuali e proprietà consentono alle classi derivate di estendere una classe base senza dover usare l'implementazione della classe base di un metodo.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="f7fe0-137">Per altre informazioni, vedere [Controllo delle versioni con le parole chiave Override e New](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="f7fe0-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="f7fe0-138">Un'interfaccia fornisce un'altra modalità per definire un metodo o un insieme di metodi la cui implementazione è lasciata alle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="f7fe0-139">Per ulteriori informazioni, vedi [Interfacce](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="f7fe0-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="f7fe0-140">Nascondere i membri della classe base con nuovi membri</span><span class="sxs-lookup"><span data-stu-id="f7fe0-140">Hide base class members with new members</span></span>

<span data-ttu-id="f7fe0-141">Se si desidera che la classe derivata abbia un membro con lo stesso nome di un membro in una classe base, è possibile utilizzare la parola chiave [new](../../language-reference/keywords/new-modifier.md) per nascondere il membro della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-141">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="f7fe0-142">La parola chiave `new` viene inserita prima del tipo restituito di un membro di classe che viene sostituito.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="f7fe0-143">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-143">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="f7fe0-144">È possibile accedere ai membri della classe base nascosti dal codice client eseguendo il cast dell'istanza della classe derivata in un'istanza della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-144">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="f7fe0-145">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-145">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="f7fe0-146">Impedire alle classi derivate di eseguire l'override dei membri virtuali</span><span class="sxs-lookup"><span data-stu-id="f7fe0-146">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="f7fe0-147">I membri virtuali rimangono virtuali, indipendentemente dal numero di classi dichiarate tra il membro virtuale e la classe che lo ha originariamente dichiarato.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-147">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="f7fe0-148">Se `A` la classe dichiara un `B` membro virtuale `A`e `C` la classe `B`deriva `C` da , e la classe deriva da , `B` la classe eredita il membro virtuale e può eseguirne l'override, indipendentemente dal fatto che la classe abbia dichiarato un override per tale membro.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-148">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="f7fe0-149">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-149">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="f7fe0-150">Una classe derivata può interrompere l'ereditarietà virtuale dichiarando un override come [sealed](../../language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="f7fe0-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="f7fe0-151">L'interruzione dell'ereditarietà richiede l'inserimento della `sealed` parola chiave prima della `override` parola chiave nella dichiarazione del membro della classe.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-151">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="f7fe0-152">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-152">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="f7fe0-153">Nell'esempio precedente, `DoWork` il metodo non è più `C`virtuale per qualsiasi classe derivata da .</span><span class="sxs-lookup"><span data-stu-id="f7fe0-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="f7fe0-154">È ancora virtuale per `C`le istanze di , `B` anche `A`se ne viene esegetta il cast nel tipo o nel tipo .</span><span class="sxs-lookup"><span data-stu-id="f7fe0-154">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="f7fe0-155">I metodi sealed possono essere sostituiti dalle classi derivate usando la parola chiave , come illustrato nell'esempio seguente:Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-155">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="f7fe0-156">In questo caso, `DoWork` se `D` viene chiamato `D`utilizzando una `DoWork` variabile di tipo , viene chiamato il nuovo.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-156">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="f7fe0-157">Se una variabile `C` `B`di `A` tipo , , o `D`viene utilizzata `DoWork` per accedere a un'istanza di , `DoWork` una `C`chiamata a seguirà le regole dell'ereditarietà virtuale, instradando tali chiamate all'implementazione di sulla classe .</span><span class="sxs-lookup"><span data-stu-id="f7fe0-157">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="f7fe0-158">Accedere ai membri virtuali della classe base dalle classi derivateAccess base class virtual members from derived classes</span><span class="sxs-lookup"><span data-stu-id="f7fe0-158">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="f7fe0-159">Una classe derivata che ha sostituito un metodo o una proprietà, o ne ha eseguito l'override, può ancora accedere al metodo o alla proprietà sulla classe base usando la parola chiave `base`.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-159">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="f7fe0-160">Nel codice seguente ne viene illustrato un esempio:</span><span class="sxs-lookup"><span data-stu-id="f7fe0-160">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="f7fe0-161">Per altre informazioni, vedere [base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="f7fe0-161">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="f7fe0-162">Nell'implementazione dei membri virtuali è consigliabile l'uso della parola chiave `base` per le chiamate all'implementazione della classe base di tali membri.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-162">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="f7fe0-163">In questo modo, nella classe derivata sarà possibile definire la sola implementazione del comportamento specifico per tale classe.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-163">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="f7fe0-164">Se l'implementazione della classe base non viene chiamata, spetterà alla classe derivata rendere il proprio comportamento compatibile con quello della classe base.</span><span class="sxs-lookup"><span data-stu-id="f7fe0-164">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="f7fe0-165">Contenuto della sezione</span><span class="sxs-lookup"><span data-stu-id="f7fe0-165">In this section</span></span>

- [<span data-ttu-id="f7fe0-166">Controllo delle versioni con le parole chiave Override e New</span><span class="sxs-lookup"><span data-stu-id="f7fe0-166">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="f7fe0-167">Sapere quando utilizzare le parole chiave Override e New</span><span class="sxs-lookup"><span data-stu-id="f7fe0-167">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="f7fe0-168">Come eseguire l'override del metodo ToString</span><span class="sxs-lookup"><span data-stu-id="f7fe0-168">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="f7fe0-169">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f7fe0-169">See also</span></span>

- [<span data-ttu-id="f7fe0-170">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="f7fe0-170">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="f7fe0-171">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="f7fe0-171">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="f7fe0-172">Classi e membri delle classi astratte e sealed</span><span class="sxs-lookup"><span data-stu-id="f7fe0-172">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="f7fe0-173">Metodi</span><span class="sxs-lookup"><span data-stu-id="f7fe0-173">Methods</span></span>](./methods.md)
- [<span data-ttu-id="f7fe0-174">Events</span><span class="sxs-lookup"><span data-stu-id="f7fe0-174">Events</span></span>](../events/index.md)
- [<span data-ttu-id="f7fe0-175">Proprietà</span><span class="sxs-lookup"><span data-stu-id="f7fe0-175">Properties</span></span>](./properties.md)
- [<span data-ttu-id="f7fe0-176">Indicizzatori</span><span class="sxs-lookup"><span data-stu-id="f7fe0-176">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="f7fe0-177">Tipi</span><span class="sxs-lookup"><span data-stu-id="f7fe0-177">Types</span></span>](../types/index.md)
