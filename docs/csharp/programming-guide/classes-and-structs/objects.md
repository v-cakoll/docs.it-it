---
title: Oggetti - Guida per programmatori C#
description: C# usa una definizione di classe o struct per definire i tipi di oggetti. In un linguaggio orientato a oggetti, ad esempio C#, un programma è costituito da oggetti che interagiscono dinamicamente.
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: b54db325c568dec702e4e50c3c265286662092fe
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864761"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="404ab-104">Oggetti (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="404ab-104">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="404ab-105">Una definizione di classe o struct è simile a un progetto iniziale in cui vengono specificate le funzionalità del tipo.</span><span class="sxs-lookup"><span data-stu-id="404ab-105">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="404ab-106">Un oggetto è essenzialmente un blocco di memoria che è stato allocato e configurato in base al progetto iniziale.</span><span class="sxs-lookup"><span data-stu-id="404ab-106">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="404ab-107">Un programma può creare molti oggetti della stessa classe.</span><span class="sxs-lookup"><span data-stu-id="404ab-107">A program may create many objects of the same class.</span></span> <span data-ttu-id="404ab-108">Gli oggetti, definiti anche istanze, possono essere archiviati in una variabile denominata o in una matrice o raccolta.</span><span class="sxs-lookup"><span data-stu-id="404ab-108">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="404ab-109">Il codice client è il codice che usa queste variabili per chiamare i metodi e accedere alle proprietà pubbliche dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="404ab-109">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="404ab-110">In un linguaggio orientato a oggetti come C#, il programma tipico è costituito da più oggetti che interagiscono dinamicamente.</span><span class="sxs-lookup"><span data-stu-id="404ab-110">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="404ab-111">I tipi statici si comportano in modo diverso da quanto descritto qui.</span><span class="sxs-lookup"><span data-stu-id="404ab-111">Static types behave differently than what is described here.</span></span> <span data-ttu-id="404ab-112">Per altre informazioni, vedere [classi statiche e membri di classi statiche](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="404ab-112">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="404ab-113">Istanze struct e istanze di classe</span><span class="sxs-lookup"><span data-stu-id="404ab-113">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="404ab-114">Poiché le classi sono tipi di riferimento, una variabile di un oggetto classe contiene un riferimento all'indirizzo dell'oggetto sull'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="404ab-114">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="404ab-115">Se al primo oggetto viene assegnato un secondo oggetto dello stesso tipo, entrambe le variabili fanno riferimento all'oggetto in quell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="404ab-115">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="404ab-116">Questo punto viene illustrato più dettagliatamente di seguito in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="404ab-116">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="404ab-117">Le istanze delle classi vengono create usando l'[operatore new](../../language-reference/operators/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="404ab-117">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="404ab-118">Nell'esempio seguente `Person` è il tipo e `person1` e `person 2` sono le istanze o gli oggetti di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="404ab-118">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="404ab-119">Poiché gli struct sono tipi di valore, una variabile di un oggetto struct contiene una copia dell'intero oggetto.</span><span class="sxs-lookup"><span data-stu-id="404ab-119">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="404ab-120">Le istanze di struct possono essere create anche usando l'operatore `new`, sebbene non sia obbligatorio, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="404ab-120">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="404ab-121">La memoria per `p1` e `p2` viene allocata nello stack di thread.</span><span class="sxs-lookup"><span data-stu-id="404ab-121">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="404ab-122">La memoria viene recuperata insieme al tipo o al metodo in cui è stata dichiarata.</span><span class="sxs-lookup"><span data-stu-id="404ab-122">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="404ab-123">Questo è il motivo per cui gli struct vengono copiati per assegnazione.</span><span class="sxs-lookup"><span data-stu-id="404ab-123">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="404ab-124">Al contrario, la memoria allocata per l'istanza di una classe viene recuperata automaticamente (tramite Garbage Collection) da Common Language Runtime quando tutti i riferimenti all'oggetto sono usciti dall'ambito.</span><span class="sxs-lookup"><span data-stu-id="404ab-124">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="404ab-125">Non è possibile eliminare in modo deterministico un oggetto di classe come avviene in C++.</span><span class="sxs-lookup"><span data-stu-id="404ab-125">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="404ab-126">Per ulteriori informazioni su Garbage Collection in .NET, vedere [Garbage Collection](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="404ab-126">For more information about garbage collection in .NET, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="404ab-127">L'allocazione e la deallocazione di memoria sull'heap gestito sono estremamente ottimizzate in Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="404ab-127">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="404ab-128">Nella maggior parte dei casi non esistono differenze significative in termini di impatto sulle prestazioni tra l'allocazione di un'istanza di classe sull'heap e l'allocazione di un'istanza di struttura sullo stack.</span><span class="sxs-lookup"><span data-stu-id="404ab-128">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="404ab-129">Identità dell'oggetto e uguaglianza di valori</span><span class="sxs-lookup"><span data-stu-id="404ab-129">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="404ab-130">Quando si confrontano due oggetti per verificarne l'uguaglianza, è necessario innanzitutto distinguere se si vuole determinare se le due variabili rappresentano lo stesso oggetto in memoria oppure se i valori di uno o più campi sono equivalenti.</span><span class="sxs-lookup"><span data-stu-id="404ab-130">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="404ab-131">Se si intende confrontare valori, è necessario considerare se gli oggetti sono istanze di tipi di valore (struct) o di tipi di riferimento (classi, delegati, matrici).</span><span class="sxs-lookup"><span data-stu-id="404ab-131">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="404ab-132">Per determinare se due istanze di classe fanno riferimento alla stessa posizione in memoria (ovvero hanno la stessa *identità*), usare il metodo statico <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="404ab-132">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="404ab-133"><xref:System.Object?displayProperty=nameWithType> è la classe di base implicita per tutti i tipi valore e i tipi riferimento, inclusi struct e classi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="404ab-133">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="404ab-134">Per determinare se i campi di istanza in due istanze di struct hanno gli stessi valori, usare il metodo <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="404ab-134">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="404ab-135">Poiché tutti gli struct ereditano implicitamente da <xref:System.ValueType?displayProperty=nameWithType>, il metodo viene chiamato direttamente nell'oggetto, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="404ab-135">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="404ab-136">L'implementazione <xref:System.ValueType?displayProperty=nameWithType> di `Equals` usa la reflection perché deve essere in grado di determinare i campi presenti in tutti gli struct.</span><span class="sxs-lookup"><span data-stu-id="404ab-136">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="404ab-137">Quando si creano struct, eseguire l'override del metodo `Equals` per specificare un algoritmo di uguaglianza efficiente specifico del tipo.</span><span class="sxs-lookup"><span data-stu-id="404ab-137">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="404ab-138">Per determinare se i valori dei campi in due istanze di classe sono uguali, è possibile usare il metodo <xref:System.Object.Equals%2A> o l'operatore [==](../../language-reference/operators/equality-operators.md#equality-operator-).</span><span class="sxs-lookup"><span data-stu-id="404ab-138">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="404ab-139">Tuttavia, usarli solo se la classe ha eseguito il loro override o overload per offrire una definizione personalizzata di cosa significa "uguaglianza" per gli oggetti di quel tipo.</span><span class="sxs-lookup"><span data-stu-id="404ab-139">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="404ab-140">La classe può anche implementare l'interfaccia <xref:System.IEquatable%601> o <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="404ab-140">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="404ab-141">Entrambe le interfacce offrono metodi che possono essere usati per verificare l'uguaglianza dei valori.</span><span class="sxs-lookup"><span data-stu-id="404ab-141">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="404ab-142">Quando si progettano classi personalizzate che eseguono l'override di `Equals` , assicurarsi di seguire le linee guida indicate in [come definire l'uguaglianza di valori per un tipo](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) e <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="404ab-142">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="404ab-143">Sezioni correlate</span><span class="sxs-lookup"><span data-stu-id="404ab-143">Related Sections</span></span>  
 <span data-ttu-id="404ab-144">Per altre informazioni:</span><span class="sxs-lookup"><span data-stu-id="404ab-144">For more information:</span></span>  
  
- [<span data-ttu-id="404ab-145">Classi</span><span class="sxs-lookup"><span data-stu-id="404ab-145">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="404ab-146">Costruttori</span><span class="sxs-lookup"><span data-stu-id="404ab-146">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="404ab-147">Finalizzatori</span><span class="sxs-lookup"><span data-stu-id="404ab-147">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="404ab-148">Events</span><span class="sxs-lookup"><span data-stu-id="404ab-148">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="404ab-149">Vedi anche</span><span class="sxs-lookup"><span data-stu-id="404ab-149">See also</span></span>

- [<span data-ttu-id="404ab-150">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="404ab-150">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="404ab-151">object</span><span class="sxs-lookup"><span data-stu-id="404ab-151">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="404ab-152">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="404ab-152">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="404ab-153">class</span><span class="sxs-lookup"><span data-stu-id="404ab-153">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="404ab-154">Tipi di struttura</span><span class="sxs-lookup"><span data-stu-id="404ab-154">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="404ab-155">Operatore New</span><span class="sxs-lookup"><span data-stu-id="404ab-155">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="404ab-156">Common Type System</span><span class="sxs-lookup"><span data-stu-id="404ab-156">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
