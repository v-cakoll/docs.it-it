---
title: Tipi di base - Guida a C#
description: Informazioni sui tipi di base (dati numerici, stringhe e oggetto) in tutti i programmi C#
ms.date: 10/10/2016
ms.technology: csharp-fundamentals
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 93a0023969bb8bb089922a9e30fbf599eddc7203
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174179"
---
# <a name="types-variables-and-values"></a><span data-ttu-id="75b41-103">Tipi, variabili e valori</span><span class="sxs-lookup"><span data-stu-id="75b41-103">Types, variables, and values</span></span>

<span data-ttu-id="75b41-104">C# è un linguaggio fortemente tipizzato.</span><span class="sxs-lookup"><span data-stu-id="75b41-104">C# is a strongly typed language.</span></span> <span data-ttu-id="75b41-105">Ogni variabile e costante ha un tipo, così come ogni espressione che restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="75b41-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="75b41-106">Ogni firma del metodo specifica un tipo per ogni parametro di input e per il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="75b41-106">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="75b41-107">La libreria di classi .NET Framework definisce un set di tipi numerici incorporati, oltre a tipi più complessi che rappresentano un'ampia gamma di costrutti logici, ad esempio il file system, le connessioni di rete, le raccolte e le matrici di oggetti e le date.</span><span class="sxs-lookup"><span data-stu-id="75b41-107">The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="75b41-108">Un tipico programma C# usa tipi dalla libreria di classi e tipi definiti dall'utente che modellano i concetti specifici del dominio relativo al problema del programma.</span><span class="sxs-lookup"><span data-stu-id="75b41-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
<span data-ttu-id="75b41-109">Le informazioni archiviate in un tipo possono includere quanto segue:</span><span class="sxs-lookup"><span data-stu-id="75b41-109">The information stored in a type can include the following:</span></span>  
  
- <span data-ttu-id="75b41-110">Lo spazio di archiviazione richiesto da una variabile del tipo.</span><span class="sxs-lookup"><span data-stu-id="75b41-110">The storage space that a variable of the type requires.</span></span>  
  
- <span data-ttu-id="75b41-111">I valori minimi e massimi che può rappresentare.</span><span class="sxs-lookup"><span data-stu-id="75b41-111">The maximum and minimum values that it can represent.</span></span>  
  
- <span data-ttu-id="75b41-112">I membri (metodi, campi, eventi e così via) in esso contenuti.</span><span class="sxs-lookup"><span data-stu-id="75b41-112">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
- <span data-ttu-id="75b41-113">Il tipo di base da cui eredita.</span><span class="sxs-lookup"><span data-stu-id="75b41-113">The base type it inherits from.</span></span>  
  
- <span data-ttu-id="75b41-114">Il percorso in cui viene allocata la memoria per le variabili in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="75b41-114">The location where the memory for variables will be allocated at run time.</span></span>  
  
- <span data-ttu-id="75b41-115">I tipi di operazioni consentite.</span><span class="sxs-lookup"><span data-stu-id="75b41-115">The kinds of operations that are permitted.</span></span>  
  
<span data-ttu-id="75b41-116">Il compilatore usa le informazioni sul tipo per assicurarsi che tutte le operazioni eseguite nel codice siano *indipendenti dai tipi*.</span><span class="sxs-lookup"><span data-stu-id="75b41-116">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="75b41-117">Se ad esempio si dichiara una variabile di tipo [int](language-reference/builtin-types/integral-numeric-types.md), il compilatore consente di usare la variabile anche in operazioni di addizione e sottrazione.</span><span class="sxs-lookup"><span data-stu-id="75b41-117">For example, if you declare a variable of type [int](language-reference/builtin-types/integral-numeric-types.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="75b41-118">Se si prova a eseguire le stesse operazioni su una variabile di tipo [bool](language-reference/builtin-types/bool.md), il compilatore genera un errore, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="75b41-118">If you try to perform those same operations on a variable of type [bool](language-reference/builtin-types/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  
  
> [!NOTE]  
> <span data-ttu-id="75b41-119">Gli sviluppatori C e C++ devono tenere presente che, in C#, [bool](language-reference/builtin-types/bool.md) non è convertibile in [int](language-reference/builtin-types/integral-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-119">C and C++ developers, notice that in C#, [bool](language-reference/builtin-types/bool.md) is not convertible to [int](language-reference/builtin-types/integral-numeric-types.md).</span></span>  
  
<span data-ttu-id="75b41-120">Il compilatore incorpora le informazioni sul tipo nel file eseguibile come metadati.</span><span class="sxs-lookup"><span data-stu-id="75b41-120">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="75b41-121">Il Common Language Runtime (CLR) usa i metadati in fase di esecuzione per garantire una maggiore indipendenza dai tipi quando alloca e recupera la memoria.</span><span class="sxs-lookup"><span data-stu-id="75b41-121">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  

## <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="75b41-122">Specifica dei tipi nelle dichiarazioni di variabile</span><span class="sxs-lookup"><span data-stu-id="75b41-122">Specifying types in variable declarations</span></span>

<span data-ttu-id="75b41-123">Quando si dichiara una variabile o una costante in un programma, è necessario specificarne il tipo oppure usare la parola chiave [var](language-reference/keywords/var.md) per consentire al compilatore di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="75b41-123">When you declare a variable or constant in a program, you must either specify its type or use the [var](language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="75b41-124">L'esempio seguente illustra alcune dichiarazioni di variabili che usano sia tipi numerici incorporati sia tipi complessi definiti dall'utente:</span><span class="sxs-lookup"><span data-stu-id="75b41-124">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  
  
<span data-ttu-id="75b41-125">I tipi di parametri e valori restituiti del metodo sono specificati nella firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="75b41-125">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="75b41-126">La firma seguente illustra un metodo che richiede un [int](language-reference/builtin-types/integral-numeric-types.md) come argomento di input e restituisce una stringa:</span><span class="sxs-lookup"><span data-stu-id="75b41-126">The following signature shows a method that requires an [int](language-reference/builtin-types/integral-numeric-types.md) as an input argument and returns a string:</span></span>  
  
[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  
  
<span data-ttu-id="75b41-127">Una variabile dichiarata non può essere dichiarata una seconda volta con un tipo nuovo e non è possibile assegnare a tale variabile un valore non compatibile con il relativo tipo dichiarato.</span><span class="sxs-lookup"><span data-stu-id="75b41-127">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="75b41-128">Ad esempio, non è possibile dichiarare un valore [int](language-reference/builtin-types/integral-numeric-types.md) e quindi assegnargli un valore booleano `true` .</span><span class="sxs-lookup"><span data-stu-id="75b41-128">For example, you cannot declare an [int](language-reference/builtin-types/integral-numeric-types.md) and then assign it a Boolean value of `true`.</span></span> <span data-ttu-id="75b41-129">I valori possono tuttavia essere convertiti in altri tipi, ad esempio quando vengono assegnati a nuove variabili o passati come argomenti di metodo.</span><span class="sxs-lookup"><span data-stu-id="75b41-129">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="75b41-130">Una *conversione del tipo* che non causa la perdita di dati viene eseguita automaticamente dal compilatore,</span><span class="sxs-lookup"><span data-stu-id="75b41-130">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="75b41-131">mentre una conversione che può causare la perdita di dati richiede un *cast* nel codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="75b41-131">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="75b41-132">Per altre informazioni, vedere [cast e conversioni di tipi](programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-132">For more information, see [Casting and type conversions](programming-guide/types/casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="75b41-133">Tipi incorporati</span><span class="sxs-lookup"><span data-stu-id="75b41-133">Built-in types</span></span>

<span data-ttu-id="75b41-134">Il linguaggio C# offre un set standard di tipi numerici incorporati per rappresentare numeri interi, valori a virgola mobile, espressioni booleane, caratteri di testo, valori decimali e altri tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="75b41-134">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="75b41-135">Sono anche disponibili tipi **string** e **object** predefiniti.</span><span class="sxs-lookup"><span data-stu-id="75b41-135">There are also built-in **string** and **object** types.</span></span> <span data-ttu-id="75b41-136">Questi possono essere usati in qualsiasi programma C#.</span><span class="sxs-lookup"><span data-stu-id="75b41-136">These are available for you to use in any C# program.</span></span> <span data-ttu-id="75b41-137">Per l'elenco completo dei tipi incorporati, vedere [tipi incorporati](language-reference/builtin-types/built-in-types.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-137">For the complete list of the built-in types, see [Built-in types](language-reference/builtin-types/built-in-types.md).</span></span>
  
## <a name="custom-types"></a><span data-ttu-id="75b41-138">Tipi personalizzati</span><span class="sxs-lookup"><span data-stu-id="75b41-138">Custom types</span></span>

<span data-ttu-id="75b41-139">Usare i costrutti [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md) e [enum](language-reference/builtin-types/enum.md) per creare tipi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="75b41-139">You use the [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md), and [enum](language-reference/builtin-types/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="75b41-140">La libreria di classi .NET Framework è una raccolta di tipi personalizzati offerti da Microsoft che è possibile usare nelle nuove applicazioni.</span><span class="sxs-lookup"><span data-stu-id="75b41-140">The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="75b41-141">Per impostazione predefinita, i tipi più comunemente usati nella libreria di classi sono disponibili in qualsiasi programma C#,</span><span class="sxs-lookup"><span data-stu-id="75b41-141">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="75b41-142">mentre altri diventano disponibili solo quando si aggiunge in modo esplicito un riferimento di progetto all'assembly in cui sono definiti.</span><span class="sxs-lookup"><span data-stu-id="75b41-142">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="75b41-143">Nel momento in cui il compilatore ha un riferimento all'assembly, è possibile dichiarare variabili (e costanti) dei tipi dichiarati nell'assembly in codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="75b41-143">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span>
  
## <a name="generic-types"></a><span data-ttu-id="75b41-144">Tipi generici</span><span class="sxs-lookup"><span data-stu-id="75b41-144">Generic types</span></span>

<span data-ttu-id="75b41-145">Un tipo può essere dichiarato con uno o più *parametri di tipo* che agiscono da segnaposto per il tipo effettivo (*tipo concreto*) che il codice client specifica quando si crea un'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="75b41-145">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="75b41-146">Questi tipi sono definiti *tipi generici*.</span><span class="sxs-lookup"><span data-stu-id="75b41-146">Such types are called *generic types*.</span></span> <span data-ttu-id="75b41-147">Ad esempio, il tipo <xref:System.Collections.Generic.List%601> di .NET Framework dispone di un parametro di tipo a cui per convenzione viene assegnato il nome *T*. Quando si crea un'istanza del tipo, si specifica il tipo degli oggetti che l'elenco conterrà, ad esempio, String:</span><span class="sxs-lookup"><span data-stu-id="75b41-147">For example, the .NET Framework type <xref:System.Collections.Generic.List%601> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
  
[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)]
  
<span data-ttu-id="75b41-148">L'uso del parametro di tipo consente di riutilizzare la stessa classe per contenere qualsiasi tipo di elemento senza dover convertire ogni elemento in [object](language-reference/builtin-types/reference-types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="75b41-148">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](language-reference/builtin-types/reference-types.md#the-object-type).</span></span> <span data-ttu-id="75b41-149">Le classi di raccolte generiche sono denominate *raccolte fortemente tipizzate* perché il compilatore conosce il tipo specifico degli elementi della raccolta e può generare un errore in fase di compilazione se, ad esempio, si tenta di aggiungere un numero intero all' `strings` oggetto nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="75b41-149">Generic collection classes are called *strongly typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example.</span></span> <span data-ttu-id="75b41-150">Per altre informazioni, vedere [Generics](programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-150">For more information, see [Generics](programming-guide/generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-tuple-types"></a><span data-ttu-id="75b41-151">Tipi impliciti, tipi anonimi e tipi di tupla</span><span class="sxs-lookup"><span data-stu-id="75b41-151">Implicit types, anonymous types, and tuple types</span></span>

<span data-ttu-id="75b41-152">Come indicato in precedenza, è possibile tipizzare una variabile locale (ma non membri di classe) in modo implicito usando la parola chiave [var](language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-152">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="75b41-153">Alla variabile viene comunque assegnato un tipo in fase di compilazione, specificato dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="75b41-153">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="75b41-154">Per altre informazioni, vedere [variabili locali tipizzate in modo implicito](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-154">For more information, see [Implicitly typed local variables](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
<span data-ttu-id="75b41-155">In alcuni casi non è consigliabile creare un tipo denominato per set semplici di valori correlati che non si intende archiviare o passare fuori dai limiti del metodo.</span><span class="sxs-lookup"><span data-stu-id="75b41-155">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="75b41-156">A questo scopo è possibile creare *tipi anonimi*.</span><span class="sxs-lookup"><span data-stu-id="75b41-156">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="75b41-157">Per ulteriori informazioni, vedere [tipi anonimi](programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-157">For more information, see [Anonymous types](programming-guide/classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="75b41-158">È prassi comune voler restituire più valori da un metodo.</span><span class="sxs-lookup"><span data-stu-id="75b41-158">It's common to want to return more than one value from a method.</span></span> <span data-ttu-id="75b41-159">È possibile creare *tipi di tupla* che restituiscono più valori in una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="75b41-159">You can create *tuple types* that return multiple values in a single method call.</span></span> <span data-ttu-id="75b41-160">Per altre informazioni, vedere [tipi di tupla](language-reference/builtin-types/value-tuples.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-160">For more information, see [Tuple types](language-reference/builtin-types/value-tuples.md).</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="75b41-161">Sistema dei tipi comuni</span><span class="sxs-lookup"><span data-stu-id="75b41-161">The Common type system</span></span>

<span data-ttu-id="75b41-162">È importante capire due punti fondamentali sul sistema dei tipi in .NET Framework:</span><span class="sxs-lookup"><span data-stu-id="75b41-162">It is important to understand two fundamental points about the type system in the .NET Framework:</span></span>  
  
- <span data-ttu-id="75b41-163">Supporta il principio di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="75b41-163">It supports the principle of inheritance.</span></span> <span data-ttu-id="75b41-164">I tipi possono derivare da altri tipi, denominati *tipi di base*.</span><span class="sxs-lookup"><span data-stu-id="75b41-164">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="75b41-165">Il tipo derivato eredita (con alcune limitazioni) metodi, proprietà e altri membri del tipo di base,</span><span class="sxs-lookup"><span data-stu-id="75b41-165">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="75b41-166">che a sua volta può derivare da un altro tipo. In questo caso, il tipo derivato eredita i membri di entrambi i tipi di base nella gerarchia di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="75b41-166">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="75b41-167">Tutti i tipi, inclusi i tipi numerici predefiniti, ad esempio <xref:System.Int32> (parola chiave C#: `int`), derivano in definitiva da un unico tipo di base, ovvero <xref:System.Object> (parola chiave C#: `object`).</span><span class="sxs-lookup"><span data-stu-id="75b41-167">All types, including built-in numeric types such as <xref:System.Int32> (C# keyword: `int`), derive ultimately from a single base type, which is <xref:System.Object> (C# keyword: `object`).</span></span> <span data-ttu-id="75b41-168">Questa gerarchia di tipi unificata è chiamata [Common Type System](../standard/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="75b41-168">This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS).</span></span> <span data-ttu-id="75b41-169">Per altre informazioni sull'ereditarietà in C#, vedere [Ereditarietà](programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-169">For more information about inheritance in C#, see [Inheritance](programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
- <span data-ttu-id="75b41-170">Nel CTS ogni tipo è definito come *tipo valore* o *tipo riferimento*.</span><span class="sxs-lookup"><span data-stu-id="75b41-170">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="75b41-171">In queste due categorie sono inclusi anche tutti i tipi personalizzati nella libreria di classi .NET e i tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="75b41-171">This includes all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="75b41-172">I tipi definiti tramite la `struct` `enum` parola chiave o sono tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="75b41-172">Types that you define by using the `struct` or `enum` keyword are value types.</span></span> <span data-ttu-id="75b41-173">Per ulteriori informazioni sui tipi di valore, vedere [tipi di valore](language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-173">For more information about value types, see [Value types](language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="75b41-174">I tipi definiti tramite la parola chiave [class](language-reference/keywords/class.md) sono tipi riferimento.</span><span class="sxs-lookup"><span data-stu-id="75b41-174">Types that you define by using the [class](language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="75b41-175">Per altre informazioni sui tipi di riferimento, vedere [Classi](programming-guide/classes-and-structs/classes.md).</span><span class="sxs-lookup"><span data-stu-id="75b41-175">For more information about reference types, see [Classes](programming-guide/classes-and-structs/classes.md).</span></span> <span data-ttu-id="75b41-176">I tipi di riferimento e i tipi di valore hanno regole diverse e un comportamento diverso in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="75b41-176">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

## <a name="see-also"></a><span data-ttu-id="75b41-177">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="75b41-177">See also</span></span>

- [<span data-ttu-id="75b41-178">Tipi di struttura</span><span class="sxs-lookup"><span data-stu-id="75b41-178">Structure types</span></span>](language-reference/builtin-types/struct.md)
- [<span data-ttu-id="75b41-179">Tipi di enumerazione</span><span class="sxs-lookup"><span data-stu-id="75b41-179">Enumeration types</span></span>](language-reference/builtin-types/enum.md)
- [<span data-ttu-id="75b41-180">Classi</span><span class="sxs-lookup"><span data-stu-id="75b41-180">Classes</span></span>](programming-guide/classes-and-structs/classes.md)
