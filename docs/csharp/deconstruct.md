---
title: Decostruzione di tuple e altri tipi
description: Informazioni su come decostruire le tuple e altri tipi.
ms.technology: csharp-fundamentals
ms.date: 11/23/2017
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: d238f6f520653befb1464377094b93e34dde0eca
ms.sourcegitcommit: 927b7ea6b2ea5a440c8f23e3e66503152eb85591
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/16/2020
ms.locfileid: "81463132"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="377d2-103">Decostruzione di tuple e altri tipi</span><span class="sxs-lookup"><span data-stu-id="377d2-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="377d2-104">Una tupla è un metodo semplice per recuperare più valori da una chiamata a un metodo.</span><span class="sxs-lookup"><span data-stu-id="377d2-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="377d2-105">Tuttavia dopo aver recuperato la tupla è necessario gestirne i singoli elementi.</span><span class="sxs-lookup"><span data-stu-id="377d2-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="377d2-106">Se eseguita un elemento alla volta, questa operazione può risultare molto laboriosa, come visualizzato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="377d2-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="377d2-107">Il metodo `QueryCityData` restituisce una tupla con 3 elementi e ogni elemento viene assegnato a una variabile in un'operazione separata.</span><span class="sxs-lookup"><span data-stu-id="377d2-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="377d2-108">Il recupero di più valori di campi e proprietà da un oggetto può essere altrettanto complesso: è necessario assegnare un valore di campo o proprietà a una variabile, un membro alla volta.</span><span class="sxs-lookup"><span data-stu-id="377d2-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="377d2-109">A partire da C# 7.0 è possibile recuperare più elementi da una tupla o recuperare più valori di campi, proprietà e valori calcolati da un oggetto in una singola operazione di *decostruzione*.</span><span class="sxs-lookup"><span data-stu-id="377d2-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="377d2-110">Quando si decostruisce una tupla gli elementi corrispondenti vengono assegnati a singole variabili.</span><span class="sxs-lookup"><span data-stu-id="377d2-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="377d2-111">Quando si decostruisce un oggetto si assegnano valori selezionati a singole variabili.</span><span class="sxs-lookup"><span data-stu-id="377d2-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="377d2-112">Decostruzione di una tupla</span><span class="sxs-lookup"><span data-stu-id="377d2-112">Deconstructing a tuple</span></span>

<span data-ttu-id="377d2-113">In C# è incluso il supporto per la decostruzione di tuple, che consente di decomprimere tutti gli elementi di una tupla in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="377d2-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="377d2-114">La sintassi generale per la decostruzione di una tupla è simile alla sintassi per la definizione della tupla: le variabili a cui va assegnato ogni elemento vengono racchiuse tra parentesi sul lato sinistro di un'istruzione di assegnazione.</span><span class="sxs-lookup"><span data-stu-id="377d2-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="377d2-115">Ad esempio l'istruzione seguente assegna gli elementi di una tupla con 4 elementi a quattro variabili distinte:</span><span class="sxs-lookup"><span data-stu-id="377d2-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="377d2-116">Esistono tre modi per decostruire una tupla:</span><span class="sxs-lookup"><span data-stu-id="377d2-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="377d2-117">È possibile dichiarare in modo esplicito il tipo di ogni campo all'interno di parentesi.</span><span class="sxs-lookup"><span data-stu-id="377d2-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="377d2-118">Nell'esempio seguente viene usato questo approccio per decostruire la tupla con 3 elementi restituita dal metodo `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="377d2-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="377d2-119">È possibile usare la parola chiave `var` in modo che C# deduca il tipo di ogni variabile.</span><span class="sxs-lookup"><span data-stu-id="377d2-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="377d2-120">Posizionare la parola chiave `var` all'esterno delle parentesi.</span><span class="sxs-lookup"><span data-stu-id="377d2-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="377d2-121">Nell'esempio seguente viene usata l'inferenza del tipo questo approccio per decostruire la tupla con 3 elementi restituita dal metodo `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="377d2-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="377d2-122">È anche possibile usare la parola chiave `var` individualmente con una o con tutte le dichiarazioni di variabili all'interno delle parentesi.</span><span class="sxs-lookup"><span data-stu-id="377d2-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="377d2-123">Questo approccio è eccessivamente complesso e non è consigliato.</span><span class="sxs-lookup"><span data-stu-id="377d2-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="377d2-124">Infine, è possibile decostruire la tupla in variabili che sono già state dichiarate.</span><span class="sxs-lookup"><span data-stu-id="377d2-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="377d2-125">Si noti che non è possibile usare un tipo specifico all'esterno delle parentesi, anche se ogni campo nella tupla presenta lo stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="377d2-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="377d2-126">Questa operazione genera l'errore del compilatore CS8136 "Nel form di decostruzione 'var (...)' non è consentito un tipo specifico per 'var'".</span><span class="sxs-lookup"><span data-stu-id="377d2-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="377d2-127">Si noti anche che è necessario assegnare ogni elemento della tupla a una variabile.</span><span class="sxs-lookup"><span data-stu-id="377d2-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="377d2-128">Se si omette un elemento, il compilatore genera l'errore CS8132: "Non è possibile decostruire una tupla di 'x' elementi in 'y' variabili".</span><span class="sxs-lookup"><span data-stu-id="377d2-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="377d2-129">Si noti che non è possibile combinare le dichiarazioni e le assegnazioni a variabili esistenti sul lato sinistro di una decostruzione.</span><span class="sxs-lookup"><span data-stu-id="377d2-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="377d2-130">Questa operazione genera l'errore del compilatore CS8184: "Nella parte sinistra di una decostruzione non è possibile combinare dichiarazioni ed espressioni"</span><span class="sxs-lookup"><span data-stu-id="377d2-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="377d2-131">quando i membri includono variabili esistenti e appena dichiarate.</span><span class="sxs-lookup"><span data-stu-id="377d2-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="377d2-132">Decostruzione degli elementi della tupla con variabili discard</span><span class="sxs-lookup"><span data-stu-id="377d2-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="377d2-133">Spesso quando si decostruisce una tupla si è interessati solo ai valori di alcuni elementi.</span><span class="sxs-lookup"><span data-stu-id="377d2-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="377d2-134">A partire da C# 7.0 è possibile avvalersi del supporto in C# delle variabili *discard*, variabili di sola scrittura delle quali si è scelto di ignorare i valori.</span><span class="sxs-lookup"><span data-stu-id="377d2-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="377d2-135">Una variabile discard è indicata da un carattere di sottolineatura ("\_") in un'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="377d2-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="377d2-136">È possibile rimuovere il numero di valori desiderato; tutti sono rappresentati dalla variabile discard singola `_`.</span><span class="sxs-lookup"><span data-stu-id="377d2-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="377d2-137">L'esempio seguente illustra l'uso delle tuple con le variabili discard.</span><span class="sxs-lookup"><span data-stu-id="377d2-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="377d2-138">Il metodo `QueryCityDataForYears` restituisce una tupla con 6 elementi con il nome di una città, l'area della città, un anno, la popolazione della città per tale anno, un secondo anno e la popolazione della città per tale anno.</span><span class="sxs-lookup"><span data-stu-id="377d2-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="377d2-139">L'esempio visualizza la variazione della popolazione tra questi due anni.</span><span class="sxs-lookup"><span data-stu-id="377d2-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="377d2-140">Tra i dati resi disponibili dalla tupla non interessa l'area della città, mentre il nome della città e le due date sono già noti in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="377d2-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="377d2-141">Di conseguenza interessano soltanto i due valori di popolazione archiviati nella tupla, mentre gli altri valori possono essere gestiti come variabili discard.</span><span class="sxs-lookup"><span data-stu-id="377d2-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="377d2-142">Decostruzione dei tipi definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="377d2-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="377d2-143">C# non offre il supporto predefinito per la decostruzione di tipi diversi da tuple.</span><span class="sxs-lookup"><span data-stu-id="377d2-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="377d2-144">Tuttavia l'autore di una classe, uno struct o un'interfaccia può consentire la decostruzione di istanze del tipo implementando uno o più metodi `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="377d2-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="377d2-145">Il metodo restituisce un valore void e ogni valore da decostruire è indicato da un parametro [out](language-reference/keywords/out-parameter-modifier.md) nella firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="377d2-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="377d2-146">Ad esempio il seguente metodo `Deconstruct` di una classe `Person` restituisce il nome, il secondo nome e il cognome:</span><span class="sxs-lookup"><span data-stu-id="377d2-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="377d2-147">È quindi possibile decostruire un'istanza della classe `Person` denominata `p` con un'assegnazione simile alla seguente:</span><span class="sxs-lookup"><span data-stu-id="377d2-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="377d2-148">L'esempio che segue implementa l'overload del metodo `Deconstruct` per restituire varie combinazioni di proprietà di un oggetto `Person`.</span><span class="sxs-lookup"><span data-stu-id="377d2-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="377d2-149">I singoli overload restituiscono:</span><span class="sxs-lookup"><span data-stu-id="377d2-149">Individual overloads return:</span></span>

- <span data-ttu-id="377d2-150">Un nome e un cognome.</span><span class="sxs-lookup"><span data-stu-id="377d2-150">A first and last name.</span></span>
- <span data-ttu-id="377d2-151">Un nome, un secondo nome e un cognome.</span><span class="sxs-lookup"><span data-stu-id="377d2-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="377d2-152">Un nome, un cognome, un nome di città e un nome di stato.</span><span class="sxs-lookup"><span data-stu-id="377d2-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="377d2-153">Poiché è possibile eseguire l'overload del metodo `Deconstruct` in modo da riflettere gruppi di dati estratti comunemente da un oggetto, è importante definire metodi `Deconstruct` con firme uniche e non ambigue.</span><span class="sxs-lookup"><span data-stu-id="377d2-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="377d2-154">Più metodi `Deconstruct` che hanno lo stesso numero di parametri `out` o lo stesso numero e tipo di parametri `out` in un ordine diverso possono provocare confusione.</span><span class="sxs-lookup"><span data-stu-id="377d2-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="377d2-155">Il metodo `Deconstruct` con overload dell'esempio seguente visualizza una possibile causa di confusione.</span><span class="sxs-lookup"><span data-stu-id="377d2-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="377d2-156">Il primo overload restituisce il nome, il secondo nome, il cognome e l'età di un oggetto `Person` in quest'ordine.</span><span class="sxs-lookup"><span data-stu-id="377d2-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="377d2-157">Il secondo overload restituisce solo le informazioni del nome oltre al reddito annuale, ma i dati relativi a nome, secondo nome e cognome sono in un ordine diverso.</span><span class="sxs-lookup"><span data-stu-id="377d2-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="377d2-158">In questo modo è più facile confondere l'ordine degli argomenti quando si esegue la decostruzione di un'istanza di `Person`.</span><span class="sxs-lookup"><span data-stu-id="377d2-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="377d2-159">Decostruzione di un tipo definito dall'utente con variabili discard</span><span class="sxs-lookup"><span data-stu-id="377d2-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="377d2-160">Come per le [tuple](#deconstructing-tuple-elements-with-discards), è possibile usare le variabili discard per ignorare elementi selezionati restituiti da un metodo `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="377d2-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="377d2-161">Ogni variabile discard è definita da una variabile denominata \_ e una singola operazione di decostruzione può includere diverse variabili discard.</span><span class="sxs-lookup"><span data-stu-id="377d2-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="377d2-162">L'esempio seguente esegue la decostruzione di un oggetto `Person` in quattro stringhe (nome, cognome, città e stato) ma rimuove il cognome e lo stato.</span><span class="sxs-lookup"><span data-stu-id="377d2-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="377d2-163">Decostruzione di un tipo definito dall'utente con un metodo di estensione</span><span class="sxs-lookup"><span data-stu-id="377d2-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="377d2-164">Anche un utente che non ha creato una classe, uno struct o un'interfaccia può eseguire la decostruzione di oggetti di questo tipo implementando uno o più `Deconstruct` [metodi di estensione](programming-guide/classes-and-structs/extension-methods.md) per restituire i valori che risultano di interesse.</span><span class="sxs-lookup"><span data-stu-id="377d2-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="377d2-165">L'esempio riportato di seguito illustra due metodi di estensione `Deconstruct` per la classe <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="377d2-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="377d2-166">Il primo metodo restituisce un set di valori che indicano le caratteristiche della proprietà: il tipo, se è statica o di istanza, se è di sola lettura e se è indicizzata.</span><span class="sxs-lookup"><span data-stu-id="377d2-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="377d2-167">Il secondo indica l'accessibilità della proprietà.</span><span class="sxs-lookup"><span data-stu-id="377d2-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="377d2-168">Dato che l'accessibilità delle funzioni di accesso get e set può essere diversa, i valori booleani indicano se la proprietà ha funzioni di accesso get e set separate e in questo caso se tali funzioni presentano la stessa accessibilità.</span><span class="sxs-lookup"><span data-stu-id="377d2-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="377d2-169">Se è presente solo una funzione di accesso o se le funzioni di accesso get e set hanno la stessa accessibilità, la variabile `access` indica l'accessibilità della proprietà nel suo complesso.</span><span class="sxs-lookup"><span data-stu-id="377d2-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="377d2-170">In caso contrario l'accessibilità delle funzioni di accesso get e set è indicata dalle variabili `getAccess` e `setAccess`.</span><span class="sxs-lookup"><span data-stu-id="377d2-170">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="377d2-171">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="377d2-171">See also</span></span>

- [<span data-ttu-id="377d2-172">Variabili discard</span><span class="sxs-lookup"><span data-stu-id="377d2-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="377d2-173">Tuple</span><span class="sxs-lookup"><span data-stu-id="377d2-173">Tuples</span></span>](tuples.md)
