---
title: Tipi tupla - Guida a C#
description: Informazioni sui tipi di tupla denominati e non denominati in C#
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 9ce9e1d4395d1a75f36004384ec215c615cd9802
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156909"
---
# <a name="c-tuple-types"></a><span data-ttu-id="3d70f-103">Tipi tupla in C#</span><span class="sxs-lookup"><span data-stu-id="3d70f-103">C# tuple types</span></span>

<span data-ttu-id="3d70f-104">Le tuple in C# sono tipi definiti tramite una sintassi leggera.</span><span class="sxs-lookup"><span data-stu-id="3d70f-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="3d70f-105">I vantaggi includono una sintassi più semplice, regole per le conversioni basate sul numero (note come cardinalità) e sui tipi di elementi, nonché regole coerenti per copie, test di uguaglianza e assegnazioni.</span><span class="sxs-lookup"><span data-stu-id="3d70f-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="3d70f-106">Lo svantaggio è che le tuple non supportano alcuni dei meccanismi orientati agli oggetti associati all'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="3d70f-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="3d70f-107">È possibile ottenere una panoramica nella sezione dedicata alle tuple nell'articolo [Novità di C# 7.0](whats-new/csharp-7.md#tuples).</span><span class="sxs-lookup"><span data-stu-id="3d70f-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="3d70f-108">Questo articolo descrive le regole del linguaggio che controllano le tuple in C# 7.0 e versioni successive, i diversi modi per usarle e linee guida iniziali per l'utilizzo delle tuple.</span><span class="sxs-lookup"><span data-stu-id="3d70f-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="3d70f-109">Le nuove funzionalità delle tuple richiedono i tipi <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="3d70f-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="3d70f-110">È necessario aggiungere il [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) pacchetto NuGet per utilizzarlo su piattaforme che non includono i tipi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="3d70f-111">È simile ad altre funzionalità del linguaggio basate sui tipi resi disponibili nel framework.</span><span class="sxs-lookup"><span data-stu-id="3d70f-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="3d70f-112">Alcuni esempi sono `async` e `await`, basati sull'interfaccia `INotifyCompletion`, e LINQ, basato su `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="3d70f-113">Tuttavia, il meccanismo di distribuzione sta cambiando perché .NET sta diventando più indipendente dalla piattaforma.</span><span class="sxs-lookup"><span data-stu-id="3d70f-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="3d70f-114">.NET Framework potrebbe non essere sempre distribuito secondo la stessa cadenza del compilatore del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="3d70f-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="3d70f-115">Quando nuove funzionalità del linguaggio si basano su nuovi tipi, tali tipi saranno disponibili come pacchetti NuGet al momento della distribuzione delle funzionalità del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="3d70f-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="3d70f-116">Una volta che questi nuovi tipi vengono aggiunti all'API standard .NET e distribuiti come parte del framework, il requisito del pacchetto NuGet viene rimosso.</span><span class="sxs-lookup"><span data-stu-id="3d70f-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="3d70f-117">Per iniziare, verranno spiegati i motivi dell'aggiunta del nuovo supporto per le tuple.</span><span class="sxs-lookup"><span data-stu-id="3d70f-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="3d70f-118">I metodi restituiscono un oggetto singolo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-118">Methods return a single object.</span></span> <span data-ttu-id="3d70f-119">Le tuple consentono di creare più facilmente pacchetti di valori multipli in questo oggetto singolo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="3d70f-120">.NET Framework dispone già di classi `Tuple` generiche.</span><span class="sxs-lookup"><span data-stu-id="3d70f-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="3d70f-121">Queste classi, tuttavia, presentano due limitazioni principali.</span><span class="sxs-lookup"><span data-stu-id="3d70f-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="3d70f-122">Da un lato, le classi `Tuple` hanno denominato le proprietà `Item1`, `Item2` e così via.</span><span class="sxs-lookup"><span data-stu-id="3d70f-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="3d70f-123">Questi nomi non includono informazioni semantiche.</span><span class="sxs-lookup"><span data-stu-id="3d70f-123">Those names carry no semantic information.</span></span> <span data-ttu-id="3d70f-124">L'uso di questi tipi `Tuple` non consente di comunicare il significato di ciascuna proprietà.</span><span class="sxs-lookup"><span data-stu-id="3d70f-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="3d70f-125">Le nuove funzionalità del linguaggio consentono di dichiarare e utilizzare nomi significativi semanticamente per gli elementi in una tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="3d70f-126">Le classi `Tuple` causano più problemi di prestazioni perché sono tipi riferimento.</span><span class="sxs-lookup"><span data-stu-id="3d70f-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="3d70f-127">L'uso di uno dei tipi `Tuple` si traduce nell'allocazione di oggetti.</span><span class="sxs-lookup"><span data-stu-id="3d70f-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="3d70f-128">Nei percorsi critici, l'allocazione di molti oggetti piccoli può avere un impatto notevole sulle prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="3d70f-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="3d70f-129">Pertanto, il supporto del linguaggio per le tuple sfrutta i nuovi struct `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="3d70f-130">Per evitare tali problematiche, è possibile creare un `class` o `struct` per supportare più elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="3d70f-131">Sfortunatamente, ciò comporta più lavoro per l'utente e rende poco chiare le finalità.</span><span class="sxs-lookup"><span data-stu-id="3d70f-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="3d70f-132">Compilare uno `struct` o una `class` implica la definizione di un tipo con dati e comportamento.</span><span class="sxs-lookup"><span data-stu-id="3d70f-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="3d70f-133">In molti casi, si desidera semplicemente archiviare più valori in un singolo oggetto.</span><span class="sxs-lookup"><span data-stu-id="3d70f-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="3d70f-134">Le funzionalità del linguaggio e gli struct `ValueTuple` generici applicano la regola che impedisce all'utente di aggiungere comportamenti (metodi) a questi tipi di tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="3d70f-135">Tutti i tipi `ValueTuple` sono *struct modificabili*.</span><span class="sxs-lookup"><span data-stu-id="3d70f-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="3d70f-136">Ogni campo del membro è un campo pubblico.</span><span class="sxs-lookup"><span data-stu-id="3d70f-136">Each member field is a public field.</span></span> <span data-ttu-id="3d70f-137">Questo rende i campi molto leggeri.</span><span class="sxs-lookup"><span data-stu-id="3d70f-137">That makes them very lightweight.</span></span> <span data-ttu-id="3d70f-138">Tuttavia, ciò implica che le tuple non devono essere usate nei contesti in cui l'immutabilità è un fattore importante.</span><span class="sxs-lookup"><span data-stu-id="3d70f-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="3d70f-139">Le tuple sono contenitori di dati più semplici e flessibili rispetto ai tipi `class` e `struct`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="3d70f-140">Esaminiamo queste differenze.</span><span class="sxs-lookup"><span data-stu-id="3d70f-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="3d70f-141">Tuple con e senza nome</span><span class="sxs-lookup"><span data-stu-id="3d70f-141">Named and unnamed tuples</span></span>

<span data-ttu-id="3d70f-142">Lo struct `ValueTuple` include campi denominati `Item1`, `Item2`, `Item3` e così via, simili alle proprietà definite nei tipi `Tuple` esistenti.</span><span class="sxs-lookup"><span data-stu-id="3d70f-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="3d70f-143">Questi nomi sono gli unici nomi che è possibile usare per le *tuple senza nome*.</span><span class="sxs-lookup"><span data-stu-id="3d70f-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="3d70f-144">Quando non si forniscono alla tupla nomi alternativi per i campi, viene creata una tupla senza nome:</span><span class="sxs-lookup"><span data-stu-id="3d70f-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="3d70f-145">La tupla nell'esempio precedente è stata inizializzata tramite costanti letterali e non avrà nomi di elemento creati con le *proiezioni dei nomi di campo di tupla* in C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="3d70f-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="3d70f-146">Tuttavia, quando si inizializza una tupla, è possibile usare nuove funzionalità del linguaggio che assegnano a ciascun campo un nome più semplice.</span><span class="sxs-lookup"><span data-stu-id="3d70f-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="3d70f-147">In questo modo viene creata una *tupla con nome*.</span><span class="sxs-lookup"><span data-stu-id="3d70f-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="3d70f-148">Le tuple con nome dispongono ancora di elementi denominati `Item1`, `Item2`, `Item3` e così via.</span><span class="sxs-lookup"><span data-stu-id="3d70f-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="3d70f-149">Hanno tuttavia anche sinonimi per eventuali elementi a cui l'utente ha assegnato un nome.</span><span class="sxs-lookup"><span data-stu-id="3d70f-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="3d70f-150">Creare una tupla con nome specificando i nomi per ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="3d70f-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="3d70f-151">Un modo consiste nello specificare i nomi come parte dell'inizializzazione della tupla:</span><span class="sxs-lookup"><span data-stu-id="3d70f-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="3d70f-152">I sinonimi vengono gestiti dal compilatore e dal linguaggio in modo che sia possibile usare efficacemente le tuple con nome.</span><span class="sxs-lookup"><span data-stu-id="3d70f-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="3d70f-153">Gli editor e gli IDE possono leggere questi nomi semantici tramite le API di Roslyn.</span><span class="sxs-lookup"><span data-stu-id="3d70f-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="3d70f-154">È possibile fare riferimento agli elementi di una tupla denominata tramite questi nomi semantici in qualsiasi punto dello stesso assembly.</span><span class="sxs-lookup"><span data-stu-id="3d70f-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="3d70f-155">Il compilatore sostituisce i nomi definiti con equivalenti `Item*` durante la generazione dell'output compilato.</span><span class="sxs-lookup"><span data-stu-id="3d70f-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="3d70f-156">Il Microsoft Intermediate Language (MSIL) compilato non include i nomi assegnati a questi elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="3d70f-157">A partire da C# 7.1, i nomi dei campi per una tupla possono essere forniti dalle variabili utilizzate per inizializzare la tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="3d70f-158">Si parla di **[inizializzatori di proiezione tupla](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="3d70f-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="3d70f-159">Il codice seguente crea una tupla denominata `accumulation` con elementi `count` (integer) e `sum` (double).</span><span class="sxs-lookup"><span data-stu-id="3d70f-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="3d70f-160">Il compilatore deve comunicare tali nomi creati per le tuple, restituiti dalle proprietà o dai metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="3d70f-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="3d70f-161">In questi casi, il compilatore aggiunge un attributo <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> al metodo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="3d70f-162">Questo attributo contiene una proprietà elenco <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> che presenta i nomi assegnati a ognuno degli elementi nella tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="3d70f-163">Anche gli strumenti di sviluppo come Visual Studio consentono di leggere i metadati e di fornirli a IntelliSense e ad altre funzionalità tramite i nomi dei campi dei metadati.</span><span class="sxs-lookup"><span data-stu-id="3d70f-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="3d70f-164">È importante comprendere questi principi fondamentali delle nuove tuple e del tipo `ValueTuple` per comprendere le regole per la mutua assegnazione delle tuple con nome.</span><span class="sxs-lookup"><span data-stu-id="3d70f-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="3d70f-165">Inizializzatori di proiezione tupla</span><span class="sxs-lookup"><span data-stu-id="3d70f-165">Tuple projection initializers</span></span>

<span data-ttu-id="3d70f-166">In generale, gli inizializzatori di proiezione tupla funzionano utilizzando i nomi di variabile o campo dal lato destro di un'istruzione di inizializzazione della tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="3d70f-167">Se viene fornito un nome esplicito, esso ha la precedenza su qualsiasi nome previsto.</span><span class="sxs-lookup"><span data-stu-id="3d70f-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="3d70f-168">Nell'inizializzatore seguente, ad esempio, gli elementi sono `explicitFieldOne` e `explicitFieldTwo`, non `localVariableOne` e `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="3d70f-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="3d70f-169">Per i campi in cui non viene specificato un nome esplicito, viene proiettato un nome implicito applicabile.</span><span class="sxs-lookup"><span data-stu-id="3d70f-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="3d70f-170">Non è obbligatorio fornire nomi semantici, in modo esplicito o implicito.</span><span class="sxs-lookup"><span data-stu-id="3d70f-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="3d70f-171">L'inizializzatore seguente ha nomi di campo `Item1` con valore `42`, e `stringContent` con valore "The answer to everything":</span><span class="sxs-lookup"><span data-stu-id="3d70f-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="3d70f-172">Esistono due condizioni in cui i nomi dei campi candidati non sono previsti nel campo di tupla:</span><span class="sxs-lookup"><span data-stu-id="3d70f-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="3d70f-173">Quando il nome candidato è un nome di tupla riservato.</span><span class="sxs-lookup"><span data-stu-id="3d70f-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="3d70f-174">Gli `Item3`esempi `ToString`includono `Rest`, , o .</span><span class="sxs-lookup"><span data-stu-id="3d70f-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="3d70f-175">Quando il nome candidato è un duplicato di un altro nome di campo di tupla, implicito o esplicito.</span><span class="sxs-lookup"><span data-stu-id="3d70f-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="3d70f-176">Queste condizioni evitano ogni ambiguità.</span><span class="sxs-lookup"><span data-stu-id="3d70f-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="3d70f-177">Questi nomi creerebbero un'ambiguità se utilizzati come nomi di campo per un campo in una tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="3d70f-178">Nessuna di queste condizioni causa errori in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3d70f-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="3d70f-179">Al contrario, per gli elementi senza nomi previsti non esistono nomi semantici previsti.</span><span class="sxs-lookup"><span data-stu-id="3d70f-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="3d70f-180">Gli esempi seguenti illustrano queste condizioni:</span><span class="sxs-lookup"><span data-stu-id="3d70f-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="3d70f-181">Queste situazioni non causano errori del compilatore perché sarebbe una modifica di rilievo per il codice scritto con C# 7.0, quando le proiezioni dei nomi di campo di tupla non erano disponibili.</span><span class="sxs-lookup"><span data-stu-id="3d70f-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="3d70f-182">Uguaglianza e tuple</span><span class="sxs-lookup"><span data-stu-id="3d70f-182">Equality and tuples</span></span>

<span data-ttu-id="3d70f-183">A partire da C# 7.3, i tipi tupla supportano gli operatori `==` e `!=`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="3d70f-184">Questi operatori confrontano ogni membro dell'argomento a sinistra con ogni membro dell'argomento a destra in ordine.</span><span class="sxs-lookup"><span data-stu-id="3d70f-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="3d70f-185">Questi confronti generano un corto circuito.</span><span class="sxs-lookup"><span data-stu-id="3d70f-185">These comparisons short-circuit.</span></span> <span data-ttu-id="3d70f-186">Interromperanno la valutazione dei membri non appena una coppia è diversa.</span><span class="sxs-lookup"><span data-stu-id="3d70f-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="3d70f-187">Gli esempi di codice seguenti usano `==`, ma tutte le regole di confronto si applicano anche a `!=`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="3d70f-188">L'esempio di codice seguente illustra un confronto di uguaglianza per due coppie di interi:</span><span class="sxs-lookup"><span data-stu-id="3d70f-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="3d70f-189">Esistono diverse regole che rendono più comodi i test di uguaglianza delle tuple.</span><span class="sxs-lookup"><span data-stu-id="3d70f-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="3d70f-190">I test di uguaglianza delle tuple eseguono [conversioni con elevazione](~/_csharplang/spec/conversions.md#lifted-conversion-operators) se una delle tuple è una tupla nullable, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="3d70f-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="3d70f-191">I test di uguaglianza delle tuple eseguono anche conversioni implicite per ogni membro di entrambe le tuple,</span><span class="sxs-lookup"><span data-stu-id="3d70f-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="3d70f-192">incluse conversioni con elevazione, conversioni verso un tipo di dati più grande o altre conversioni implicite.</span><span class="sxs-lookup"><span data-stu-id="3d70f-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="3d70f-193">Gli esempi seguenti mostrano che una tupla a 2 elementi integer può essere confrontata con una tupla a 2 elementi long a causa della conversione implicita da integer a long:</span><span class="sxs-lookup"><span data-stu-id="3d70f-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="3d70f-194">I nomi dei membri della tupla non partecipano ai test per l'uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="3d70f-195">Tuttavia, se uno degli operandi è una valore letterale di tupla con nomi espliciti, il compilatore genera l'avviso CS8383 se tali nomi non corrispondono ai nomi dell'altro operando.</span><span class="sxs-lookup"><span data-stu-id="3d70f-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="3d70f-196">Nel caso in cui entrambi gli operandi sono valori letterali di tupla, l'avviso viene generato per l'operando di destra, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="3d70f-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="3d70f-197">Infine, le tuple possono contenere tuple annidate.</span><span class="sxs-lookup"><span data-stu-id="3d70f-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="3d70f-198">L'uguaglianza delle tuple confronta la "forma" di ogni operando tramite tuple annidate, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="3d70f-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="3d70f-199">È un errore di compilazione confrontare due tuple per verificarne l'uguaglianza (o la disuguaglianza) quando hanno forme diverse.</span><span class="sxs-lookup"><span data-stu-id="3d70f-199">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="3d70f-200">Il compilatore non prova a decostruire le tuple annidate per confrontarle.</span><span class="sxs-lookup"><span data-stu-id="3d70f-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="3d70f-201">Assegnazione e tuple</span><span class="sxs-lookup"><span data-stu-id="3d70f-201">Assignment and tuples</span></span>

<span data-ttu-id="3d70f-202">Il linguaggio supporta l'assegnazione tra tipi tupla con lo stesso numero di elementi, in cui ogni elemento sul lato destro può essere convertito in modo implicito nell'elemento sul lato sinistro corrispondente.</span><span class="sxs-lookup"><span data-stu-id="3d70f-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="3d70f-203">Non vengono considerate altre conversioni per le assegnazioni.</span><span class="sxs-lookup"><span data-stu-id="3d70f-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="3d70f-204">È un errore in fase di compilazione assegnare una tupla a un'altra quando hanno forme diverse.</span><span class="sxs-lookup"><span data-stu-id="3d70f-204">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="3d70f-205">Il compilatore non tenterà la decostruzione di tuple annidate per assegnarle.</span><span class="sxs-lookup"><span data-stu-id="3d70f-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="3d70f-206">Esaminiamo i tipi di assegnazioni consentiti tra i tipi di tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="3d70f-207">Considerare le variabili usate negli esempi seguenti:</span><span class="sxs-lookup"><span data-stu-id="3d70f-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="3d70f-208">Le prime due variabili, `unnamed` e `anonymous`, non hanno nomi semantici forniti per gli elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="3d70f-209">I nomi dei campi sono `Item1` e `Item2`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="3d70f-210">Le ultime due variabili, `named` e `differentName`, hanno nomi semantici attribuiti agli elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="3d70f-211">Queste due tuple presentano nomi diversi per gli elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="3d70f-212">Tutte e quattro le tuple hanno lo stesso numero di elementi (noto come "cardinalità") e i tipi di tali elementi sono identici.</span><span class="sxs-lookup"><span data-stu-id="3d70f-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="3d70f-213">Pertanto, tutte queste assegnazioni funzionano:</span><span class="sxs-lookup"><span data-stu-id="3d70f-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="3d70f-214">Si noti che non sono assegnati i nomi delle tuple.</span><span class="sxs-lookup"><span data-stu-id="3d70f-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="3d70f-215">I valori degli elementi vengono assegnati seguendo l'ordine degli elementi nella tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="3d70f-216">Le tuple di tipi diversi o con numeri di elementi diversi non possono essere assegnate:</span><span class="sxs-lookup"><span data-stu-id="3d70f-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="3d70f-217">Tuple come valori restituiti dal metodo</span><span class="sxs-lookup"><span data-stu-id="3d70f-217">Tuples as method return values</span></span>

<span data-ttu-id="3d70f-218">Uno degli usi più comuni per le tuple è come valore restituito da metodo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="3d70f-219">Di seguito viene illustrato un esempio.</span><span class="sxs-lookup"><span data-stu-id="3d70f-219">Let's walk through one example.</span></span> <span data-ttu-id="3d70f-220">Si consideri il metodo che calcola la deviazione standard per una sequenza di numeri:</span><span class="sxs-lookup"><span data-stu-id="3d70f-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="3d70f-221">Questi esempi calcolano la deviazione standard non corretta di esempio.</span><span class="sxs-lookup"><span data-stu-id="3d70f-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="3d70f-222">La formula di deviazione standard non corretta di esempio consiste nel dividere la somma dei quadrati delle differenze rispetto al valore medio per (N-1) invece di N, come fa il metodo di estensione `Average`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="3d70f-223">Per altre informazioni sulle differenze tra queste formule di deviazione standard, consultare un testo di statistica.</span><span class="sxs-lookup"><span data-stu-id="3d70f-223">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="3d70f-224">Il codice precedente segue la formula canonica per la deviazione standard.</span><span class="sxs-lookup"><span data-stu-id="3d70f-224">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="3d70f-225">Genera la risposta corretta, ma si tratta di un'implementazione inefficiente.</span><span class="sxs-lookup"><span data-stu-id="3d70f-225">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="3d70f-226">Questo metodo enumera la sequenza due volte: una volta per produrre la media e una volta per produrre la media del quadrato della differenza della media.</span><span class="sxs-lookup"><span data-stu-id="3d70f-226">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="3d70f-227">Si noti che le query LINQ vengono valutate in modo differito, quindi il calcolo delle differenze rispetto al valore medio e la media tra tali differenze genera un'unica enumerazione.</span><span class="sxs-lookup"><span data-stu-id="3d70f-227">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="3d70f-228">Esiste una formula alternativa che calcola la deviazione standard usando solo un'enumerazione della sequenza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-228">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="3d70f-229">Questo calcolo produce due valori durante l'enumerazione della sequenza: la somma di tutti gli elementi nella sequenza e la somma di ogni valore quadrato:</span><span class="sxs-lookup"><span data-stu-id="3d70f-229">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="3d70f-230">Questa versione enumera la sequenza esattamente una volta.</span><span class="sxs-lookup"><span data-stu-id="3d70f-230">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="3d70f-231">Tuttavia, non si tratta di codice riutilizzabile.</span><span class="sxs-lookup"><span data-stu-id="3d70f-231">But it's not reusable code.</span></span> <span data-ttu-id="3d70f-232">Continuando a lavorare, si scoprirà che numerosi calcoli statistici usano il numero di elementi nella sequenza, la somma della sequenza e la somma dei quadrati della sequenza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-232">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="3d70f-233">Eseguiamo il refactoring di questo metodo e scriviamo un metodo di utilità che produce tutti e tre questi valori.</span><span class="sxs-lookup"><span data-stu-id="3d70f-233">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="3d70f-234">Tutti e tre i valori possono essere restituiti come tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-234">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="3d70f-235">Aggiorniamo questo metodo in modo tale che i tre valori calcolati durante l'enumerazione vengano archiviati in una tupla.</span><span class="sxs-lookup"><span data-stu-id="3d70f-235">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="3d70f-236">Questa operazione consente di creare questa versione:</span><span class="sxs-lookup"><span data-stu-id="3d70f-236">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="3d70f-237">Il supporto del refactoring di Visual Studio semplifica l'estrazione delle funzionalità per le statistiche principali in un metodo privato.</span><span class="sxs-lookup"><span data-stu-id="3d70f-237">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="3d70f-238">Ciò offre un metodo `private static` che restituisce il tipo di tupla con tre valori di `Sum`, `SumOfSquares`, e `Count`:</span><span class="sxs-lookup"><span data-stu-id="3d70f-238">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="3d70f-239">Il linguaggio fornisce due opzioni aggiuntive che è possibile usare se si desidera apportare manualmente rapide modifiche.</span><span class="sxs-lookup"><span data-stu-id="3d70f-239">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="3d70f-240">In primo luogo, è possibile usare la dichiarazione `var` per inizializzare il risultato della tupla dalla chiamata al metodo `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-240">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="3d70f-241">È anche possibile creare tre variabili discrete all'interno del metodo `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-241">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="3d70f-242">La versione finale è illustrata nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="3d70f-242">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="3d70f-243">Questa versione finale può essere usata per qualsiasi metodo che necessiti di questi tre valori o di sottoinsiemi di essi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-243">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="3d70f-244">Il linguaggio supporta altre opzioni per la gestione dei nomi degli elementi in questi metodi che restituiscono tuple.</span><span class="sxs-lookup"><span data-stu-id="3d70f-244">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="3d70f-245">È possibile rimuovere i nomi dei campi dalla dichiarazione di valore restituito e restituire una tupla senza nome:</span><span class="sxs-lookup"><span data-stu-id="3d70f-245">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="3d70f-246">I campi di questa tupla sono denominati `Item1`, `Item2` e `Item3`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-246">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="3d70f-247">Si consiglia di fornire nomi semantici agli elementi delle tuple restituite dai metodi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-247">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="3d70f-248">Un altro contesto in cui le tuple possono risultare utili è durante la creazione di query LINQ.</span><span class="sxs-lookup"><span data-stu-id="3d70f-248">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="3d70f-249">Il risultato proiettato finale spesso contiene alcune, ma non tutte le proprietà degli oggetti selezionati.</span><span class="sxs-lookup"><span data-stu-id="3d70f-249">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="3d70f-250">In genere, i risultati della query vengono proiettati in una sequenza di oggetti del tipo anonimo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-250">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="3d70f-251">Ciò presenta numerose limitazioni, principalmente perché i tipi anonimi non possono essere facilmente denominati nel tipo restituito per un metodo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-251">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="3d70f-252">In alternativa, usare `object` o `dynamic` come tipo del risultato offre costi significativi in termini di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="3d70f-252">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="3d70f-253">La restituzione di una sequenza di un tipo di tupla è semplice e i nomi e i tipi degli elementi sono disponibili in fase di compilazione e tramite gli strumenti IDE.</span><span class="sxs-lookup"><span data-stu-id="3d70f-253">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="3d70f-254">Si consideri, ad esempio, un'applicazione ToDo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-254">For example, consider a ToDo application.</span></span> <span data-ttu-id="3d70f-255">È possibile definire una classe simile alla seguente per rappresentare una singola voce nell'elenco ToDo:</span><span class="sxs-lookup"><span data-stu-id="3d70f-255">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="3d70f-256">Le applicazioni per dispositivi mobili possono supportare un modulo compresso delle voci ToDo correnti che visualizza solo il titolo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-256">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="3d70f-257">Questa query LINQ genera una proiezione che include solo l'ID e il titolo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-257">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="3d70f-258">Un metodo che restituisce una sequenza di tuple esprime in maniera accurata questa struttura:</span><span class="sxs-lookup"><span data-stu-id="3d70f-258">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="3d70f-259">In C# 7.1, le proiezioni di tupla consentono di creare tuple con nome utilizzando gli elementi, in modo simile alla denominazione di proprietà in tipi anonimi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-259">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="3d70f-260">Nel codice precedente, l'istruzione `select` nella proiezione di query crea una tupla che contiene elementi `ID` e `Title`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-260">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="3d70f-261">La tupla con nome può essere parte della firma.</span><span class="sxs-lookup"><span data-stu-id="3d70f-261">The named tuple can be part of the signature.</span></span> <span data-ttu-id="3d70f-262">Consente al compilatore e agli strumenti IDE di garantire in modo statico che si sta usando correttamente il risultato.</span><span class="sxs-lookup"><span data-stu-id="3d70f-262">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="3d70f-263">La tupla con nome contiene anche le informazioni sul tipo statico in modo da eliminare la necessità di usare le costose funzionalità di runtime quali la reflection o l'associazione dinamica al fine di lavorare con i risultati.</span><span class="sxs-lookup"><span data-stu-id="3d70f-263">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="3d70f-264">Decostruzione</span><span class="sxs-lookup"><span data-stu-id="3d70f-264">Deconstruction</span></span>

<span data-ttu-id="3d70f-265">È possibile decomprimere tutte le voci in una tupla *decostruendo* la tupla restituita da un metodo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-265">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="3d70f-266">Per la decostruzione delle tuple esistono tre diversi approcci.</span><span class="sxs-lookup"><span data-stu-id="3d70f-266">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="3d70f-267">È prima possibile dichiarare il tipo di ogni campo all'interno di parentesi per creare variabili discrete per ognuno degli elementi nella tupla:</span><span class="sxs-lookup"><span data-stu-id="3d70f-267">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="3d70f-268">È anche possibile dichiarare variabili tipizzate in modo implicito per ogni campo in una tupla usando la parola chiave `var` all'esterno delle parentesi:</span><span class="sxs-lookup"><span data-stu-id="3d70f-268">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="3d70f-269">In aggiunta, è possibile usare la parola chiave `var` con una o tutte le dichiarazioni di variabili all'interno delle parentesi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-269">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="3d70f-270">Non è possibile usare un tipo specifico all'esterno delle parentesi, anche se ogni campo nella tupla presenta lo stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="3d70f-270">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="3d70f-271">È possibile decostruire le tuple anche con le dichiarazioni esistenti:</span><span class="sxs-lookup"><span data-stu-id="3d70f-271">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="3d70f-272">Non è possibile combinare le dichiarazioni esistenti con dichiarazioni all'interno di parentesi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-272">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="3d70f-273">Ad esempio, la dichiarazione seguente non è consentita: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-273">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="3d70f-274">Questa operazione genera un errore CS8184 perché *x* è dichiarato all'interno delle parentesi e *y* è già stato dichiarato in precedenza in un'altra posizione.</span><span class="sxs-lookup"><span data-stu-id="3d70f-274">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="3d70f-275">Decostruzione dei tipi definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="3d70f-275">Deconstructing user-defined types</span></span>

<span data-ttu-id="3d70f-276">Qualsiasi tipo di tupla può essere decostruito come illustrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-276">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="3d70f-277">È anche semplice abilitare la decostruzione sui tipi definiti dall'utente (classi, struct o perfino interfacce).</span><span class="sxs-lookup"><span data-stu-id="3d70f-277">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="3d70f-278">L'autore del tipo può definire uno o più metodi `Deconstruct` che assegnano valori a qualsiasi numero di variabili `out` che rappresentano gli elementi di dati di cui il tipo è composto.</span><span class="sxs-lookup"><span data-stu-id="3d70f-278">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="3d70f-279">Ad esempio, il tipo `Person` seguente definisce un metodo `Deconstruct` che decostruisce un oggetto persona negli elementi che ne rappresentano nome e cognome:</span><span class="sxs-lookup"><span data-stu-id="3d70f-279">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="3d70f-280">Il metodo di decostruzione consente l'assegnazione da un `Person` a due stringhe, che rappresentano le proprietà `FirstName` e `LastName`:</span><span class="sxs-lookup"><span data-stu-id="3d70f-280">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="3d70f-281">È possibile abilitare la decostruzione anche per i tipi non creati dall'utente.</span><span class="sxs-lookup"><span data-stu-id="3d70f-281">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="3d70f-282">Il metodo `Deconstruct` può essere un metodo di estensione che decomprime i membri di dati accessibili di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="3d70f-282">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="3d70f-283">L'esempio seguente mostra un tipo `Student`, derivato dal tipo `Person` e un metodo di estensione che decostruisce un `Student` in tre variabili, che rappresentano `FirstName`, `LastName` e `GPA`:</span><span class="sxs-lookup"><span data-stu-id="3d70f-283">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="3d70f-284">Un oggetto `Student` dispone ora di due metodi `Deconstruct` di accesso: il metodo di estensione dichiarato per i tipi `Student` e i membri del tipo `Person`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-284">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="3d70f-285">Entrambi appartengono all'ambito, consentendo la decostruzione di un `Student` in due o tre variabili.</span><span class="sxs-lookup"><span data-stu-id="3d70f-285">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="3d70f-286">Se si assegna uno studente a tre variabili, vengono restituiti nome, cognome e GPA.</span><span class="sxs-lookup"><span data-stu-id="3d70f-286">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="3d70f-287">Se si assegna uno studente a due variabili, vengono restituiti solo nome e cognome.</span><span class="sxs-lookup"><span data-stu-id="3d70f-287">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="3d70f-288">È necessario prestare attenzione alla definizione di più metodi `Deconstruct` in una classe o in una gerarchia di classi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-288">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="3d70f-289">Più metodi `Deconstruct` che presentano lo stesso numero di parametri `out` possono rapidamente causare ambiguità.</span><span class="sxs-lookup"><span data-stu-id="3d70f-289">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="3d70f-290">I chiamanti potrebbero non essere in grado di eseguire facilmente chiamate al metodo `Deconstruct` desiderato.</span><span class="sxs-lookup"><span data-stu-id="3d70f-290">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="3d70f-291">In questo esempio, vi è una minima possibilità di chiamata ambigua perché il metodo `Deconstruct` per `Person` ha due parametri di output e il metodo `Deconstruct` per `Student` ne ha tre.</span><span class="sxs-lookup"><span data-stu-id="3d70f-291">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="3d70f-292">Gli operatori di decostruzione non partecipano ai test di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-292">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="3d70f-293">L'esempio seguente genera l'errore di compilazione CS0019:</span><span class="sxs-lookup"><span data-stu-id="3d70f-293">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="3d70f-294">Il metodo `Deconstruct` potrebbe convertire l'oggetto `Person``p` in una tupla che contiene due stringhe, ma ciò non è applicabile nel contesto dei test di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="3d70f-294">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="3d70f-295">Tuple come parametri outTuples as out parameters</span><span class="sxs-lookup"><span data-stu-id="3d70f-295">Tuples as out parameters</span></span>

<span data-ttu-id="3d70f-296">Le tuple possono essere utilizzate come parametri *out.*</span><span class="sxs-lookup"><span data-stu-id="3d70f-296">Tuples can be used as out parameters *themselves*.</span></span> <span data-ttu-id="3d70f-297">Da non confondere con alcuna ambiguità menzionata in precedenza nella sezione [Decostruzione.](#deconstruction)</span><span class="sxs-lookup"><span data-stu-id="3d70f-297">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="3d70f-298">In una chiamata al metodo, è necessario descrivere solo la forma della tupla:In a method call, you need only describe the tuple's shape:</span><span class="sxs-lookup"><span data-stu-id="3d70f-298">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="3d70f-299">In alternativa, è possibile utilizzare una tupla `Item1` `Item2` [_senza nome_](#named-and-unnamed-tuples) e fare riferimento ai relativi campi come e :</span><span class="sxs-lookup"><span data-stu-id="3d70f-299">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="3d70f-300">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="3d70f-300">Conclusion</span></span>

<span data-ttu-id="3d70f-301">Il nuovo supporto per linguaggio e libreria per le tuple con nome rende più semplice lavorare con schemi che usano strutture di dati che archiviano più elementi, ma non definiscono il comportamento, come le classi e gli struct.</span><span class="sxs-lookup"><span data-stu-id="3d70f-301">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="3d70f-302">Usare le tuple per questi tipi è semplice e veloce.</span><span class="sxs-lookup"><span data-stu-id="3d70f-302">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="3d70f-303">Si ottengono tutti i vantaggi del controllo del tipo statico, senza la necessità di creare tipi tramite la sintassi più dettagliata `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-303">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="3d70f-304">Anche in questo caso, risultano particolarmente utili per i metodi di utilità `private` o `internal`.</span><span class="sxs-lookup"><span data-stu-id="3d70f-304">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="3d70f-305">Creare tipi definiti dall'utente, tipi `class` o `struct` quando i metodi pubblici restituiscono un valore che contiene più elementi.</span><span class="sxs-lookup"><span data-stu-id="3d70f-305">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
