---
title: Tipi e variabili C# - Panoramica del linguaggio C#
description: Informazioni sulla definizione di tipi e la dichiarazione di variabili nel linguaggio C#
ms.date: 04/24/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: a14291d1eec4d090b0275875326c5a580e5abe9d
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174127"
---
# <a name="types-and-variables"></a><span data-ttu-id="c414a-103">Tipi e variabili</span><span class="sxs-lookup"><span data-stu-id="c414a-103">Types and variables</span></span>

<span data-ttu-id="c414a-104">In C# esistono due generi di tipi: *tipi valore* e *tipi riferimento*.</span><span class="sxs-lookup"><span data-stu-id="c414a-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="c414a-105">Le variabili dei tipi valore contengono direttamente i propri dati, mentre le variabili dei tipi riferimento archiviano i riferimenti ai propri dati, noti come oggetti.</span><span class="sxs-lookup"><span data-stu-id="c414a-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="c414a-106">Con i tipi di riferimento, è possibile che due variabili facciano riferimento allo stesso oggetto e pertanto le operazioni su una variabile influiscano sull'oggetto a cui fa riferimento l'altra variabile.</span><span class="sxs-lookup"><span data-stu-id="c414a-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="c414a-107">Con i tipi valore, ogni variabile ha una propria copia dei dati e non è possibile che le operazioni su uno influiscano sull'altro (ad eccezione `ref` delle `out` variabili di parametro e).</span><span class="sxs-lookup"><span data-stu-id="c414a-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="c414a-108">I tipi di valore di C# sono ulteriormente divisi in *tipi semplici*, *tipi enum*, *tipi struct*e *tipi di valore Nullable*.</span><span class="sxs-lookup"><span data-stu-id="c414a-108">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="c414a-109">I tipi di riferimento di C# sono ulteriormente divisi in *tipi di classe*, *tipi di interfaccia*, tipi di *matrici*e *tipi delegati*.</span><span class="sxs-lookup"><span data-stu-id="c414a-109">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="c414a-110">La struttura seguente fornisce una panoramica del sistema di tipi di C#.</span><span class="sxs-lookup"><span data-stu-id="c414a-110">The following outline provides an overview of C#'s type system.</span></span>

- <span data-ttu-id="c414a-111">[Tipi di valori][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="c414a-112">[Tipi semplici][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="c414a-113">Signed Integer: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="c414a-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="c414a-114">Unsigned Integer: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="c414a-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="c414a-115">Caratteri Unicode: `char`</span><span class="sxs-lookup"><span data-stu-id="c414a-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="c414a-116">File binario IEEE a virgola mobile: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="c414a-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="c414a-117">Decimale ad alta precisione a virgola mobile: `decimal`</span><span class="sxs-lookup"><span data-stu-id="c414a-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="c414a-118">Booleano: `bool`</span><span class="sxs-lookup"><span data-stu-id="c414a-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="c414a-119">[Tipi enum][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="c414a-120">Tipi definiti dall'utente nel formato `enum E {...}`</span><span class="sxs-lookup"><span data-stu-id="c414a-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="c414a-121">[Tipi struct][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="c414a-122">Tipi definiti dall'utente nel formato `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="c414a-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="c414a-123">[Tipi valore nullable][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="c414a-124">Estensioni di tutti gli altri tipi valore con un valore `null`</span><span class="sxs-lookup"><span data-stu-id="c414a-124">Extensions of all other value types with a `null` value</span></span>
  - <span data-ttu-id="c414a-125">[Tipi di valore di tupla][TupleTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-125">[Tuple value types][TupleTypes]</span></span>
    - <span data-ttu-id="c414a-126">Tipi definiti dall'utente nel formato `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="c414a-126">User-defined types of the form `(T1, T2, ...)`</span></span>
- <span data-ttu-id="c414a-127">[Tipi riferimento][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-127">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="c414a-128">[Tipi di classe][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-128">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="c414a-129">Classe di base principale di tutti gli altri tipi: `object`</span><span class="sxs-lookup"><span data-stu-id="c414a-129">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="c414a-130">Stringhe Unicode: `string`</span><span class="sxs-lookup"><span data-stu-id="c414a-130">Unicode strings: `string`</span></span>
    - <span data-ttu-id="c414a-131">Tipi definiti dall'utente nel formato `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="c414a-131">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="c414a-132">[Tipi di interfaccia][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-132">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="c414a-133">Tipi definiti dall'utente nel formato `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="c414a-133">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="c414a-134">[Tipi di matrice][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-134">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="c414a-135">Unidimensionale e multidimensionale, ad esempio `int[]` e `int[,]`</span><span class="sxs-lookup"><span data-stu-id="c414a-135">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="c414a-136">[Tipi delegato][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="c414a-136">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="c414a-137">Tipi definiti dall'utente nel formato `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="c414a-137">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[TupleTypes]: ../language-reference/builtin-types/value-tuples.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="c414a-138">Per altre informazioni sui tipi numerici, vedere la [tabella dei tipi integrali](../language-reference/builtin-types/integral-numeric-types.md) e la [tabella dei tipi a virgola mobile](../language-reference/builtin-types/floating-point-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="c414a-138">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="c414a-139">Il tipo di C# `bool` viene usato per rappresentare valori booleani, ovvero valori che sono `true` o `false` .</span><span class="sxs-lookup"><span data-stu-id="c414a-139">C#'s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="c414a-140">Per l'elaborazione di caratteri e stringhe, in C# viene usata la codifica Unicode.</span><span class="sxs-lookup"><span data-stu-id="c414a-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="c414a-141">Il tipo `char` rappresenta un'unità di codice UTF-16, mentre il tipo `string` rappresenta una sequenza di unità di codice UTF-16.</span><span class="sxs-lookup"><span data-stu-id="c414a-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="c414a-142">I programmi C# usano le *dichiarazioni di tipo* per creare nuovi tipi.</span><span class="sxs-lookup"><span data-stu-id="c414a-142">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="c414a-143">Una dichiarazione di tipo consente di specificare il nome e i membri del nuovo tipo.</span><span class="sxs-lookup"><span data-stu-id="c414a-143">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="c414a-144">Cinque delle categorie di tipi di C# sono definibili dall'utente: tipi di classe, tipi di struct, tipi di interfaccia, tipi enum e tipi delegati.</span><span class="sxs-lookup"><span data-stu-id="c414a-144">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="c414a-145">Un tipo `class` definisce una struttura dati contenente membri dati (campi) e membri funzione (metodi, proprietà e altro).</span><span class="sxs-lookup"><span data-stu-id="c414a-145">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="c414a-146">I tipi classe supportano l'ereditarietà singola e il polimorfismo, meccanismi in base ai quali le classi derivate possono estendere e specializzare le classi di base.</span><span class="sxs-lookup"><span data-stu-id="c414a-146">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="c414a-147">Un tipo `struct` è simile a un tipo classe in quanto rappresenta una struttura con membri dati e membri funzione.</span><span class="sxs-lookup"><span data-stu-id="c414a-147">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="c414a-148">Tuttavia, a differenza delle classi, gli struct sono tipi di valore e in genere non richiedono l'allocazione dell'heap.</span><span class="sxs-lookup"><span data-stu-id="c414a-148">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="c414a-149">I tipi struct non supportano l'ereditarietà specificata dall'utente e tutti i tipi struct ereditano implicitamente dal tipo `object` .</span><span class="sxs-lookup"><span data-stu-id="c414a-149">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="c414a-150">Un tipo `interface` definisce un contratto come un set denominato di membri funzione pubblici.</span><span class="sxs-lookup"><span data-stu-id="c414a-150">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="c414a-151">Un oggetto `class` o `struct` che implementa un oggetto `interface` deve fornire implementazioni dei membri della funzione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c414a-151">A `class` or `struct` that implements an `interface` must provide implementations of the interface's function members.</span></span> <span data-ttu-id="c414a-152">Un tipo `interface` può ereditare da più interfacce di base e un tipo `class` o `struct` può implementare più interfacce.</span><span class="sxs-lookup"><span data-stu-id="c414a-152">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="c414a-153">Un tipo `delegate` rappresenta i riferimenti ai metodi, con un elenco di parametri e un tipo restituito particolari.</span><span class="sxs-lookup"><span data-stu-id="c414a-153">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="c414a-154">I delegati consentono di trattare i metodi come entità che è possibile assegnare a variabili e passare come parametri.</span><span class="sxs-lookup"><span data-stu-id="c414a-154">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="c414a-155">I delegati sono analoghi ai tipi funzione forniti dai linguaggi funzionali.</span><span class="sxs-lookup"><span data-stu-id="c414a-155">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="c414a-156">Sono anche simili al concetto di puntatori a funzione disponibili in altri linguaggi.</span><span class="sxs-lookup"><span data-stu-id="c414a-156">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="c414a-157">A differenza dei puntatori a funzione, i delegati sono orientati agli oggetti e indipendenti dai tipi.</span><span class="sxs-lookup"><span data-stu-id="c414a-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="c414a-158">I `class` tipi,, `struct` `interface` e `delegate` supportano tutti i generics, in base ai quali possono essere parametrizzati con altri tipi.</span><span class="sxs-lookup"><span data-stu-id="c414a-158">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="c414a-159">Un tipo `enum` è un tipo distinto con costanti denominate.</span><span class="sxs-lookup"><span data-stu-id="c414a-159">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="c414a-160">Ogni tipo `enum` ha un tipo sottostante, che deve essere uno degli otto tipi integrali.</span><span class="sxs-lookup"><span data-stu-id="c414a-160">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="c414a-161">Il set di valori di un tipo `enum` coincide con il set di valori del tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="c414a-161">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="c414a-162">C# supporta matrici unidimensionali e multidimensionali di qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="c414a-162">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="c414a-163">A differenza dei tipi elencati in precedenza, i tipi di matrice non devono essere dichiarati prima di poter essere usati.</span><span class="sxs-lookup"><span data-stu-id="c414a-163">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="c414a-164">Al contrario, i tipi matrice vengono costruiti facendo seguire a un nome di tipo delle parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="c414a-164">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="c414a-165">Ad esempio, `int[]` è una matrice unidimensionale di `int`, `int[,]` è una matrice bidimensionale di `int` e `int[][]` è una matrice unidimensionale di matrici unidimensionali di `int`.</span><span class="sxs-lookup"><span data-stu-id="c414a-165">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="c414a-166">Anche i tipi di valore nullable non devono essere dichiarati prima di poter essere usati.</span><span class="sxs-lookup"><span data-stu-id="c414a-166">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="c414a-167">Per ogni tipo di valore che non ammette i valori null `T` , esiste un tipo di valore nullable corrispondente `T?` , che può avere un valore aggiuntivo, `null` .</span><span class="sxs-lookup"><span data-stu-id="c414a-167">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="c414a-168">Ad esempio, `int?` è un tipo che può contenere qualsiasi Integer a 32 bit o il valore `null`.</span><span class="sxs-lookup"><span data-stu-id="c414a-168">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="c414a-169">Il sistema di tipi di C# è unificato in modo che un valore di qualsiasi tipo possa essere considerato come un `object` .</span><span class="sxs-lookup"><span data-stu-id="c414a-169">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="c414a-170">In C# ogni tipo deriva direttamente o indirettamente dal tipo classe `object` e `object` è la classe di base principale di tutti i tipi.</span><span class="sxs-lookup"><span data-stu-id="c414a-170">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="c414a-171">I valori dei tipi riferimento vengono trattati come oggetti semplicemente visualizzando tali valori come tipi `object`.</span><span class="sxs-lookup"><span data-stu-id="c414a-171">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="c414a-172">I valori dei tipi valore vengono trattati come oggetti mediante l'esecuzione di operazioni di *boxing* e *unboxing*.</span><span class="sxs-lookup"><span data-stu-id="c414a-172">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="c414a-173">Nell'esempio seguente un valore `int` viene convertito in `object` e quindi convertito nuovamente in `int`.</span><span class="sxs-lookup"><span data-stu-id="c414a-173">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="c414a-174">Quando un valore di un tipo di valore viene assegnato a un `object` riferimento, viene allocata una "casella" per conservare il valore.</span><span class="sxs-lookup"><span data-stu-id="c414a-174">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="c414a-175">Questa casella è un'istanza di un tipo di riferimento e il valore viene copiato in tale casella.</span><span class="sxs-lookup"><span data-stu-id="c414a-175">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="c414a-176">Viceversa, quando `object` viene eseguito il cast di un riferimento a un tipo valore, viene eseguito un controllo che l'oggetto a cui si fa riferimento `object` è una casella del tipo di valore corretto.</span><span class="sxs-lookup"><span data-stu-id="c414a-176">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="c414a-177">Se il controllo ha esito positivo, il valore nella casella viene copiato nel tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="c414a-177">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="c414a-178">Il sistema di tipi unificato di C# significa che i tipi di valore vengono considerati come `object` Riferimenti "su richiesta".</span><span class="sxs-lookup"><span data-stu-id="c414a-178">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="c414a-179">A causa dell'unificazione, le librerie di uso generico che usano il tipo `object` possono essere usate con tutti i tipi che derivano da `object` , inclusi sia i tipi di riferimento che i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="c414a-179">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="c414a-180">In C# sono disponibili diversi tipi di *variabili*, inclusi campi, elementi matrice, variabili locali e parametri.</span><span class="sxs-lookup"><span data-stu-id="c414a-180">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="c414a-181">Le variabili rappresentano posizioni di archiviazione e ogni variabile dispone di un tipo che determina quali valori possono essere archiviati nella variabile stessa, come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="c414a-181">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="c414a-182">Tipo valore non-nullable</span><span class="sxs-lookup"><span data-stu-id="c414a-182">Non-nullable value type</span></span>
  - <span data-ttu-id="c414a-183">Valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="c414a-183">A value of that exact type</span></span>
- <span data-ttu-id="c414a-184">Tipo valore nullable</span><span class="sxs-lookup"><span data-stu-id="c414a-184">Nullable value type</span></span>
  - <span data-ttu-id="c414a-185">Valore `null` o valore esattamente del tipo indicato</span><span class="sxs-lookup"><span data-stu-id="c414a-185">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="c414a-186">object</span><span class="sxs-lookup"><span data-stu-id="c414a-186">object</span></span>
  - <span data-ttu-id="c414a-187">Riferimento `null`, riferimento a un oggetto di qualsiasi tipo riferimento oppure riferimento a un valore boxed di qualsiasi tipo valore</span><span class="sxs-lookup"><span data-stu-id="c414a-187">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="c414a-188">Tipo classe</span><span class="sxs-lookup"><span data-stu-id="c414a-188">Class type</span></span>
  - <span data-ttu-id="c414a-189">Riferimento `null`, riferimento a un'istanza del tipo classe oppure riferimento a un'istanza di una classe derivata dal tipo classe</span><span class="sxs-lookup"><span data-stu-id="c414a-189">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="c414a-190">Tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="c414a-190">Interface type</span></span>
  - <span data-ttu-id="c414a-191">Riferimento `null`, riferimento a un'istanza di un tipo classe che implementa il tipo interfaccia oppure riferimento a un valore boxed di un tipo valore che implementa il tipo interfaccia</span><span class="sxs-lookup"><span data-stu-id="c414a-191">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="c414a-192">Tipo matrice</span><span class="sxs-lookup"><span data-stu-id="c414a-192">Array type</span></span>
  - <span data-ttu-id="c414a-193">Riferimento `null`, riferimento a un'istanza del tipo matrice oppure riferimento a un'istanza di un tipo matrice compatibile</span><span class="sxs-lookup"><span data-stu-id="c414a-193">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="c414a-194">Tipo delegato</span><span class="sxs-lookup"><span data-stu-id="c414a-194">Delegate type</span></span>
  - <span data-ttu-id="c414a-195">Riferimento `null` oppure riferimento a un'istanza di un tipo delegato compatibile</span><span class="sxs-lookup"><span data-stu-id="c414a-195">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="c414a-196">[Precedente](program-structure.md) 
>  [Avanti](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="c414a-196">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
